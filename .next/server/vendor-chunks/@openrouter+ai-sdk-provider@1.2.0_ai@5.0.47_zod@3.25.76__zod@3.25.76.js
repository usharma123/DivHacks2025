"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@openrouter+ai-sdk-provider@1.2.0_ai@5.0.47_zod@3.25.76__zod@3.25.76";
exports.ids = ["vendor-chunks/@openrouter+ai-sdk-provider@1.2.0_ai@5.0.47_zod@3.25.76__zod@3.25.76"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@openrouter+ai-sdk-provider@1.2.0_ai@5.0.47_zod@3.25.76__zod@3.25.76/node_modules/@openrouter/ai-sdk-provider/dist/index.mjs":
/*!*********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@openrouter+ai-sdk-provider@1.2.0_ai@5.0.47_zod@3.25.76__zod@3.25.76/node_modules/@openrouter/ai-sdk-provider/dist/index.mjs ***!
  \*********************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OpenRouter: () => (/* binding */ OpenRouter),\n/* harmony export */   createOpenRouter: () => (/* binding */ createOpenRouter),\n/* harmony export */   openrouter: () => (/* binding */ openrouter)\n/* harmony export */ });\n/* harmony import */ var zod_v4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod/v4 */ \"(rsc)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/schemas.js\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// node_modules/.pnpm/@ai-sdk+provider@2.0.0/node_modules/@ai-sdk/provider/dist/index.mjs\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError2 extends Error {\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name: name14,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a] = true;\n    this.name = name14;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error) {\n    return _AISDKError2.hasMarker(error, marker);\n  }\n  static hasMarker(error, marker15) {\n    const markerSymbol = Symbol.for(marker15);\n    return error != null && typeof error === \"object\" && markerSymbol in error && typeof error[markerSymbol] === \"boolean\" && error[markerSymbol] === true;\n  }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar APICallError = class extends AISDKError {\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null && (statusCode === 408 || // request timeout\n    statusCode === 409 || // conflict\n    statusCode === 429 || // too many requests\n    statusCode >= 500),\n    // server error\n    data\n  }) {\n    super({ name, message, cause });\n    this[_a2] = true;\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker2);\n  }\n};\n_a2 = symbol2;\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar EmptyResponseBodyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message = \"Empty response body\" } = {}) {\n    super({ name: name2, message });\n    this[_a3] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker3);\n  }\n};\n_a3 = symbol3;\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\nvar name3 = \"AI_InvalidArgumentError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidArgumentError = class extends AISDKError {\n  constructor({\n    message,\n    cause,\n    argument\n  }) {\n    super({ name: name3, message, cause });\n    this[_a4] = true;\n    this.argument = argument;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker4);\n  }\n};\n_a4 = symbol4;\nvar name4 = \"AI_InvalidPromptError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidPromptError = class extends AISDKError {\n  constructor({\n    prompt,\n    message,\n    cause\n  }) {\n    super({ name: name4, message: `Invalid prompt: ${message}`, cause });\n    this[_a5] = true;\n    this.prompt = prompt;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker5);\n  }\n};\n_a5 = symbol5;\nvar name5 = \"AI_InvalidResponseDataError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar InvalidResponseDataError = class extends AISDKError {\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`\n  }) {\n    super({ name: name5, message });\n    this[_a6] = true;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker6);\n  }\n};\n_a6 = symbol6;\nvar name6 = \"AI_JSONParseError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar JSONParseError = class extends AISDKError {\n  constructor({ text, cause }) {\n    super({\n      name: name6,\n      message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a7] = true;\n    this.text = text;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker7);\n  }\n};\n_a7 = symbol7;\nvar name7 = \"AI_LoadAPIKeyError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar LoadAPIKeyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name7, message });\n    this[_a8] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker8);\n  }\n};\n_a8 = symbol8;\nvar name8 = \"AI_LoadSettingError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\n_a9 = symbol9;\nvar name9 = \"AI_NoContentGeneratedError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\n_a10 = symbol10;\nvar name10 = \"AI_NoSuchModelError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\n_a11 = symbol11;\nvar name11 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\n_a12 = symbol12;\nvar name12 = \"AI_TypeValidationError\";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar _TypeValidationError = class _TypeValidationError2 extends AISDKError {\n  constructor({ value, cause }) {\n    super({\n      name: name12,\n      message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a13] = true;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker13);\n  }\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause\n  }) {\n    return _TypeValidationError2.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError2({ value, cause });\n  }\n};\n_a13 = symbol13;\nvar TypeValidationError = _TypeValidationError;\nvar name13 = \"AI_UnsupportedFunctionalityError\";\nvar marker14 = `vercel.ai.error.${name13}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar UnsupportedFunctionalityError = class extends AISDKError {\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`\n  }) {\n    super({ name: name13, message });\n    this[_a14] = true;\n    this.functionality = functionality;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker14);\n  }\n};\n_a14 = symbol14;\n\n// node_modules/.pnpm/eventsource-parser@3.0.3/node_modules/eventsource-parser/dist/index.js\nvar ParseError = class extends Error {\n  constructor(message, options) {\n    super(message), this.name = \"ParseError\", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;\n  }\n};\nfunction noop(_arg) {\n}\nfunction createParser(callbacks) {\n  if (typeof callbacks == \"function\")\n    throw new TypeError(\n      \"`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?\"\n    );\n  const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;\n  let incompleteLine = \"\", isFirstChunk = true, id, data = \"\", eventType = \"\";\n  function feed(newChunk) {\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, \"\") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);\n    for (const line of complete)\n      parseLine(line);\n    incompleteLine = incomplete, isFirstChunk = false;\n  }\n  function parseLine(line) {\n    if (line === \"\") {\n      dispatchEvent();\n      return;\n    }\n    if (line.startsWith(\":\")) {\n      onComment && onComment(line.slice(line.startsWith(\": \") ? 2 : 1));\n      return;\n    }\n    const fieldSeparatorIndex = line.indexOf(\":\");\n    if (fieldSeparatorIndex !== -1) {\n      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === \" \" ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);\n      processField(field, value, line);\n      return;\n    }\n    processField(line, \"\", line);\n  }\n  function processField(field, value, line) {\n    switch (field) {\n      case \"event\":\n        eventType = value;\n        break;\n      case \"data\":\n        data = `${data}${value}\n`;\n        break;\n      case \"id\":\n        id = value.includes(\"\\0\") ? void 0 : value;\n        break;\n      case \"retry\":\n        /^\\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(\n          new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n            type: \"invalid-retry\",\n            value,\n            line\n          })\n        );\n        break;\n      default:\n        onError(\n          new ParseError(\n            `Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}\\u2026` : field}\"`,\n            { type: \"unknown-field\", field, value, line }\n          )\n        );\n        break;\n    }\n  }\n  function dispatchEvent() {\n    data.length > 0 && onEvent({\n      id,\n      event: eventType || void 0,\n      // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n      // then remove the last character from the data buffer.\n      data: data.endsWith(`\n`) ? data.slice(0, -1) : data\n    }), id = void 0, data = \"\", eventType = \"\";\n  }\n  function reset(options = {}) {\n    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = \"\", eventType = \"\", incompleteLine = \"\";\n  }\n  return { feed, reset };\n}\nfunction splitLines(chunk) {\n  const lines = [];\n  let incompleteLine = \"\", searchIndex = 0;\n  for (; searchIndex < chunk.length; ) {\n    const crIndex = chunk.indexOf(\"\\r\", searchIndex), lfIndex = chunk.indexOf(`\n`, searchIndex);\n    let lineEnd = -1;\n    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {\n      incompleteLine = chunk.slice(searchIndex);\n      break;\n    } else {\n      const line = chunk.slice(searchIndex, lineEnd);\n      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === \"\\r\" && chunk[searchIndex] === `\n` && searchIndex++;\n    }\n  }\n  return [lines, incompleteLine];\n}\n\n// node_modules/.pnpm/eventsource-parser@3.0.3/node_modules/eventsource-parser/dist/stream.js\nvar EventSourceParserStream = class extends TransformStream {\n  constructor({ onError, onRetry, onComment } = {}) {\n    let parser;\n    super({\n      start(controller) {\n        parser = createParser({\n          onEvent: (event) => {\n            controller.enqueue(event);\n          },\n          onError(error) {\n            onError === \"terminate\" ? controller.error(error) : typeof onError == \"function\" && onError(error);\n          },\n          onRetry,\n          onComment\n        });\n      },\n      transform(chunk) {\n        parser.feed(chunk);\n      }\n    });\n  }\n};\n\n// node_modules/.pnpm/@ai-sdk+provider-utils@3.0.1_zod@3.25.76/node_modules/@ai-sdk/provider-utils/dist/index.mjs\n\n\n// node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/Options.js\nvar ignoreOverride = Symbol(\"Let zodToJsonSchema decide on which parser to use\");\n\n// node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/selectParser.js\n\n\n// node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/array.js\n\n\n// node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/record.js\n\n\n// node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/string.js\nvar ALPHA_NUMERIC = new Set(\"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\");\n\n// node_modules/.pnpm/@ai-sdk+provider-utils@3.0.1_zod@3.25.76/node_modules/@ai-sdk/provider-utils/dist/index.mjs\nfunction combineHeaders(...headers) {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => __spreadValues(__spreadValues({}, combinedHeaders), currentHeaders != null ? currentHeaders : {}),\n    {}\n  );\n}\nfunction extractResponseHeaders(response) {\n  return Object.fromEntries([...response.headers]);\n}\nvar createIdGenerator = ({\n  prefix,\n  size = 16,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  separator = \"-\"\n} = {}) => {\n  const generator = () => {\n    const alphabetLength = alphabet.length;\n    const chars = new Array(size);\n    for (let i = 0; i < size; i++) {\n      chars[i] = alphabet[Math.random() * alphabetLength | 0];\n    }\n    return chars.join(\"\");\n  };\n  if (prefix == null) {\n    return generator;\n  }\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: \"separator\",\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`\n    });\n  }\n  return () => `${prefix}${separator}${generator()}`;\n};\nvar generateId = createIdGenerator();\nfunction isAbortError(error) {\n  return (error instanceof Error || error instanceof DOMException) && (error.name === \"AbortError\" || error.name === \"ResponseAborted\" || // Next.js\n  error.name === \"TimeoutError\");\n}\nvar FETCH_FAILED_ERROR_MESSAGES = [\"fetch failed\", \"failed to fetch\"];\nfunction handleFetchError({\n  error,\n  url,\n  requestBodyValues\n}) {\n  if (isAbortError(error)) {\n    return error;\n  }\n  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())) {\n    const cause = error.cause;\n    if (cause != null) {\n      return new APICallError({\n        message: `Cannot connect to API: ${cause.message}`,\n        cause,\n        url,\n        requestBodyValues,\n        isRetryable: true\n        // retry when network error\n      });\n    }\n  }\n  return error;\n}\nfunction removeUndefinedEntries(record) {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null)\n  );\n}\nfunction loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description\n}) {\n  if (typeof apiKey === \"string\") {\n    return apiKey;\n  }\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  apiKey = process.env[environmentVariableName];\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof apiKey !== \"string\") {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return apiKey;\n}\nvar suspectProtoRx = /\"__proto__\"\\s*:/;\nvar suspectConstructorRx = /\"constructor\"\\s*:/;\nfunction _parse(text) {\n  const obj = JSON.parse(text);\n  if (obj === null || typeof obj !== \"object\") {\n    return obj;\n  }\n  if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n    return obj;\n  }\n  return filter(obj);\n}\nfunction filter(obj) {\n  let next = [obj];\n  while (next.length) {\n    const nodes = next;\n    next = [];\n    for (const node of nodes) {\n      if (Object.prototype.hasOwnProperty.call(node, \"__proto__\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      if (Object.prototype.hasOwnProperty.call(node, \"constructor\") && Object.prototype.hasOwnProperty.call(node.constructor, \"prototype\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      for (const key in node) {\n        const value = node[key];\n        if (value && typeof value === \"object\") {\n          next.push(value);\n        }\n      }\n    }\n  }\n  return obj;\n}\nfunction secureJsonParse(text) {\n  const { stackTraceLimit } = Error;\n  Error.stackTraceLimit = 0;\n  try {\n    return _parse(text);\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n}\nvar validatorSymbol = Symbol.for(\"vercel.ai.validator\");\nfunction validator(validate) {\n  return { [validatorSymbol]: true, validate };\n}\nfunction isValidator(value) {\n  return typeof value === \"object\" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && \"validate\" in value;\n}\nfunction asValidator(value) {\n  return isValidator(value) ? value : standardSchemaValidator(value);\n}\nfunction standardSchemaValidator(standardSchema) {\n  return validator(async (value) => {\n    const result = await standardSchema[\"~standard\"].validate(value);\n    return result.issues == null ? { success: true, value: result.value } : {\n      success: false,\n      error: new TypeValidationError({\n        value,\n        cause: result.issues\n      })\n    };\n  });\n}\nasync function validateTypes({\n  value,\n  schema\n}) {\n  const result = await safeValidateTypes({ value, schema });\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n  return result.value;\n}\nasync function safeValidateTypes({\n  value,\n  schema\n}) {\n  const validator2 = asValidator(schema);\n  try {\n    if (validator2.validate == null) {\n      return { success: true, value, rawValue: value };\n    }\n    const result = await validator2.validate(value);\n    if (result.success) {\n      return { success: true, value: result.value, rawValue: value };\n    }\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n      rawValue: value\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n      rawValue: value\n    };\n  }\n}\nasync function parseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secureJsonParse(text);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (JSONParseError.isInstance(error) || TypeValidationError.isInstance(error)) {\n      throw error;\n    }\n    throw new JSONParseError({ text, cause: error });\n  }\n}\nasync function safeParseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secureJsonParse(text);\n    if (schema == null) {\n      return { success: true, value, rawValue: value };\n    }\n    return await safeValidateTypes({ value, schema });\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error) ? error : new JSONParseError({ text, cause: error }),\n      rawValue: void 0\n    };\n  }\n}\nfunction isParsableJson(input) {\n  try {\n    secureJsonParse(input);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction parseJsonEventStream({\n  stream,\n  schema\n}) {\n  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(\n    new TransformStream({\n      async transform({ data }, controller) {\n        if (data === \"[DONE]\") {\n          return;\n        }\n        controller.enqueue(await safeParseJSON({ text: data, schema }));\n      }\n    })\n  );\n}\nvar getOriginalFetch2 = () => globalThis.fetch;\nvar postJsonToApi = async ({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers: __spreadValues({\n    \"Content-Type\": \"application/json\"\n  }, headers),\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postToApi = async ({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch2()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n        throw new APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error) {\n    throw handleFetchError({ error, url, requestBodyValues: body.values });\n  }\n};\nvar createJsonErrorResponseHandler = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = await parseJSON({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: errorToMessage(parsedError),\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new EmptyResponseBodyError({});\n  }\n  return {\n    responseHeaders,\n    value: parseJsonEventStream({\n      stream: response.body,\n      schema: chunkSchema\n    })\n  };\n};\nvar createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const parsedResult = await safeParseJSON({\n    text: responseBody,\n    schema: responseSchema\n  });\n  const responseHeaders = extractResponseHeaders(response);\n  if (!parsedResult.success) {\n    throw new APICallError({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value,\n    rawValue: parsedResult.rawValue\n  };\n};\nvar schemaSymbol = Symbol.for(\"vercel.ai.schema\");\nvar { btoa, atob } = globalThis;\nfunction convertUint8ArrayToBase64(array) {\n  let latin1string = \"\";\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n  return btoa(latin1string);\n}\nfunction withoutTrailingSlash(url) {\n  return url == null ? void 0 : url.replace(/\\/$/, \"\");\n}\n\n// src/schemas/reasoning-details.ts\n\nvar ReasoningDetailSummarySchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"reasoning.summary\" /* Summary */),\n  summary: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string()\n});\nvar ReasoningDetailEncryptedSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"reasoning.encrypted\" /* Encrypted */),\n  data: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string()\n});\nvar ReasoningDetailTextSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"reasoning.text\" /* Text */),\n  text: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish(),\n  signature: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish()\n});\nvar ReasoningDetailUnionSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.union([\n  ReasoningDetailSummarySchema,\n  ReasoningDetailEncryptedSchema,\n  ReasoningDetailTextSchema\n]);\nvar ReasoningDetailsWithUnknownSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.union([\n  ReasoningDetailUnionSchema,\n  zod_v4__WEBPACK_IMPORTED_MODULE_0__.unknown().transform(() => null)\n]);\nvar ReasoningDetailArraySchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(ReasoningDetailsWithUnknownSchema).transform((d) => d.filter((d2) => !!d2));\n\n// src/schemas/error-response.ts\n\nvar OpenRouterErrorResponseSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n  error: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n    code: zod_v4__WEBPACK_IMPORTED_MODULE_0__.union([zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()]).nullable().optional().default(null),\n    message: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullable().optional().default(null),\n    param: zod_v4__WEBPACK_IMPORTED_MODULE_0__.any().nullable().optional().default(null)\n  })\n});\nvar openrouterFailedResponseHandler = createJsonErrorResponseHandler({\n  errorSchema: OpenRouterErrorResponseSchema,\n  errorToMessage: (data) => data.error.message\n});\n\n// src/utils/map-finish-reason.ts\nfunction mapOpenRouterFinishReason(finishReason) {\n  switch (finishReason) {\n    case \"stop\":\n      return \"stop\";\n    case \"length\":\n      return \"length\";\n    case \"content_filter\":\n      return \"content-filter\";\n    case \"function_call\":\n    case \"tool_calls\":\n      return \"tool-calls\";\n    default:\n      return \"unknown\";\n  }\n}\n\n// src/chat/is-url.ts\nfunction isUrl({\n  url,\n  protocols\n}) {\n  try {\n    const urlObj = new URL(url);\n    return protocols.has(urlObj.protocol);\n  } catch (_) {\n    return false;\n  }\n}\n\n// src/chat/file-url-utils.ts\nfunction getFileUrl({\n  part,\n  defaultMediaType\n}) {\n  var _a15, _b;\n  if (part.data instanceof Uint8Array) {\n    const base64 = convertUint8ArrayToBase64(part.data);\n    return `data:${(_a15 = part.mediaType) != null ? _a15 : defaultMediaType};base64,${base64}`;\n  }\n  const stringUrl = part.data.toString();\n  if (isUrl({\n    url: stringUrl,\n    protocols: /* @__PURE__ */ new Set([\"http:\", \"https:\"])\n  })) {\n    return stringUrl;\n  }\n  return stringUrl.startsWith(\"data:\") ? stringUrl : `data:${(_b = part.mediaType) != null ? _b : defaultMediaType};base64,${stringUrl}`;\n}\nfunction getMediaType(dataUrl, defaultMediaType) {\n  var _a15;\n  const match = dataUrl.match(/^data:([^;]+)/);\n  return match ? (_a15 = match[1]) != null ? _a15 : defaultMediaType : defaultMediaType;\n}\nfunction getBase64FromDataUrl(dataUrl) {\n  const match = dataUrl.match(/^data:[^;]*;base64,(.+)$/);\n  return match ? match[1] : dataUrl;\n}\n\n// src/chat/convert-to-openrouter-chat-messages.ts\nfunction getCacheControl(providerMetadata) {\n  var _a15, _b, _c;\n  const anthropic = providerMetadata == null ? void 0 : providerMetadata.anthropic;\n  const openrouter2 = providerMetadata == null ? void 0 : providerMetadata.openrouter;\n  return (_c = (_b = (_a15 = openrouter2 == null ? void 0 : openrouter2.cacheControl) != null ? _a15 : openrouter2 == null ? void 0 : openrouter2.cache_control) != null ? _b : anthropic == null ? void 0 : anthropic.cacheControl) != null ? _c : anthropic == null ? void 0 : anthropic.cache_control;\n}\nfunction convertToOpenRouterChatMessages(prompt) {\n  var _a15, _b, _c;\n  const messages = [];\n  for (const { role, content, providerOptions } of prompt) {\n    switch (role) {\n      case \"system\": {\n        messages.push({\n          role: \"system\",\n          content,\n          cache_control: getCacheControl(providerOptions)\n        });\n        break;\n      }\n      case \"user\": {\n        if (content.length === 1 && ((_a15 = content[0]) == null ? void 0 : _a15.type) === \"text\") {\n          const cacheControl = (_b = getCacheControl(providerOptions)) != null ? _b : getCacheControl(content[0].providerOptions);\n          const contentWithCacheControl = cacheControl ? [\n            {\n              type: \"text\",\n              text: content[0].text,\n              cache_control: cacheControl\n            }\n          ] : content[0].text;\n          messages.push({\n            role: \"user\",\n            content: contentWithCacheControl\n          });\n          break;\n        }\n        const messageCacheControl = getCacheControl(providerOptions);\n        const contentParts = content.map(\n          (part) => {\n            var _a16, _b2, _c2, _d, _e, _f;\n            const cacheControl = (_a16 = getCacheControl(part.providerOptions)) != null ? _a16 : messageCacheControl;\n            switch (part.type) {\n              case \"text\":\n                return {\n                  type: \"text\",\n                  text: part.text,\n                  // For text parts, only use part-specific cache control\n                  cache_control: cacheControl\n                };\n              case \"file\": {\n                if ((_b2 = part.mediaType) == null ? void 0 : _b2.startsWith(\"image/\")) {\n                  const url = getFileUrl({\n                    part,\n                    defaultMediaType: \"image/jpeg\"\n                  });\n                  return {\n                    type: \"image_url\",\n                    image_url: {\n                      url\n                    },\n                    // For image parts, use part-specific or message-level cache control\n                    cache_control: cacheControl\n                  };\n                }\n                const fileName = String(\n                  (_f = (_e = (_d = (_c2 = part.providerOptions) == null ? void 0 : _c2.openrouter) == null ? void 0 : _d.filename) != null ? _e : part.filename) != null ? _f : \"\"\n                );\n                const fileData = getFileUrl({\n                  part,\n                  defaultMediaType: \"application/pdf\"\n                });\n                if (isUrl({\n                  url: fileData,\n                  protocols: /* @__PURE__ */ new Set([\"http:\", \"https:\"])\n                })) {\n                  return {\n                    type: \"file\",\n                    file: {\n                      filename: fileName,\n                      file_data: fileData\n                    }\n                  };\n                }\n                return {\n                  type: \"file\",\n                  file: {\n                    filename: fileName,\n                    file_data: fileData\n                  },\n                  cache_control: cacheControl\n                };\n              }\n              default: {\n                return {\n                  type: \"text\",\n                  text: \"\",\n                  cache_control: cacheControl\n                };\n              }\n            }\n          }\n        );\n        messages.push({\n          role: \"user\",\n          content: contentParts\n        });\n        break;\n      }\n      case \"assistant\": {\n        let text = \"\";\n        let reasoning = \"\";\n        const reasoningDetails = [];\n        const toolCalls = [];\n        for (const part of content) {\n          switch (part.type) {\n            case \"text\": {\n              text += part.text;\n              break;\n            }\n            case \"tool-call\": {\n              toolCalls.push({\n                id: part.toolCallId,\n                type: \"function\",\n                function: {\n                  name: part.toolName,\n                  arguments: JSON.stringify(part.input)\n                }\n              });\n              break;\n            }\n            case \"reasoning\": {\n              reasoning += part.text;\n              reasoningDetails.push({\n                type: \"reasoning.text\" /* Text */,\n                text: part.text\n              });\n              break;\n            }\n            case \"file\":\n              break;\n            default: {\n              break;\n            }\n          }\n        }\n        messages.push({\n          role: \"assistant\",\n          content: text,\n          tool_calls: toolCalls.length > 0 ? toolCalls : void 0,\n          reasoning: reasoning || void 0,\n          reasoning_details: reasoningDetails.length > 0 ? reasoningDetails : void 0,\n          cache_control: getCacheControl(providerOptions)\n        });\n        break;\n      }\n      case \"tool\": {\n        for (const toolResponse of content) {\n          const content2 = getToolResultContent(toolResponse);\n          messages.push({\n            role: \"tool\",\n            tool_call_id: toolResponse.toolCallId,\n            content: content2,\n            cache_control: (_c = getCacheControl(providerOptions)) != null ? _c : getCacheControl(toolResponse.providerOptions)\n          });\n        }\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n  }\n  return messages;\n}\nfunction getToolResultContent(input) {\n  return input.output.type === \"text\" ? input.output.value : JSON.stringify(input.output.value);\n}\n\n// src/chat/get-tool-choice.ts\n\nvar ChatCompletionToolChoiceSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.union([\n  zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"auto\"),\n  zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"none\"),\n  zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"required\"),\n  zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"function\"),\n    function: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n      name: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string()\n    })\n  })\n]);\nfunction getChatCompletionToolChoice(toolChoice) {\n  switch (toolChoice.type) {\n    case \"auto\":\n    case \"none\":\n    case \"required\":\n      return toolChoice.type;\n    case \"tool\": {\n      return {\n        type: \"function\",\n        function: { name: toolChoice.toolName }\n      };\n    }\n    default: {\n      toolChoice;\n      throw new Error(`Invalid tool choice type: ${toolChoice}`);\n    }\n  }\n}\n\n// src/chat/schemas.ts\n\n\n// src/schemas/image.ts\n\nvar ImageResponseSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"image_url\"),\n  image_url: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n    url: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string()\n  })\n});\nvar ImageResponseWithUnknownSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.union([\n  ImageResponseSchema,\n  zod_v4__WEBPACK_IMPORTED_MODULE_0__.unknown().transform(() => null)\n]);\nvar ImageResponseArraySchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(ImageResponseWithUnknownSchema).transform((d) => d.filter((d2) => !!d2));\n\n// src/chat/schemas.ts\nvar OpenRouterChatCompletionBaseResponseSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n  id: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n  model: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n  provider: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n  usage: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n    prompt_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n    prompt_tokens_details: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n      cached_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()\n    }).nullish(),\n    completion_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n    completion_tokens_details: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n      reasoning_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()\n    }).nullish(),\n    total_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n    cost: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().optional(),\n    cost_details: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n      upstream_inference_cost: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().nullish()\n    }).nullish()\n  }).nullish()\n});\nvar OpenRouterNonStreamChatCompletionResponseSchema = OpenRouterChatCompletionBaseResponseSchema.extend({\n  choices: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n    zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n      message: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n        role: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"assistant\"),\n        content: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullable().optional(),\n        reasoning: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullable().optional(),\n        reasoning_details: ReasoningDetailArraySchema.nullish(),\n        images: ImageResponseArraySchema.nullish(),\n        tool_calls: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n          zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n            id: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional().nullable(),\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"function\"),\n            function: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n              name: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n              arguments: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string()\n            })\n          })\n        ).optional(),\n        annotations: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n          zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\"url_citation\"]),\n            url_citation: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n              end_index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n              start_index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n              title: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n              url: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n              content: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional()\n            })\n          })\n        ).nullish()\n      }),\n      index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().nullish(),\n      logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n        content: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n          zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n            token: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n            logprob: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n            top_logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n              zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n                token: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n                logprob: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()\n              })\n            )\n          })\n        ).nullable()\n      }).nullable().optional(),\n      finish_reason: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional().nullable()\n    })\n  )\n});\nvar OpenRouterStreamChatCompletionChunkSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.union([\n  OpenRouterChatCompletionBaseResponseSchema.extend({\n    choices: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n      zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n        delta: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n          role: zod_v4__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\"assistant\"]).optional(),\n          content: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish(),\n          reasoning: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish().optional(),\n          reasoning_details: ReasoningDetailArraySchema.nullish(),\n          images: ImageResponseArraySchema.nullish(),\n          tool_calls: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n            zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n              index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().nullish(),\n              id: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish(),\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"function\").optional(),\n              function: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n                name: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish(),\n                arguments: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish()\n              })\n            })\n          ).nullish(),\n          annotations: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n            zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\"url_citation\"]),\n              url_citation: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n                end_index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n                start_index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n                title: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n                url: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n                content: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional()\n              })\n            })\n          ).nullish()\n        }).nullish(),\n        logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n          content: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n            zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n              token: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n              logprob: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n              top_logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n                zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n                  token: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n                  logprob: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()\n                })\n              )\n            })\n          ).nullable()\n        }).nullish(),\n        finish_reason: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullable().optional(),\n        index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().nullish()\n      })\n    )\n  }),\n  OpenRouterErrorResponseSchema\n]);\n\n// src/chat/index.ts\nvar OpenRouterChatLanguageModel = class {\n  constructor(modelId, settings, config) {\n    this.specificationVersion = \"v2\";\n    this.provider = \"openrouter\";\n    this.defaultObjectGenerationMode = \"tool\";\n    this.supportedUrls = {\n      \"image/*\": [\n        /^data:image\\/[a-zA-Z]+;base64,/,\n        /^https?:\\/\\/.+\\.(jpg|jpeg|png|gif|webp)$/i\n      ],\n      // 'text/*': [/^data:text\\//, /^https?:\\/\\/.+$/],\n      \"application/*\": [/^data:application\\//, /^https?:\\/\\/.+$/]\n    };\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n  getArgs({\n    prompt,\n    maxOutputTokens,\n    temperature,\n    topP,\n    frequencyPenalty,\n    presencePenalty,\n    seed,\n    stopSequences,\n    responseFormat,\n    topK,\n    tools,\n    toolChoice\n  }) {\n    var _a15;\n    const baseArgs = __spreadValues(__spreadValues({\n      // model id:\n      model: this.modelId,\n      models: this.settings.models,\n      // model specific settings:\n      logit_bias: this.settings.logitBias,\n      logprobs: this.settings.logprobs === true || typeof this.settings.logprobs === \"number\" ? true : void 0,\n      top_logprobs: typeof this.settings.logprobs === \"number\" ? this.settings.logprobs : typeof this.settings.logprobs === \"boolean\" ? this.settings.logprobs ? 0 : void 0 : void 0,\n      user: this.settings.user,\n      parallel_tool_calls: this.settings.parallelToolCalls,\n      // standardized settings:\n      max_tokens: maxOutputTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      seed,\n      stop: stopSequences,\n      response_format: responseFormat,\n      top_k: topK,\n      // messages:\n      messages: convertToOpenRouterChatMessages(prompt),\n      // OpenRouter specific settings:\n      include_reasoning: this.settings.includeReasoning,\n      reasoning: this.settings.reasoning,\n      usage: this.settings.usage,\n      // Web search settings:\n      plugins: this.settings.plugins,\n      web_search_options: this.settings.web_search_options,\n      // Provider routing settings:\n      provider: this.settings.provider\n    }, this.config.extraBody), this.settings.extraBody);\n    if ((responseFormat == null ? void 0 : responseFormat.type) === \"json\" && responseFormat.schema != null) {\n      return __spreadProps(__spreadValues({}, baseArgs), {\n        response_format: {\n          type: \"json_schema\",\n          json_schema: __spreadValues({\n            schema: responseFormat.schema,\n            strict: true,\n            name: (_a15 = responseFormat.name) != null ? _a15 : \"response\"\n          }, responseFormat.description && {\n            description: responseFormat.description\n          })\n        }\n      });\n    }\n    if (tools && tools.length > 0) {\n      const mappedTools = tools.filter((tool) => tool.type === \"function\").map((tool) => ({\n        type: \"function\",\n        function: {\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.inputSchema\n        }\n      }));\n      return __spreadProps(__spreadValues({}, baseArgs), {\n        tools: mappedTools,\n        tool_choice: toolChoice ? getChatCompletionToolChoice(toolChoice) : void 0\n      });\n    }\n    return baseArgs;\n  }\n  async doGenerate(options) {\n    var _a15, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;\n    const providerOptions = options.providerOptions || {};\n    const openrouterOptions = providerOptions.openrouter || {};\n    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: \"/chat/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: openrouterFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        OpenRouterNonStreamChatCompletionResponseSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const choice = response.choices[0];\n    if (!choice) {\n      throw new Error(\"No choice in response\");\n    }\n    const usageInfo = response.usage ? {\n      inputTokens: (_a15 = response.usage.prompt_tokens) != null ? _a15 : 0,\n      outputTokens: (_b = response.usage.completion_tokens) != null ? _b : 0,\n      totalTokens: ((_c = response.usage.prompt_tokens) != null ? _c : 0) + ((_d = response.usage.completion_tokens) != null ? _d : 0),\n      reasoningTokens: (_f = (_e = response.usage.completion_tokens_details) == null ? void 0 : _e.reasoning_tokens) != null ? _f : 0,\n      cachedInputTokens: (_h = (_g = response.usage.prompt_tokens_details) == null ? void 0 : _g.cached_tokens) != null ? _h : 0\n    } : {\n      inputTokens: 0,\n      outputTokens: 0,\n      totalTokens: 0,\n      reasoningTokens: 0,\n      cachedInputTokens: 0\n    };\n    const reasoningDetails = (_i = choice.message.reasoning_details) != null ? _i : [];\n    const reasoning = reasoningDetails.length > 0 ? reasoningDetails.map((detail) => {\n      switch (detail.type) {\n        case \"reasoning.text\" /* Text */: {\n          if (detail.text) {\n            return {\n              type: \"reasoning\",\n              text: detail.text\n            };\n          }\n          break;\n        }\n        case \"reasoning.summary\" /* Summary */: {\n          if (detail.summary) {\n            return {\n              type: \"reasoning\",\n              text: detail.summary\n            };\n          }\n          break;\n        }\n        case \"reasoning.encrypted\" /* Encrypted */: {\n          if (detail.data) {\n            return {\n              type: \"reasoning\",\n              text: \"[REDACTED]\"\n            };\n          }\n          break;\n        }\n        default: {\n          detail;\n        }\n      }\n      return null;\n    }).filter((p) => p !== null) : choice.message.reasoning ? [\n      {\n        type: \"reasoning\",\n        text: choice.message.reasoning\n      }\n    ] : [];\n    const content = [];\n    content.push(...reasoning);\n    if (choice.message.content) {\n      content.push({\n        type: \"text\",\n        text: choice.message.content\n      });\n    }\n    if (choice.message.tool_calls) {\n      for (const toolCall of choice.message.tool_calls) {\n        content.push({\n          type: \"tool-call\",\n          toolCallId: (_j = toolCall.id) != null ? _j : generateId(),\n          toolName: toolCall.function.name,\n          input: toolCall.function.arguments\n        });\n      }\n    }\n    if (choice.message.images) {\n      for (const image of choice.message.images) {\n        content.push({\n          type: \"file\",\n          mediaType: getMediaType(image.image_url.url, \"image/jpeg\"),\n          data: getBase64FromDataUrl(image.image_url.url)\n        });\n      }\n    }\n    if (choice.message.annotations) {\n      for (const annotation of choice.message.annotations) {\n        if (annotation.type === \"url_citation\") {\n          content.push({\n            type: \"source\",\n            sourceType: \"url\",\n            id: annotation.url_citation.url,\n            url: annotation.url_citation.url,\n            title: annotation.url_citation.title,\n            providerMetadata: {\n              openrouter: {\n                content: annotation.url_citation.content || \"\"\n              }\n            }\n          });\n        }\n      }\n    }\n    return {\n      content,\n      finishReason: mapOpenRouterFinishReason(choice.finish_reason),\n      usage: usageInfo,\n      warnings: [],\n      providerMetadata: {\n        openrouter: {\n          provider: (_k = response.provider) != null ? _k : \"\",\n          usage: {\n            promptTokens: (_l = usageInfo.inputTokens) != null ? _l : 0,\n            completionTokens: (_m = usageInfo.outputTokens) != null ? _m : 0,\n            totalTokens: (_n = usageInfo.totalTokens) != null ? _n : 0,\n            cost: (_o = response.usage) == null ? void 0 : _o.cost,\n            promptTokensDetails: {\n              cachedTokens: (_r = (_q = (_p = response.usage) == null ? void 0 : _p.prompt_tokens_details) == null ? void 0 : _q.cached_tokens) != null ? _r : 0\n            },\n            completionTokensDetails: {\n              reasoningTokens: (_u = (_t = (_s = response.usage) == null ? void 0 : _s.completion_tokens_details) == null ? void 0 : _t.reasoning_tokens) != null ? _u : 0\n            },\n            costDetails: {\n              upstreamInferenceCost: (_x = (_w = (_v = response.usage) == null ? void 0 : _v.cost_details) == null ? void 0 : _w.upstream_inference_cost) != null ? _x : 0\n            }\n          }\n        }\n      },\n      request: { body: args },\n      response: {\n        id: response.id,\n        modelId: response.model,\n        headers: responseHeaders\n      }\n    };\n  }\n  async doStream(options) {\n    var _a15;\n    const providerOptions = options.providerOptions || {};\n    const openrouterOptions = providerOptions.openrouter || {};\n    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: \"/chat/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: __spreadProps(__spreadValues({}, args), {\n        stream: true,\n        // only include stream_options when in strict compatibility mode:\n        stream_options: this.config.compatibility === \"strict\" ? __spreadValues({\n          include_usage: true\n        }, ((_a15 = this.settings.usage) == null ? void 0 : _a15.include) ? { include_usage: true } : {}) : void 0\n      }),\n      failedResponseHandler: openrouterFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        OpenRouterStreamChatCompletionChunkSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const toolCalls = [];\n    let finishReason = \"other\";\n    const usage = {\n      inputTokens: Number.NaN,\n      outputTokens: Number.NaN,\n      totalTokens: Number.NaN,\n      reasoningTokens: Number.NaN,\n      cachedInputTokens: Number.NaN\n    };\n    const openrouterUsage = {};\n    let textStarted = false;\n    let reasoningStarted = false;\n    let textId;\n    let reasoningId;\n    let openrouterResponseId;\n    let provider;\n    return {\n      stream: response.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            var _a16, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;\n            if (!chunk.success) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: chunk.error });\n              return;\n            }\n            const value = chunk.value;\n            if (\"error\" in value) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: value.error });\n              return;\n            }\n            if (value.provider) {\n              provider = value.provider;\n            }\n            if (value.id) {\n              openrouterResponseId = value.id;\n              controller.enqueue({\n                type: \"response-metadata\",\n                id: value.id\n              });\n            }\n            if (value.model) {\n              controller.enqueue({\n                type: \"response-metadata\",\n                modelId: value.model\n              });\n            }\n            if (value.usage != null) {\n              usage.inputTokens = value.usage.prompt_tokens;\n              usage.outputTokens = value.usage.completion_tokens;\n              usage.totalTokens = value.usage.prompt_tokens + value.usage.completion_tokens;\n              openrouterUsage.promptTokens = value.usage.prompt_tokens;\n              if (value.usage.prompt_tokens_details) {\n                const cachedInputTokens = (_a16 = value.usage.prompt_tokens_details.cached_tokens) != null ? _a16 : 0;\n                usage.cachedInputTokens = cachedInputTokens;\n                openrouterUsage.promptTokensDetails = {\n                  cachedTokens: cachedInputTokens\n                };\n              }\n              openrouterUsage.completionTokens = value.usage.completion_tokens;\n              if (value.usage.completion_tokens_details) {\n                const reasoningTokens = (_b = value.usage.completion_tokens_details.reasoning_tokens) != null ? _b : 0;\n                usage.reasoningTokens = reasoningTokens;\n                openrouterUsage.completionTokensDetails = {\n                  reasoningTokens\n                };\n              }\n              openrouterUsage.cost = value.usage.cost;\n              openrouterUsage.totalTokens = value.usage.total_tokens;\n            }\n            const choice = value.choices[0];\n            if ((choice == null ? void 0 : choice.finish_reason) != null) {\n              finishReason = mapOpenRouterFinishReason(choice.finish_reason);\n            }\n            if ((choice == null ? void 0 : choice.delta) == null) {\n              return;\n            }\n            const delta = choice.delta;\n            const emitReasoningChunk = (chunkText) => {\n              if (!reasoningStarted) {\n                reasoningId = openrouterResponseId || generateId();\n                controller.enqueue({\n                  type: \"reasoning-start\",\n                  id: reasoningId\n                });\n                reasoningStarted = true;\n              }\n              controller.enqueue({\n                type: \"reasoning-delta\",\n                delta: chunkText,\n                id: reasoningId || generateId()\n              });\n            };\n            if (delta.reasoning_details && delta.reasoning_details.length > 0) {\n              for (const detail of delta.reasoning_details) {\n                switch (detail.type) {\n                  case \"reasoning.text\" /* Text */: {\n                    if (detail.text) {\n                      emitReasoningChunk(detail.text);\n                    }\n                    break;\n                  }\n                  case \"reasoning.encrypted\" /* Encrypted */: {\n                    if (detail.data) {\n                      emitReasoningChunk(\"[REDACTED]\");\n                    }\n                    break;\n                  }\n                  case \"reasoning.summary\" /* Summary */: {\n                    if (detail.summary) {\n                      emitReasoningChunk(detail.summary);\n                    }\n                    break;\n                  }\n                  default: {\n                    detail;\n                    break;\n                  }\n                }\n              }\n            } else if (delta.reasoning) {\n              emitReasoningChunk(delta.reasoning);\n            }\n            if (delta.content) {\n              if (reasoningStarted && !textStarted) {\n                controller.enqueue({\n                  type: \"reasoning-end\",\n                  id: reasoningId || generateId()\n                });\n                reasoningStarted = false;\n              }\n              if (!textStarted) {\n                textId = openrouterResponseId || generateId();\n                controller.enqueue({\n                  type: \"text-start\",\n                  id: textId\n                });\n                textStarted = true;\n              }\n              controller.enqueue({\n                type: \"text-delta\",\n                delta: delta.content,\n                id: textId || generateId()\n              });\n            }\n            if (delta.annotations) {\n              for (const annotation of delta.annotations) {\n                if (annotation.type === \"url_citation\") {\n                  controller.enqueue({\n                    type: \"source\",\n                    sourceType: \"url\",\n                    id: annotation.url_citation.url,\n                    url: annotation.url_citation.url,\n                    title: annotation.url_citation.title,\n                    providerMetadata: {\n                      openrouter: {\n                        content: annotation.url_citation.content || \"\"\n                      }\n                    }\n                  });\n                }\n              }\n            }\n            if (delta.tool_calls != null) {\n              for (const toolCallDelta of delta.tool_calls) {\n                const index = (_c = toolCallDelta.index) != null ? _c : toolCalls.length - 1;\n                if (toolCalls[index] == null) {\n                  if (toolCallDelta.type !== \"function\") {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function' type.`\n                    });\n                  }\n                  if (toolCallDelta.id == null) {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'id' to be a string.`\n                    });\n                  }\n                  if (((_d = toolCallDelta.function) == null ? void 0 : _d.name) == null) {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function.name' to be a string.`\n                    });\n                  }\n                  toolCalls[index] = {\n                    id: toolCallDelta.id,\n                    type: \"function\",\n                    function: {\n                      name: toolCallDelta.function.name,\n                      arguments: (_e = toolCallDelta.function.arguments) != null ? _e : \"\"\n                    },\n                    inputStarted: false,\n                    sent: false\n                  };\n                  const toolCall2 = toolCalls[index];\n                  if (toolCall2 == null) {\n                    throw new Error(\"Tool call is missing\");\n                  }\n                  if (((_f = toolCall2.function) == null ? void 0 : _f.name) != null && ((_g = toolCall2.function) == null ? void 0 : _g.arguments) != null && isParsableJson(toolCall2.function.arguments)) {\n                    toolCall2.inputStarted = true;\n                    controller.enqueue({\n                      type: \"tool-input-start\",\n                      id: toolCall2.id,\n                      toolName: toolCall2.function.name\n                    });\n                    controller.enqueue({\n                      type: \"tool-input-delta\",\n                      id: toolCall2.id,\n                      delta: toolCall2.function.arguments\n                    });\n                    controller.enqueue({\n                      type: \"tool-input-end\",\n                      id: toolCall2.id\n                    });\n                    controller.enqueue({\n                      type: \"tool-call\",\n                      toolCallId: toolCall2.id,\n                      toolName: toolCall2.function.name,\n                      input: toolCall2.function.arguments\n                    });\n                    toolCall2.sent = true;\n                  }\n                  continue;\n                }\n                const toolCall = toolCalls[index];\n                if (toolCall == null) {\n                  throw new Error(\"Tool call is missing\");\n                }\n                if (!toolCall.inputStarted) {\n                  toolCall.inputStarted = true;\n                  controller.enqueue({\n                    type: \"tool-input-start\",\n                    id: toolCall.id,\n                    toolName: toolCall.function.name\n                  });\n                }\n                if (((_h = toolCallDelta.function) == null ? void 0 : _h.arguments) != null) {\n                  toolCall.function.arguments += (_j = (_i = toolCallDelta.function) == null ? void 0 : _i.arguments) != null ? _j : \"\";\n                }\n                controller.enqueue({\n                  type: \"tool-input-delta\",\n                  id: toolCall.id,\n                  delta: (_k = toolCallDelta.function.arguments) != null ? _k : \"\"\n                });\n                if (((_l = toolCall.function) == null ? void 0 : _l.name) != null && ((_m = toolCall.function) == null ? void 0 : _m.arguments) != null && isParsableJson(toolCall.function.arguments)) {\n                  controller.enqueue({\n                    type: \"tool-call\",\n                    toolCallId: (_n = toolCall.id) != null ? _n : generateId(),\n                    toolName: toolCall.function.name,\n                    input: toolCall.function.arguments\n                  });\n                  toolCall.sent = true;\n                }\n              }\n            }\n            if (delta.images != null) {\n              for (const image of delta.images) {\n                controller.enqueue({\n                  type: \"file\",\n                  mediaType: getMediaType(image.image_url.url, \"image/jpeg\"),\n                  data: getBase64FromDataUrl(image.image_url.url)\n                });\n              }\n            }\n          },\n          flush(controller) {\n            var _a16;\n            if (finishReason === \"tool-calls\") {\n              for (const toolCall of toolCalls) {\n                if (toolCall && !toolCall.sent) {\n                  controller.enqueue({\n                    type: \"tool-call\",\n                    toolCallId: (_a16 = toolCall.id) != null ? _a16 : generateId(),\n                    toolName: toolCall.function.name,\n                    // Coerce invalid arguments to an empty JSON object\n                    input: isParsableJson(toolCall.function.arguments) ? toolCall.function.arguments : \"{}\"\n                  });\n                  toolCall.sent = true;\n                }\n              }\n            }\n            if (reasoningStarted) {\n              controller.enqueue({\n                type: \"reasoning-end\",\n                id: reasoningId || generateId()\n              });\n            }\n            if (textStarted) {\n              controller.enqueue({\n                type: \"text-end\",\n                id: textId || generateId()\n              });\n            }\n            const openrouterMetadata = {\n              usage: openrouterUsage\n            };\n            if (provider !== void 0) {\n              openrouterMetadata.provider = provider;\n            }\n            controller.enqueue({\n              type: \"finish\",\n              finishReason,\n              usage,\n              providerMetadata: {\n                openrouter: openrouterMetadata\n              }\n            });\n          }\n        })\n      ),\n      warnings: [],\n      request: { body: args },\n      response: { headers: responseHeaders }\n    };\n  }\n};\n\n// src/completion/convert-to-openrouter-completion-prompt.ts\nfunction convertToOpenRouterCompletionPrompt({\n  prompt,\n  inputFormat,\n  user = \"user\",\n  assistant = \"assistant\"\n}) {\n  if (inputFormat === \"prompt\" && prompt.length === 1 && prompt[0] && prompt[0].role === \"user\" && prompt[0].content.length === 1 && prompt[0].content[0] && prompt[0].content[0].type === \"text\") {\n    return { prompt: prompt[0].content[0].text };\n  }\n  let text = \"\";\n  if (prompt[0] && prompt[0].role === \"system\") {\n    text += `${prompt[0].content}\n\n`;\n    prompt = prompt.slice(1);\n  }\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case \"system\": {\n        throw new InvalidPromptError({\n          message: `Unexpected system message in prompt: ${content}`,\n          prompt\n        });\n      }\n      case \"user\": {\n        const userMessage = content.map((part) => {\n          switch (part.type) {\n            case \"text\": {\n              return part.text;\n            }\n            case \"file\": {\n              throw new UnsupportedFunctionalityError({\n                functionality: \"file attachments\"\n              });\n            }\n            default: {\n              return \"\";\n            }\n          }\n        }).join(\"\");\n        text += `${user}:\n${userMessage}\n\n`;\n        break;\n      }\n      case \"assistant\": {\n        const assistantMessage = content.map(\n          (part) => {\n            switch (part.type) {\n              case \"text\": {\n                return part.text;\n              }\n              case \"tool-call\": {\n                throw new UnsupportedFunctionalityError({\n                  functionality: \"tool-call messages\"\n                });\n              }\n              case \"tool-result\": {\n                throw new UnsupportedFunctionalityError({\n                  functionality: \"tool-result messages\"\n                });\n              }\n              case \"reasoning\": {\n                throw new UnsupportedFunctionalityError({\n                  functionality: \"reasoning messages\"\n                });\n              }\n              case \"file\": {\n                throw new UnsupportedFunctionalityError({\n                  functionality: \"file attachments\"\n                });\n              }\n              default: {\n                return \"\";\n              }\n            }\n          }\n        ).join(\"\");\n        text += `${assistant}:\n${assistantMessage}\n\n`;\n        break;\n      }\n      case \"tool\": {\n        throw new UnsupportedFunctionalityError({\n          functionality: \"tool messages\"\n        });\n      }\n      default: {\n        break;\n      }\n    }\n  }\n  text += `${assistant}:\n`;\n  return {\n    prompt: text\n  };\n}\n\n// src/completion/schemas.ts\n\nvar OpenRouterCompletionChunkSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.union([\n  zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n    id: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n    model: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n    choices: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n      zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n        text: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n        reasoning: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish().optional(),\n        reasoning_details: ReasoningDetailArraySchema.nullish(),\n        finish_reason: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish(),\n        index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().nullish(),\n        logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n          tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(zod_v4__WEBPACK_IMPORTED_MODULE_0__.string()),\n          token_logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()),\n          top_logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(zod_v4__WEBPACK_IMPORTED_MODULE_0__.record(zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_0__.number())).nullable()\n        }).nullable().optional()\n      })\n    ),\n    usage: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n      prompt_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n      prompt_tokens_details: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n        cached_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()\n      }).nullish(),\n      completion_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n      completion_tokens_details: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n        reasoning_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()\n      }).nullish(),\n      total_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n      cost: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().optional()\n    }).nullish()\n  }),\n  OpenRouterErrorResponseSchema\n]);\n\n// src/completion/index.ts\nvar OpenRouterCompletionLanguageModel = class {\n  constructor(modelId, settings, config) {\n    this.specificationVersion = \"v2\";\n    this.provider = \"openrouter\";\n    this.supportedUrls = {\n      \"image/*\": [\n        /^data:image\\/[a-zA-Z]+;base64,/,\n        /^https?:\\/\\/.+\\.(jpg|jpeg|png|gif|webp)$/i\n      ],\n      \"text/*\": [/^data:text\\//, /^https?:\\/\\/.+$/],\n      \"application/*\": [/^data:application\\//, /^https?:\\/\\/.+$/]\n    };\n    this.defaultObjectGenerationMode = void 0;\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n  getArgs({\n    prompt,\n    maxOutputTokens,\n    temperature,\n    topP,\n    frequencyPenalty,\n    presencePenalty,\n    seed,\n    responseFormat,\n    topK,\n    stopSequences,\n    tools,\n    toolChoice\n  }) {\n    const { prompt: completionPrompt } = convertToOpenRouterCompletionPrompt({\n      prompt,\n      inputFormat: \"prompt\"\n    });\n    if (tools == null ? void 0 : tools.length) {\n      throw new UnsupportedFunctionalityError({\n        functionality: \"tools\"\n      });\n    }\n    if (toolChoice) {\n      throw new UnsupportedFunctionalityError({\n        functionality: \"toolChoice\"\n      });\n    }\n    return __spreadValues(__spreadValues({\n      // model id:\n      model: this.modelId,\n      models: this.settings.models,\n      // model specific settings:\n      logit_bias: this.settings.logitBias,\n      logprobs: typeof this.settings.logprobs === \"number\" ? this.settings.logprobs : typeof this.settings.logprobs === \"boolean\" ? this.settings.logprobs ? 0 : void 0 : void 0,\n      suffix: this.settings.suffix,\n      user: this.settings.user,\n      // standardized settings:\n      max_tokens: maxOutputTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      seed,\n      stop: stopSequences,\n      response_format: responseFormat,\n      top_k: topK,\n      // prompt:\n      prompt: completionPrompt,\n      // OpenRouter specific settings:\n      include_reasoning: this.settings.includeReasoning,\n      reasoning: this.settings.reasoning\n    }, this.config.extraBody), this.settings.extraBody);\n  }\n  async doGenerate(options) {\n    var _a15, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;\n    const providerOptions = options.providerOptions || {};\n    const openrouterOptions = providerOptions.openrouter || {};\n    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: \"/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: openrouterFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        OpenRouterCompletionChunkSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    if (\"error\" in response) {\n      throw new Error(`${response.error.message}`);\n    }\n    const choice = response.choices[0];\n    if (!choice) {\n      throw new Error(\"No choice in OpenRouter completion response\");\n    }\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: (_a15 = choice.text) != null ? _a15 : \"\"\n        }\n      ],\n      finishReason: mapOpenRouterFinishReason(choice.finish_reason),\n      usage: {\n        inputTokens: (_c = (_b = response.usage) == null ? void 0 : _b.prompt_tokens) != null ? _c : 0,\n        outputTokens: (_e = (_d = response.usage) == null ? void 0 : _d.completion_tokens) != null ? _e : 0,\n        totalTokens: ((_g = (_f = response.usage) == null ? void 0 : _f.prompt_tokens) != null ? _g : 0) + ((_i = (_h = response.usage) == null ? void 0 : _h.completion_tokens) != null ? _i : 0),\n        reasoningTokens: (_l = (_k = (_j = response.usage) == null ? void 0 : _j.completion_tokens_details) == null ? void 0 : _k.reasoning_tokens) != null ? _l : 0,\n        cachedInputTokens: (_o = (_n = (_m = response.usage) == null ? void 0 : _m.prompt_tokens_details) == null ? void 0 : _n.cached_tokens) != null ? _o : 0\n      },\n      warnings: [],\n      response: {\n        headers: responseHeaders\n      }\n    };\n  }\n  async doStream(options) {\n    const providerOptions = options.providerOptions || {};\n    const openrouterOptions = providerOptions.openrouter || {};\n    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: \"/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: __spreadProps(__spreadValues({}, args), {\n        stream: true,\n        // only include stream_options when in strict compatibility mode:\n        stream_options: this.config.compatibility === \"strict\" ? { include_usage: true } : void 0\n      }),\n      failedResponseHandler: openrouterFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        OpenRouterCompletionChunkSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    let finishReason = \"other\";\n    const usage = {\n      inputTokens: Number.NaN,\n      outputTokens: Number.NaN,\n      totalTokens: Number.NaN,\n      reasoningTokens: Number.NaN,\n      cachedInputTokens: Number.NaN\n    };\n    const openrouterUsage = {};\n    return {\n      stream: response.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            var _a15, _b;\n            if (!chunk.success) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: chunk.error });\n              return;\n            }\n            const value = chunk.value;\n            if (\"error\" in value) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: value.error });\n              return;\n            }\n            if (value.usage != null) {\n              usage.inputTokens = value.usage.prompt_tokens;\n              usage.outputTokens = value.usage.completion_tokens;\n              usage.totalTokens = value.usage.prompt_tokens + value.usage.completion_tokens;\n              openrouterUsage.promptTokens = value.usage.prompt_tokens;\n              if (value.usage.prompt_tokens_details) {\n                const cachedInputTokens = (_a15 = value.usage.prompt_tokens_details.cached_tokens) != null ? _a15 : 0;\n                usage.cachedInputTokens = cachedInputTokens;\n                openrouterUsage.promptTokensDetails = {\n                  cachedTokens: cachedInputTokens\n                };\n              }\n              openrouterUsage.completionTokens = value.usage.completion_tokens;\n              if (value.usage.completion_tokens_details) {\n                const reasoningTokens = (_b = value.usage.completion_tokens_details.reasoning_tokens) != null ? _b : 0;\n                usage.reasoningTokens = reasoningTokens;\n                openrouterUsage.completionTokensDetails = {\n                  reasoningTokens\n                };\n              }\n              openrouterUsage.cost = value.usage.cost;\n              openrouterUsage.totalTokens = value.usage.total_tokens;\n            }\n            const choice = value.choices[0];\n            if ((choice == null ? void 0 : choice.finish_reason) != null) {\n              finishReason = mapOpenRouterFinishReason(choice.finish_reason);\n            }\n            if ((choice == null ? void 0 : choice.text) != null) {\n              controller.enqueue({\n                type: \"text-delta\",\n                delta: choice.text,\n                id: generateId()\n              });\n            }\n          },\n          flush(controller) {\n            controller.enqueue({\n              type: \"finish\",\n              finishReason,\n              usage,\n              providerMetadata: {\n                openrouter: {\n                  usage: openrouterUsage\n                }\n              }\n            });\n          }\n        })\n      ),\n      response: {\n        headers: responseHeaders\n      }\n    };\n  }\n};\n\n// src/facade.ts\nvar OpenRouter = class {\n  /**\n   * Creates a new OpenRouter provider instance.\n   */\n  constructor(options = {}) {\n    var _a15, _b;\n    this.baseURL = (_b = withoutTrailingSlash((_a15 = options.baseURL) != null ? _a15 : options.baseUrl)) != null ? _b : \"https://openrouter.ai/api/v1\";\n    this.apiKey = options.apiKey;\n    this.headers = options.headers;\n  }\n  get baseConfig() {\n    return {\n      baseURL: this.baseURL,\n      headers: () => __spreadValues({\n        Authorization: `Bearer ${loadApiKey({\n          apiKey: this.apiKey,\n          environmentVariableName: \"OPENROUTER_API_KEY\",\n          description: \"OpenRouter\"\n        })}`\n      }, this.headers)\n    };\n  }\n  chat(modelId, settings = {}) {\n    return new OpenRouterChatLanguageModel(modelId, settings, __spreadProps(__spreadValues({\n      provider: \"openrouter.chat\"\n    }, this.baseConfig), {\n      compatibility: \"strict\",\n      url: ({ path }) => `${this.baseURL}${path}`\n    }));\n  }\n  completion(modelId, settings = {}) {\n    return new OpenRouterCompletionLanguageModel(modelId, settings, __spreadProps(__spreadValues({\n      provider: \"openrouter.completion\"\n    }, this.baseConfig), {\n      compatibility: \"strict\",\n      url: ({ path }) => `${this.baseURL}${path}`\n    }));\n  }\n};\n\n// src/provider.ts\nfunction createOpenRouter(options = {}) {\n  var _a15, _b, _c;\n  const baseURL = (_b = withoutTrailingSlash((_a15 = options.baseURL) != null ? _a15 : options.baseUrl)) != null ? _b : \"https://openrouter.ai/api/v1\";\n  const compatibility = (_c = options.compatibility) != null ? _c : \"compatible\";\n  const getHeaders = () => __spreadValues({\n    Authorization: `Bearer ${loadApiKey({\n      apiKey: options.apiKey,\n      environmentVariableName: \"OPENROUTER_API_KEY\",\n      description: \"OpenRouter\"\n    })}`\n  }, options.headers);\n  const createChatModel = (modelId, settings = {}) => new OpenRouterChatLanguageModel(modelId, settings, {\n    provider: \"openrouter.chat\",\n    url: ({ path }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    compatibility,\n    fetch: options.fetch,\n    extraBody: options.extraBody\n  });\n  const createCompletionModel = (modelId, settings = {}) => new OpenRouterCompletionLanguageModel(modelId, settings, {\n    provider: \"openrouter.completion\",\n    url: ({ path }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    compatibility,\n    fetch: options.fetch,\n    extraBody: options.extraBody\n  });\n  const createLanguageModel = (modelId, settings) => {\n    if (new.target) {\n      throw new Error(\n        \"The OpenRouter model function cannot be called with the new keyword.\"\n      );\n    }\n    if (modelId === \"openai/gpt-3.5-turbo-instruct\") {\n      return createCompletionModel(\n        modelId,\n        settings\n      );\n    }\n    return createChatModel(modelId, settings);\n  };\n  const provider = (modelId, settings) => createLanguageModel(modelId, settings);\n  provider.languageModel = createLanguageModel;\n  provider.chat = createChatModel;\n  provider.completion = createCompletionModel;\n  return provider;\n}\nvar openrouter = createOpenRouter({\n  compatibility: \"strict\"\n  // strict for OpenRouter API\n});\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW5yb3V0ZXIrYWktc2RrLXByb3ZpZGVyQDEuMi4wX2FpQDUuMC40N196b2RAMy4yNS43Nl9fem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL0BvcGVucm91dGVyL2FpLXNkay1wcm92aWRlci9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDLElBQUk7QUFDdEQsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxRUFBcUUsc0JBQXNCLElBQUk7QUFDeEcsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1DQUFtQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1DQUFtQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHO0FBQzFHLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0Isa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsUUFBUTtBQUNuRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG1CQUFtQixLQUFLO0FBQ3hCLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNpQztBQUNqQyxzQ0FBc0MseUNBQVE7QUFDOUMsRUFBRSwwQ0FBUztBQUNYLFFBQVEsMENBQVM7QUFDakIsV0FBVywwQ0FBUztBQUNwQixhQUFhLHlDQUFRO0FBQ3JCLE1BQU0sMENBQVM7QUFDZixjQUFjLDBDQUFTO0FBQ3ZCLG1CQUFtQiwwQ0FBUztBQUM1QjtBQUNBLHVCQUF1QiwwQ0FBUztBQUNoQyxlQUFlLDBDQUFTO0FBQ3hCLGtCQUFrQiwwQ0FBUztBQUMzQixrQkFBa0IseUNBQVEsQ0FBQywwQ0FBUztBQUNwQywwQkFBMEIseUNBQVEsQ0FBQywwQ0FBUztBQUM1Qyx3QkFBd0IseUNBQVEsQ0FBQywwQ0FBUyxDQUFDLDBDQUFTLElBQUksMENBQVM7QUFDakUsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLFdBQVcsMENBQVM7QUFDcEIscUJBQXFCLDBDQUFTO0FBQzlCLDZCQUE2QiwwQ0FBUztBQUN0Qyx1QkFBdUIsMENBQVM7QUFDaEMsT0FBTztBQUNQLHlCQUF5QiwwQ0FBUztBQUNsQyxpQ0FBaUMsMENBQVM7QUFDMUMsMEJBQTBCLDBDQUFTO0FBQ25DLE9BQU87QUFDUCxvQkFBb0IsMENBQVM7QUFDN0IsWUFBWSwwQ0FBUztBQUNyQixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxtRUFBbUUsc0JBQXNCO0FBQ3pGLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUNBQW1DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUNBQW1DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFNBQVMsRUFBRTtBQUNYLE9BQU87QUFDUDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLE1BQU0sUUFBUSxhQUFhLEVBQUUsS0FBSztBQUNoRCxLQUFLO0FBQ0w7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsTUFBTSxRQUFRLGFBQWEsRUFBRSxLQUFLO0FBQ2hELEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTtBQUNQLEdBQUc7QUFDSCxpREFBaUQ7QUFDakQ7QUFDQSxZQUFZLE1BQU0sUUFBUSxRQUFRLEVBQUUsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx1REFBdUQ7QUFDdkQ7QUFDQSxZQUFZLE1BQU0sUUFBUSxRQUFRLEVBQUUsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUtDO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy91dHNhdnNoYXJtYS9Eb2N1bWVudHMvR2l0SHViL0RpdkhhY2tzMjAyNS9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW5yb3V0ZXIrYWktc2RrLXByb3ZpZGVyQDEuMi4wX2FpQDUuMC40N196b2RAMy4yNS43Nl9fem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL0BvcGVucm91dGVyL2FpLXNkay1wcm92aWRlci9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BhaS1zZGsrcHJvdmlkZXJAMi4wLjAvbm9kZV9tb2R1bGVzL0BhaS1zZGsvcHJvdmlkZXIvZGlzdC9pbmRleC5tanNcbnZhciBtYXJrZXIgPSBcInZlcmNlbC5haS5lcnJvclwiO1xudmFyIHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcbnZhciBfYTtcbnZhciBfQUlTREtFcnJvciA9IGNsYXNzIF9BSVNES0Vycm9yMiBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gQUkgU0RLIEVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNyZWF0aW5nIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm1lc3NhZ2UgLSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAgICogQHBhcmFtIHt1bmtub3dufSBbcGFyYW1zLmNhdXNlXSAtIFRoZSB1bmRlcmx5aW5nIGNhdXNlIG9mIHRoZSBlcnJvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBuYW1lOiBuYW1lMTQsXG4gICAgbWVzc2FnZSxcbiAgICBjYXVzZVxuICB9KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpc1tfYV0gPSB0cnVlO1xuICAgIHRoaXMubmFtZSA9IG5hbWUxNDtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgYW4gQUkgU0RLIEVycm9yLlxuICAgKiBAcGFyYW0ge3Vua25vd259IGVycm9yIC0gVGhlIGVycm9yIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYW4gQUkgU0RLIEVycm9yLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBfQUlTREtFcnJvcjIuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG4gIHN0YXRpYyBoYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjE1KSB7XG4gICAgY29uc3QgbWFya2VyU3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIxNSk7XG4gICAgcmV0dXJuIGVycm9yICE9IG51bGwgJiYgdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIG1hcmtlclN5bWJvbCBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3JbbWFya2VyU3ltYm9sXSA9PT0gXCJib29sZWFuXCIgJiYgZXJyb3JbbWFya2VyU3ltYm9sXSA9PT0gdHJ1ZTtcbiAgfVxufTtcbl9hID0gc3ltYm9sO1xudmFyIEFJU0RLRXJyb3IgPSBfQUlTREtFcnJvcjtcbnZhciBuYW1lID0gXCJBSV9BUElDYWxsRXJyb3JcIjtcbnZhciBtYXJrZXIyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbnZhciBzeW1ib2wyID0gU3ltYm9sLmZvcihtYXJrZXIyKTtcbnZhciBfYTI7XG52YXIgQVBJQ2FsbEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UsXG4gICAgdXJsLFxuICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgIHN0YXR1c0NvZGUsXG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHJlc3BvbnNlQm9keSxcbiAgICBjYXVzZSxcbiAgICBpc1JldHJ5YWJsZSA9IHN0YXR1c0NvZGUgIT0gbnVsbCAmJiAoc3RhdHVzQ29kZSA9PT0gNDA4IHx8IC8vIHJlcXVlc3QgdGltZW91dFxuICAgIHN0YXR1c0NvZGUgPT09IDQwOSB8fCAvLyBjb25mbGljdFxuICAgIHN0YXR1c0NvZGUgPT09IDQyOSB8fCAvLyB0b28gbWFueSByZXF1ZXN0c1xuICAgIHN0YXR1c0NvZGUgPj0gNTAwKSxcbiAgICAvLyBzZXJ2ZXIgZXJyb3JcbiAgICBkYXRhXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2EyXSA9IHRydWU7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5yZXF1ZXN0Qm9keVZhbHVlcyA9IHJlcXVlc3RCb2R5VmFsdWVzO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnM7XG4gICAgdGhpcy5yZXNwb25zZUJvZHkgPSByZXNwb25zZUJvZHk7XG4gICAgdGhpcy5pc1JldHJ5YWJsZSA9IGlzUmV0cnlhYmxlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjIpO1xuICB9XG59O1xuX2EyID0gc3ltYm9sMjtcbnZhciBuYW1lMiA9IFwiQUlfRW1wdHlSZXNwb25zZUJvZHlFcnJvclwiO1xudmFyIG1hcmtlcjMgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTJ9YDtcbnZhciBzeW1ib2wzID0gU3ltYm9sLmZvcihtYXJrZXIzKTtcbnZhciBfYTM7XG52YXIgRW1wdHlSZXNwb25zZUJvZHlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgPSBcIkVtcHR5IHJlc3BvbnNlIGJvZHlcIiB9ID0ge30pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUyLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2EzXSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjMpO1xuICB9XG59O1xuX2EzID0gc3ltYm9sMztcbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgIHJldHVybiBcInVua25vd24gZXJyb3JcIjtcbiAgfVxuICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbn1cbnZhciBuYW1lMyA9IFwiQUlfSW52YWxpZEFyZ3VtZW50RXJyb3JcIjtcbnZhciBtYXJrZXI0ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUzfWA7XG52YXIgc3ltYm9sNCA9IFN5bWJvbC5mb3IobWFya2VyNCk7XG52YXIgX2E0O1xudmFyIEludmFsaWRBcmd1bWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UsXG4gICAgY2F1c2UsXG4gICAgYXJndW1lbnRcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTMsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E0XSA9IHRydWU7XG4gICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI0KTtcbiAgfVxufTtcbl9hNCA9IHN5bWJvbDQ7XG52YXIgbmFtZTQgPSBcIkFJX0ludmFsaWRQcm9tcHRFcnJvclwiO1xudmFyIG1hcmtlcjUgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTR9YDtcbnZhciBzeW1ib2w1ID0gU3ltYm9sLmZvcihtYXJrZXI1KTtcbnZhciBfYTU7XG52YXIgSW52YWxpZFByb21wdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHByb21wdCxcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU0LCBtZXNzYWdlOiBgSW52YWxpZCBwcm9tcHQ6ICR7bWVzc2FnZX1gLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNV0gPSB0cnVlO1xuICAgIHRoaXMucHJvbXB0ID0gcHJvbXB0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI1KTtcbiAgfVxufTtcbl9hNSA9IHN5bWJvbDU7XG52YXIgbmFtZTUgPSBcIkFJX0ludmFsaWRSZXNwb25zZURhdGFFcnJvclwiO1xudmFyIG1hcmtlcjYgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTV9YDtcbnZhciBzeW1ib2w2ID0gU3ltYm9sLmZvcihtYXJrZXI2KTtcbnZhciBfYTY7XG52YXIgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRhdGEsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIHJlc3BvbnNlIGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9LmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTZdID0gdHJ1ZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI2KTtcbiAgfVxufTtcbl9hNiA9IHN5bWJvbDY7XG52YXIgbmFtZTYgPSBcIkFJX0pTT05QYXJzZUVycm9yXCI7XG52YXIgbWFya2VyNyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNn1gO1xudmFyIHN5bWJvbDcgPSBTeW1ib2wuZm9yKG1hcmtlcjcpO1xudmFyIF9hNztcbnZhciBKU09OUGFyc2VFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHsgdGV4dCwgY2F1c2UgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWU2LFxuICAgICAgbWVzc2FnZTogYEpTT04gcGFyc2luZyBmYWlsZWQ6IFRleHQ6ICR7dGV4dH0uXG5FcnJvciBtZXNzYWdlOiAke2dldEVycm9yTWVzc2FnZShjYXVzZSl9YCxcbiAgICAgIGNhdXNlXG4gICAgfSk7XG4gICAgdGhpc1tfYTddID0gdHJ1ZTtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI3KTtcbiAgfVxufTtcbl9hNyA9IHN5bWJvbDc7XG52YXIgbmFtZTcgPSBcIkFJX0xvYWRBUElLZXlFcnJvclwiO1xudmFyIG1hcmtlcjggPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTd9YDtcbnZhciBzeW1ib2w4ID0gU3ltYm9sLmZvcihtYXJrZXI4KTtcbnZhciBfYTg7XG52YXIgTG9hZEFQSUtleUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNywgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hOF0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI4KTtcbiAgfVxufTtcbl9hOCA9IHN5bWJvbDg7XG52YXIgbmFtZTggPSBcIkFJX0xvYWRTZXR0aW5nRXJyb3JcIjtcbnZhciBtYXJrZXI5ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU4fWA7XG52YXIgc3ltYm9sOSA9IFN5bWJvbC5mb3IobWFya2VyOSk7XG52YXIgX2E5O1xuX2E5ID0gc3ltYm9sOTtcbnZhciBuYW1lOSA9IFwiQUlfTm9Db250ZW50R2VuZXJhdGVkRXJyb3JcIjtcbnZhciBtYXJrZXIxMCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOX1gO1xudmFyIHN5bWJvbDEwID0gU3ltYm9sLmZvcihtYXJrZXIxMCk7XG52YXIgX2ExMDtcbl9hMTAgPSBzeW1ib2wxMDtcbnZhciBuYW1lMTAgPSBcIkFJX05vU3VjaE1vZGVsRXJyb3JcIjtcbnZhciBtYXJrZXIxMSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTB9YDtcbnZhciBzeW1ib2wxMSA9IFN5bWJvbC5mb3IobWFya2VyMTEpO1xudmFyIF9hMTE7XG5fYTExID0gc3ltYm9sMTE7XG52YXIgbmFtZTExID0gXCJBSV9Ub29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yXCI7XG52YXIgbWFya2VyMTIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTExfWA7XG52YXIgc3ltYm9sMTIgPSBTeW1ib2wuZm9yKG1hcmtlcjEyKTtcbnZhciBfYTEyO1xuX2ExMiA9IHN5bWJvbDEyO1xudmFyIG5hbWUxMiA9IFwiQUlfVHlwZVZhbGlkYXRpb25FcnJvclwiO1xudmFyIG1hcmtlcjEzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMn1gO1xudmFyIHN5bWJvbDEzID0gU3ltYm9sLmZvcihtYXJrZXIxMyk7XG52YXIgX2ExMztcbnZhciBfVHlwZVZhbGlkYXRpb25FcnJvciA9IGNsYXNzIF9UeXBlVmFsaWRhdGlvbkVycm9yMiBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IHZhbHVlLCBjYXVzZSB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTEyLFxuICAgICAgbWVzc2FnZTogYFR5cGUgdmFsaWRhdGlvbiBmYWlsZWQ6IFZhbHVlOiAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0uXG5FcnJvciBtZXNzYWdlOiAke2dldEVycm9yTWVzc2FnZShjYXVzZSl9YCxcbiAgICAgIGNhdXNlXG4gICAgfSk7XG4gICAgdGhpc1tfYTEzXSA9IHRydWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMyk7XG4gIH1cbiAgLyoqXG4gICAqIFdyYXBzIGFuIGVycm9yIGludG8gYSBUeXBlVmFsaWRhdGlvbkVycm9yLlxuICAgKiBJZiB0aGUgY2F1c2UgaXMgYWxyZWFkeSBhIFR5cGVWYWxpZGF0aW9uRXJyb3Igd2l0aCB0aGUgc2FtZSB2YWx1ZSwgaXQgcmV0dXJucyB0aGUgY2F1c2UuXG4gICAqIE90aGVyd2lzZSwgaXQgY3JlYXRlcyBhIG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHdyYXBwaW5nIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIHt1bmtub3dufSBwYXJhbXMudmFsdWUgLSBUaGUgdmFsdWUgdGhhdCBmYWlsZWQgdmFsaWRhdGlvbi5cbiAgICogQHBhcmFtIHt1bmtub3dufSBwYXJhbXMuY2F1c2UgLSBUaGUgb3JpZ2luYWwgZXJyb3Igb3IgY2F1c2Ugb2YgdGhlIHZhbGlkYXRpb24gZmFpbHVyZS5cbiAgICogQHJldHVybnMge1R5cGVWYWxpZGF0aW9uRXJyb3J9IEEgVHlwZVZhbGlkYXRpb25FcnJvciBpbnN0YW5jZS5cbiAgICovXG4gIHN0YXRpYyB3cmFwKHtcbiAgICB2YWx1ZSxcbiAgICBjYXVzZVxuICB9KSB7XG4gICAgcmV0dXJuIF9UeXBlVmFsaWRhdGlvbkVycm9yMi5pc0luc3RhbmNlKGNhdXNlKSAmJiBjYXVzZS52YWx1ZSA9PT0gdmFsdWUgPyBjYXVzZSA6IG5ldyBfVHlwZVZhbGlkYXRpb25FcnJvcjIoeyB2YWx1ZSwgY2F1c2UgfSk7XG4gIH1cbn07XG5fYTEzID0gc3ltYm9sMTM7XG52YXIgVHlwZVZhbGlkYXRpb25FcnJvciA9IF9UeXBlVmFsaWRhdGlvbkVycm9yO1xudmFyIG5hbWUxMyA9IFwiQUlfVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3JcIjtcbnZhciBtYXJrZXIxNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTN9YDtcbnZhciBzeW1ib2wxNCA9IFN5bWJvbC5mb3IobWFya2VyMTQpO1xudmFyIF9hMTQ7XG52YXIgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZnVuY3Rpb25hbGl0eSxcbiAgICBtZXNzYWdlID0gYCcke2Z1bmN0aW9uYWxpdHl9JyBmdW5jdGlvbmFsaXR5IG5vdCBzdXBwb3J0ZWQuYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTMsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTE0XSA9IHRydWU7XG4gICAgdGhpcy5mdW5jdGlvbmFsaXR5ID0gZnVuY3Rpb25hbGl0eTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTQpO1xuICB9XG59O1xuX2ExNCA9IHN5bWJvbDE0O1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vZXZlbnRzb3VyY2UtcGFyc2VyQDMuMC4zL25vZGVfbW9kdWxlcy9ldmVudHNvdXJjZS1wYXJzZXIvZGlzdC9pbmRleC5qc1xudmFyIFBhcnNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKG1lc3NhZ2UpLCB0aGlzLm5hbWUgPSBcIlBhcnNlRXJyb3JcIiwgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlLCB0aGlzLmZpZWxkID0gb3B0aW9ucy5maWVsZCwgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWUsIHRoaXMubGluZSA9IG9wdGlvbnMubGluZTtcbiAgfVxufTtcbmZ1bmN0aW9uIG5vb3AoX2FyZykge1xufVxuZnVuY3Rpb24gY3JlYXRlUGFyc2VyKGNhbGxiYWNrcykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrcyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiYGNhbGxiYWNrc2AgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCBhIGZ1bmN0aW9uIGluc3RlYWQuIERpZCB5b3UgbWVhbiBge29uRXZlbnQ6IGZufWA/XCJcbiAgICApO1xuICBjb25zdCB7IG9uRXZlbnQgPSBub29wLCBvbkVycm9yID0gbm9vcCwgb25SZXRyeSA9IG5vb3AsIG9uQ29tbWVudCB9ID0gY2FsbGJhY2tzO1xuICBsZXQgaW5jb21wbGV0ZUxpbmUgPSBcIlwiLCBpc0ZpcnN0Q2h1bmsgPSB0cnVlLCBpZCwgZGF0YSA9IFwiXCIsIGV2ZW50VHlwZSA9IFwiXCI7XG4gIGZ1bmN0aW9uIGZlZWQobmV3Q2h1bmspIHtcbiAgICBjb25zdCBjaHVuayA9IGlzRmlyc3RDaHVuayA/IG5ld0NodW5rLnJlcGxhY2UoL15cXHhFRlxceEJCXFx4QkYvLCBcIlwiKSA6IG5ld0NodW5rLCBbY29tcGxldGUsIGluY29tcGxldGVdID0gc3BsaXRMaW5lcyhgJHtpbmNvbXBsZXRlTGluZX0ke2NodW5rfWApO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiBjb21wbGV0ZSlcbiAgICAgIHBhcnNlTGluZShsaW5lKTtcbiAgICBpbmNvbXBsZXRlTGluZSA9IGluY29tcGxldGUsIGlzRmlyc3RDaHVuayA9IGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlTGluZShsaW5lKSB7XG4gICAgaWYgKGxpbmUgPT09IFwiXCIpIHtcbiAgICAgIGRpc3BhdGNoRXZlbnQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGxpbmUuc3RhcnRzV2l0aChcIjpcIikpIHtcbiAgICAgIG9uQ29tbWVudCAmJiBvbkNvbW1lbnQobGluZS5zbGljZShsaW5lLnN0YXJ0c1dpdGgoXCI6IFwiKSA/IDIgOiAxKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkU2VwYXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICAgIGlmIChmaWVsZFNlcGFyYXRvckluZGV4ICE9PSAtMSkge1xuICAgICAgY29uc3QgZmllbGQgPSBsaW5lLnNsaWNlKDAsIGZpZWxkU2VwYXJhdG9ySW5kZXgpLCBvZmZzZXQgPSBsaW5lW2ZpZWxkU2VwYXJhdG9ySW5kZXggKyAxXSA9PT0gXCIgXCIgPyAyIDogMSwgdmFsdWUgPSBsaW5lLnNsaWNlKGZpZWxkU2VwYXJhdG9ySW5kZXggKyBvZmZzZXQpO1xuICAgICAgcHJvY2Vzc0ZpZWxkKGZpZWxkLCB2YWx1ZSwgbGluZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByb2Nlc3NGaWVsZChsaW5lLCBcIlwiLCBsaW5lKTtcbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzRmllbGQoZmllbGQsIHZhbHVlLCBsaW5lKSB7XG4gICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgIGV2ZW50VHlwZSA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgIGRhdGEgPSBgJHtkYXRhfSR7dmFsdWV9XG5gO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICBpZCA9IHZhbHVlLmluY2x1ZGVzKFwiXFwwXCIpID8gdm9pZCAwIDogdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJldHJ5XCI6XG4gICAgICAgIC9eXFxkKyQvLnRlc3QodmFsdWUpID8gb25SZXRyeShwYXJzZUludCh2YWx1ZSwgMTApKSA6IG9uRXJyb3IoXG4gICAgICAgICAgbmV3IFBhcnNlRXJyb3IoYEludmFsaWQgXFxgcmV0cnlcXGAgdmFsdWU6IFwiJHt2YWx1ZX1cImAsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZC1yZXRyeVwiLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBsaW5lXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBvbkVycm9yKFxuICAgICAgICAgIG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgYFVua25vd24gZmllbGQgXCIke2ZpZWxkLmxlbmd0aCA+IDIwID8gYCR7ZmllbGQuc2xpY2UoMCwgMjApfVxcdTIwMjZgIDogZmllbGR9XCJgLFxuICAgICAgICAgICAgeyB0eXBlOiBcInVua25vd24tZmllbGRcIiwgZmllbGQsIHZhbHVlLCBsaW5lIH1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KCkge1xuICAgIGRhdGEubGVuZ3RoID4gMCAmJiBvbkV2ZW50KHtcbiAgICAgIGlkLFxuICAgICAgZXZlbnQ6IGV2ZW50VHlwZSB8fCB2b2lkIDAsXG4gICAgICAvLyBJZiB0aGUgZGF0YSBidWZmZXIncyBsYXN0IGNoYXJhY3RlciBpcyBhIFUrMDAwQSBMSU5FIEZFRUQgKExGKSBjaGFyYWN0ZXIsXG4gICAgICAvLyB0aGVuIHJlbW92ZSB0aGUgbGFzdCBjaGFyYWN0ZXIgZnJvbSB0aGUgZGF0YSBidWZmZXIuXG4gICAgICBkYXRhOiBkYXRhLmVuZHNXaXRoKGBcbmApID8gZGF0YS5zbGljZSgwLCAtMSkgOiBkYXRhXG4gICAgfSksIGlkID0gdm9pZCAwLCBkYXRhID0gXCJcIiwgZXZlbnRUeXBlID0gXCJcIjtcbiAgfVxuICBmdW5jdGlvbiByZXNldChvcHRpb25zID0ge30pIHtcbiAgICBpbmNvbXBsZXRlTGluZSAmJiBvcHRpb25zLmNvbnN1bWUgJiYgcGFyc2VMaW5lKGluY29tcGxldGVMaW5lKSwgaXNGaXJzdENodW5rID0gdHJ1ZSwgaWQgPSB2b2lkIDAsIGRhdGEgPSBcIlwiLCBldmVudFR5cGUgPSBcIlwiLCBpbmNvbXBsZXRlTGluZSA9IFwiXCI7XG4gIH1cbiAgcmV0dXJuIHsgZmVlZCwgcmVzZXQgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0TGluZXMoY2h1bmspIHtcbiAgY29uc3QgbGluZXMgPSBbXTtcbiAgbGV0IGluY29tcGxldGVMaW5lID0gXCJcIiwgc2VhcmNoSW5kZXggPSAwO1xuICBmb3IgKDsgc2VhcmNoSW5kZXggPCBjaHVuay5sZW5ndGg7ICkge1xuICAgIGNvbnN0IGNySW5kZXggPSBjaHVuay5pbmRleE9mKFwiXFxyXCIsIHNlYXJjaEluZGV4KSwgbGZJbmRleCA9IGNodW5rLmluZGV4T2YoYFxuYCwgc2VhcmNoSW5kZXgpO1xuICAgIGxldCBsaW5lRW5kID0gLTE7XG4gICAgaWYgKGNySW5kZXggIT09IC0xICYmIGxmSW5kZXggIT09IC0xID8gbGluZUVuZCA9IE1hdGgubWluKGNySW5kZXgsIGxmSW5kZXgpIDogY3JJbmRleCAhPT0gLTEgPyBsaW5lRW5kID0gY3JJbmRleCA6IGxmSW5kZXggIT09IC0xICYmIChsaW5lRW5kID0gbGZJbmRleCksIGxpbmVFbmQgPT09IC0xKSB7XG4gICAgICBpbmNvbXBsZXRlTGluZSA9IGNodW5rLnNsaWNlKHNlYXJjaEluZGV4KTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsaW5lID0gY2h1bmsuc2xpY2Uoc2VhcmNoSW5kZXgsIGxpbmVFbmQpO1xuICAgICAgbGluZXMucHVzaChsaW5lKSwgc2VhcmNoSW5kZXggPSBsaW5lRW5kICsgMSwgY2h1bmtbc2VhcmNoSW5kZXggLSAxXSA9PT0gXCJcXHJcIiAmJiBjaHVua1tzZWFyY2hJbmRleF0gPT09IGBcbmAgJiYgc2VhcmNoSW5kZXgrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtsaW5lcywgaW5jb21wbGV0ZUxpbmVdO1xufVxuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vZXZlbnRzb3VyY2UtcGFyc2VyQDMuMC4zL25vZGVfbW9kdWxlcy9ldmVudHNvdXJjZS1wYXJzZXIvZGlzdC9zdHJlYW0uanNcbnZhciBFdmVudFNvdXJjZVBhcnNlclN0cmVhbSA9IGNsYXNzIGV4dGVuZHMgVHJhbnNmb3JtU3RyZWFtIHtcbiAgY29uc3RydWN0b3IoeyBvbkVycm9yLCBvblJldHJ5LCBvbkNvbW1lbnQgfSA9IHt9KSB7XG4gICAgbGV0IHBhcnNlcjtcbiAgICBzdXBlcih7XG4gICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgIHBhcnNlciA9IGNyZWF0ZVBhcnNlcih7XG4gICAgICAgICAgb25FdmVudDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZXZlbnQpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25FcnJvcihlcnJvcikge1xuICAgICAgICAgICAgb25FcnJvciA9PT0gXCJ0ZXJtaW5hdGVcIiA/IGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpIDogdHlwZW9mIG9uRXJyb3IgPT0gXCJmdW5jdGlvblwiICYmIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25SZXRyeSxcbiAgICAgICAgICBvbkNvbW1lbnRcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtKGNodW5rKSB7XG4gICAgICAgIHBhcnNlci5mZWVkKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BhaS1zZGsrcHJvdmlkZXItdXRpbHNAMy4wLjFfem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL0BhaS1zZGsvcHJvdmlkZXItdXRpbHMvZGlzdC9pbmRleC5tanNcbmltcG9ydCAqIGFzIHo0IGZyb20gXCJ6b2QvdjRcIjtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZC10by1qc29uLXNjaGVtYUAzLjI0LjZfem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9PcHRpb25zLmpzXG52YXIgaWdub3JlT3ZlcnJpZGUgPSBTeW1ib2woXCJMZXQgem9kVG9Kc29uU2NoZW1hIGRlY2lkZSBvbiB3aGljaCBwYXJzZXIgdG8gdXNlXCIpO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kLXRvLWpzb24tc2NoZW1hQDMuMjQuNl96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3NlbGVjdFBhcnNlci5qc1xuaW1wb3J0IHsgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIGFzIFpvZEZpcnN0UGFydHlUeXBlS2luZDMgfSBmcm9tIFwiem9kXCI7XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS96b2QtdG8tanNvbi1zY2hlbWFAMy4yNC42X3pvZEAzLjI1Ljc2L25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy9hcnJheS5qc1xuaW1wb3J0IHsgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIH0gZnJvbSBcInpvZFwiO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kLXRvLWpzb24tc2NoZW1hQDMuMjQuNl96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvcmVjb3JkLmpzXG5pbXBvcnQgeyBab2RGaXJzdFBhcnR5VHlwZUtpbmQgYXMgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMiB9IGZyb20gXCJ6b2RcIjtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZC10by1qc29uLXNjaGVtYUAzLjI0LjZfem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL3N0cmluZy5qc1xudmFyIEFMUEhBX05VTUVSSUMgPSBuZXcgU2V0KFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVlhZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ4eXowMTIzNDU2Nzg5XCIpO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vQGFpLXNkaytwcm92aWRlci11dGlsc0AzLjAuMV96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci11dGlscy9kaXN0L2luZGV4Lm1qc1xuZnVuY3Rpb24gY29tYmluZUhlYWRlcnMoLi4uaGVhZGVycykge1xuICByZXR1cm4gaGVhZGVycy5yZWR1Y2UoXG4gICAgKGNvbWJpbmVkSGVhZGVycywgY3VycmVudEhlYWRlcnMpID0+IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBjb21iaW5lZEhlYWRlcnMpLCBjdXJyZW50SGVhZGVycyAhPSBudWxsID8gY3VycmVudEhlYWRlcnMgOiB7fSksXG4gICAge31cbiAgKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhbLi4ucmVzcG9uc2UuaGVhZGVyc10pO1xufVxudmFyIGNyZWF0ZUlkR2VuZXJhdG9yID0gKHtcbiAgcHJlZml4LFxuICBzaXplID0gMTYsXG4gIGFscGhhYmV0ID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLFxuICBzZXBhcmF0b3IgPSBcIi1cIlxufSA9IHt9KSA9PiB7XG4gIGNvbnN0IGdlbmVyYXRvciA9ICgpID0+IHtcbiAgICBjb25zdCBhbHBoYWJldExlbmd0aCA9IGFscGhhYmV0Lmxlbmd0aDtcbiAgICBjb25zdCBjaGFycyA9IG5ldyBBcnJheShzaXplKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBhbHBoYWJldFtNYXRoLnJhbmRvbSgpICogYWxwaGFiZXRMZW5ndGggfCAwXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oXCJcIik7XG4gIH07XG4gIGlmIChwcmVmaXggPT0gbnVsbCkge1xuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgaWYgKGFscGhhYmV0LmluY2x1ZGVzKHNlcGFyYXRvcikpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgYXJndW1lbnQ6IFwic2VwYXJhdG9yXCIsXG4gICAgICBtZXNzYWdlOiBgVGhlIHNlcGFyYXRvciBcIiR7c2VwYXJhdG9yfVwiIG11c3Qgbm90IGJlIHBhcnQgb2YgdGhlIGFscGhhYmV0IFwiJHthbHBoYWJldH1cIi5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuICgpID0+IGAke3ByZWZpeH0ke3NlcGFyYXRvcn0ke2dlbmVyYXRvcigpfWA7XG59O1xudmFyIGdlbmVyYXRlSWQgPSBjcmVhdGVJZEdlbmVyYXRvcigpO1xuZnVuY3Rpb24gaXNBYm9ydEVycm9yKGVycm9yKSB7XG4gIHJldHVybiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbikgJiYgKGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiIHx8IGVycm9yLm5hbWUgPT09IFwiUmVzcG9uc2VBYm9ydGVkXCIgfHwgLy8gTmV4dC5qc1xuICBlcnJvci5uYW1lID09PSBcIlRpbWVvdXRFcnJvclwiKTtcbn1cbnZhciBGRVRDSF9GQUlMRURfRVJST1JfTUVTU0FHRVMgPSBbXCJmZXRjaCBmYWlsZWRcIiwgXCJmYWlsZWQgdG8gZmV0Y2hcIl07XG5mdW5jdGlvbiBoYW5kbGVGZXRjaEVycm9yKHtcbiAgZXJyb3IsXG4gIHVybCxcbiAgcmVxdWVzdEJvZHlWYWx1ZXNcbn0pIHtcbiAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIEZFVENIX0ZBSUxFRF9FUlJPUl9NRVNTQUdFUy5pbmNsdWRlcyhlcnJvci5tZXNzYWdlLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgY29uc3QgY2F1c2UgPSBlcnJvci5jYXVzZTtcbiAgICBpZiAoY2F1c2UgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBBUElDYWxsRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgQ2Fubm90IGNvbm5lY3QgdG8gQVBJOiAke2NhdXNlLm1lc3NhZ2V9YCxcbiAgICAgICAgY2F1c2UsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICAgIGlzUmV0cnlhYmxlOiB0cnVlXG4gICAgICAgIC8vIHJldHJ5IHdoZW4gbmV0d29yayBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cbmZ1bmN0aW9uIHJlbW92ZVVuZGVmaW5lZEVudHJpZXMocmVjb3JkKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMocmVjb3JkKS5maWx0ZXIoKFtfa2V5LCB2YWx1ZV0pID0+IHZhbHVlICE9IG51bGwpXG4gICk7XG59XG5mdW5jdGlvbiBsb2FkQXBpS2V5KHtcbiAgYXBpS2V5LFxuICBlbnZpcm9ubWVudFZhcmlhYmxlTmFtZSxcbiAgYXBpS2V5UGFyYW1ldGVyTmFtZSA9IFwiYXBpS2V5XCIsXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIGlmICh0eXBlb2YgYXBpS2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGFwaUtleTtcbiAgfVxuICBpZiAoYXBpS2V5ICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTG9hZEFQSUtleUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBBUEkga2V5IG11c3QgYmUgYSBzdHJpbmcuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7YXBpS2V5UGFyYW1ldGVyTmFtZX0nIHBhcmFtZXRlci4gRW52aXJvbm1lbnQgdmFyaWFibGVzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC5gXG4gICAgfSk7XG4gIH1cbiAgYXBpS2V5ID0gcHJvY2Vzcy5lbnZbZW52aXJvbm1lbnRWYXJpYWJsZU5hbWVdO1xuICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTG9hZEFQSUtleUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBBUEkga2V5IGlzIG1pc3NpbmcuIFBhc3MgaXQgdXNpbmcgdGhlICcke2FwaUtleVBhcmFtZXRlck5hbWV9JyBwYXJhbWV0ZXIgb3IgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlLmBcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIGFwaUtleSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgbXVzdCBiZSBhIHN0cmluZy4gVGhlIHZhbHVlIG9mIHRoZSAke2Vudmlyb25tZW50VmFyaWFibGVOYW1lfSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3QgYSBzdHJpbmcuYFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBhcGlLZXk7XG59XG52YXIgc3VzcGVjdFByb3RvUnggPSAvXCJfX3Byb3RvX19cIlxccyo6LztcbnZhciBzdXNwZWN0Q29uc3RydWN0b3JSeCA9IC9cImNvbnN0cnVjdG9yXCJcXHMqOi87XG5mdW5jdGlvbiBfcGFyc2UodGV4dCkge1xuICBjb25zdCBvYmogPSBKU09OLnBhcnNlKHRleHQpO1xuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGlmIChzdXNwZWN0UHJvdG9SeC50ZXN0KHRleHQpID09PSBmYWxzZSAmJiBzdXNwZWN0Q29uc3RydWN0b3JSeC50ZXN0KHRleHQpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgcmV0dXJuIGZpbHRlcihvYmopO1xufVxuZnVuY3Rpb24gZmlsdGVyKG9iaikge1xuICBsZXQgbmV4dCA9IFtvYmpdO1xuICB3aGlsZSAobmV4dC5sZW5ndGgpIHtcbiAgICBjb25zdCBub2RlcyA9IG5leHQ7XG4gICAgbmV4dCA9IFtdO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBcIl9fcHJvdG9fX1wiKSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJPYmplY3QgY29udGFpbnMgZm9yYmlkZGVuIHByb3RvdHlwZSBwcm9wZXJ0eVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZSwgXCJjb25zdHJ1Y3RvclwiKSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZS5jb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiT2JqZWN0IGNvbnRhaW5zIGZvcmJpZGRlbiBwcm90b3R5cGUgcHJvcGVydHlcIik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBub2RlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbm9kZVtrZXldO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgbmV4dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gc2VjdXJlSnNvblBhcnNlKHRleHQpIHtcbiAgY29uc3QgeyBzdGFja1RyYWNlTGltaXQgfSA9IEVycm9yO1xuICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAwO1xuICB0cnkge1xuICAgIHJldHVybiBfcGFyc2UodGV4dCk7XG4gIH0gZmluYWxseSB7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gc3RhY2tUcmFjZUxpbWl0O1xuICB9XG59XG52YXIgdmFsaWRhdG9yU3ltYm9sID0gU3ltYm9sLmZvcihcInZlcmNlbC5haS52YWxpZGF0b3JcIik7XG5mdW5jdGlvbiB2YWxpZGF0b3IodmFsaWRhdGUpIHtcbiAgcmV0dXJuIHsgW3ZhbGlkYXRvclN5bWJvbF06IHRydWUsIHZhbGlkYXRlIH07XG59XG5mdW5jdGlvbiBpc1ZhbGlkYXRvcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIHZhbGlkYXRvclN5bWJvbCBpbiB2YWx1ZSAmJiB2YWx1ZVt2YWxpZGF0b3JTeW1ib2xdID09PSB0cnVlICYmIFwidmFsaWRhdGVcIiBpbiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGFzVmFsaWRhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1ZhbGlkYXRvcih2YWx1ZSkgPyB2YWx1ZSA6IHN0YW5kYXJkU2NoZW1hVmFsaWRhdG9yKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHN0YW5kYXJkU2NoZW1hVmFsaWRhdG9yKHN0YW5kYXJkU2NoZW1hKSB7XG4gIHJldHVybiB2YWxpZGF0b3IoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RhbmRhcmRTY2hlbWFbXCJ+c3RhbmRhcmRcIl0udmFsaWRhdGUodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQuaXNzdWVzID09IG51bGwgPyB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiByZXN1bHQudmFsdWUgfSA6IHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGNhdXNlOiByZXN1bHQuaXNzdWVzXG4gICAgICB9KVxuICAgIH07XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVUeXBlcyh7XG4gIHZhbHVlLFxuICBzY2hlbWFcbn0pIHtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMoeyB2YWx1ZSwgc2NoZW1hIH0pO1xuICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgdGhyb3cgVHlwZVZhbGlkYXRpb25FcnJvci53cmFwKHsgdmFsdWUsIGNhdXNlOiByZXN1bHQuZXJyb3IgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgdmFsdWUsXG4gIHNjaGVtYVxufSkge1xuICBjb25zdCB2YWxpZGF0b3IyID0gYXNWYWxpZGF0b3Ioc2NoZW1hKTtcbiAgdHJ5IHtcbiAgICBpZiAodmFsaWRhdG9yMi52YWxpZGF0ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZSwgcmF3VmFsdWU6IHZhbHVlIH07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRvcjIudmFsaWRhdGUodmFsdWUpO1xuICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHJlc3VsdC52YWx1ZSwgcmF3VmFsdWU6IHZhbHVlIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBUeXBlVmFsaWRhdGlvbkVycm9yLndyYXAoeyB2YWx1ZSwgY2F1c2U6IHJlc3VsdC5lcnJvciB9KSxcbiAgICAgIHJhd1ZhbHVlOiB2YWx1ZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IFR5cGVWYWxpZGF0aW9uRXJyb3Iud3JhcCh7IHZhbHVlLCBjYXVzZTogZXJyb3IgfSksXG4gICAgICByYXdWYWx1ZTogdmFsdWVcbiAgICB9O1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBwYXJzZUpTT04oe1xuICB0ZXh0LFxuICBzY2hlbWFcbn0pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB2YWx1ZSA9IHNlY3VyZUpzb25QYXJzZSh0ZXh0KTtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkYXRlVHlwZXMoeyB2YWx1ZSwgc2NoZW1hIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChKU09OUGFyc2VFcnJvci5pc0luc3RhbmNlKGVycm9yKSB8fCBUeXBlVmFsaWRhdGlvbkVycm9yLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEpTT05QYXJzZUVycm9yKHsgdGV4dCwgY2F1c2U6IGVycm9yIH0pO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBzYWZlUGFyc2VKU09OKHtcbiAgdGV4dCxcbiAgc2NoZW1hXG59KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdmFsdWUgPSBzZWN1cmVKc29uUGFyc2UodGV4dCk7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZSwgcmF3VmFsdWU6IHZhbHVlIH07XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBzYWZlVmFsaWRhdGVUeXBlcyh7IHZhbHVlLCBzY2hlbWEgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IEpTT05QYXJzZUVycm9yLmlzSW5zdGFuY2UoZXJyb3IpID8gZXJyb3IgOiBuZXcgSlNPTlBhcnNlRXJyb3IoeyB0ZXh0LCBjYXVzZTogZXJyb3IgfSksXG4gICAgICByYXdWYWx1ZTogdm9pZCAwXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaXNQYXJzYWJsZUpzb24oaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICBzZWN1cmVKc29uUGFyc2UoaW5wdXQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUpzb25FdmVudFN0cmVhbSh7XG4gIHN0cmVhbSxcbiAgc2NoZW1hXG59KSB7XG4gIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpLnBpcGVUaHJvdWdoKG5ldyBFdmVudFNvdXJjZVBhcnNlclN0cmVhbSgpKS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIGFzeW5jIHRyYW5zZm9ybSh7IGRhdGEgfSwgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoZGF0YSA9PT0gXCJbRE9ORV1cIikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYXdhaXQgc2FmZVBhcnNlSlNPTih7IHRleHQ6IGRhdGEsIHNjaGVtYSB9KSk7XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cbnZhciBnZXRPcmlnaW5hbEZldGNoMiA9ICgpID0+IGdsb2JhbFRoaXMuZmV0Y2g7XG52YXIgcG9zdEpzb25Ub0FwaSA9IGFzeW5jICh7XG4gIHVybCxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2hcbn0pID0+IHBvc3RUb0FwaSh7XG4gIHVybCxcbiAgaGVhZGVyczogX19zcHJlYWRWYWx1ZXMoe1xuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gIH0sIGhlYWRlcnMpLFxuICBib2R5OiB7XG4gICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgdmFsdWVzOiBib2R5XG4gIH0sXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoXG59KTtcbnZhciBwb3N0VG9BcGkgPSBhc3luYyAoe1xuICB1cmwsXG4gIGhlYWRlcnMgPSB7fSxcbiAgYm9keSxcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2ggPSBnZXRPcmlnaW5hbEZldGNoMigpXG59KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiByZW1vdmVVbmRlZmluZWRFbnRyaWVzKGhlYWRlcnMpLFxuICAgICAgYm9keTogYm9keS5jb250ZW50LFxuICAgICAgc2lnbmFsOiBhYm9ydFNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvckluZm9ybWF0aW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JJbmZvcm1hdGlvbiA9IGF3YWl0IGZhaWxlZFJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpIHx8IEFQSUNhbGxFcnJvci5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHByb2Nlc3MgZXJyb3IgcmVzcG9uc2VcIixcbiAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JJbmZvcm1hdGlvbi52YWx1ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyKHtcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikgfHwgQVBJQ2FsbEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwcm9jZXNzIHN1Y2Nlc3NmdWwgcmVzcG9uc2VcIixcbiAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczogYm9keS52YWx1ZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVGZXRjaEVycm9yKHsgZXJyb3IsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzIH0pO1xuICB9XG59O1xudmFyIGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlciA9ICh7XG4gIGVycm9yU2NoZW1hLFxuICBlcnJvclRvTWVzc2FnZSxcbiAgaXNSZXRyeWFibGVcbn0pID0+IGFzeW5jICh7IHJlc3BvbnNlLCB1cmwsIHJlcXVlc3RCb2R5VmFsdWVzIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKHJlc3BvbnNlQm9keS50cmltKCkgPT09IFwiXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgdmFsdWU6IG5ldyBBUElDYWxsRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlKVxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkRXJyb3IgPSBhd2FpdCBwYXJzZUpTT04oe1xuICAgICAgdGV4dDogcmVzcG9uc2VCb2R5LFxuICAgICAgc2NoZW1hOiBlcnJvclNjaGVtYVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGVycm9yVG9NZXNzYWdlKHBhcnNlZEVycm9yKSxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlc3BvbnNlQm9keSxcbiAgICAgICAgZGF0YTogcGFyc2VkRXJyb3IsXG4gICAgICAgIGlzUmV0cnlhYmxlOiBpc1JldHJ5YWJsZSA9PSBudWxsID8gdm9pZCAwIDogaXNSZXRyeWFibGUocmVzcG9uc2UsIHBhcnNlZEVycm9yKVxuICAgICAgfSlcbiAgICB9O1xuICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHZhbHVlOiBuZXcgQVBJQ2FsbEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlc3BvbnNlQm9keSxcbiAgICAgICAgaXNSZXRyeWFibGU6IGlzUmV0cnlhYmxlID09IG51bGwgPyB2b2lkIDAgOiBpc1JldHJ5YWJsZShyZXNwb25zZSlcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxufTtcbnZhciBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlciA9IChjaHVua1NjaGVtYSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKHJlc3BvbnNlLmJvZHkgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFbXB0eVJlc3BvbnNlQm9keUVycm9yKHt9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICB2YWx1ZTogcGFyc2VKc29uRXZlbnRTdHJlYW0oe1xuICAgICAgc3RyZWFtOiByZXNwb25zZS5ib2R5LFxuICAgICAgc2NoZW1hOiBjaHVua1NjaGVtYVxuICAgIH0pXG4gIH07XG59O1xudmFyIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIgPSAocmVzcG9uc2VTY2hlbWEpID0+IGFzeW5jICh7IHJlc3BvbnNlLCB1cmwsIHJlcXVlc3RCb2R5VmFsdWVzIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICBjb25zdCBwYXJzZWRSZXN1bHQgPSBhd2FpdCBzYWZlUGFyc2VKU09OKHtcbiAgICB0ZXh0OiByZXNwb25zZUJvZHksXG4gICAgc2NoZW1hOiByZXNwb25zZVNjaGVtYVxuICB9KTtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGlmICghcGFyc2VkUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBKU09OIHJlc3BvbnNlXCIsXG4gICAgICBjYXVzZTogcGFyc2VkUmVzdWx0LmVycm9yLFxuICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgdXJsLFxuICAgICAgcmVxdWVzdEJvZHlWYWx1ZXNcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICB2YWx1ZTogcGFyc2VkUmVzdWx0LnZhbHVlLFxuICAgIHJhd1ZhbHVlOiBwYXJzZWRSZXN1bHQucmF3VmFsdWVcbiAgfTtcbn07XG52YXIgc2NoZW1hU3ltYm9sID0gU3ltYm9sLmZvcihcInZlcmNlbC5haS5zY2hlbWFcIik7XG52YXIgeyBidG9hLCBhdG9iIH0gPSBnbG9iYWxUaGlzO1xuZnVuY3Rpb24gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChhcnJheSkge1xuICBsZXQgbGF0aW4xc3RyaW5nID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGxhdGluMXN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChhcnJheVtpXSk7XG4gIH1cbiAgcmV0dXJuIGJ0b2EobGF0aW4xc3RyaW5nKTtcbn1cbmZ1bmN0aW9uIHdpdGhvdXRUcmFpbGluZ1NsYXNoKHVybCkge1xuICByZXR1cm4gdXJsID09IG51bGwgPyB2b2lkIDAgOiB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xufVxuXG4vLyBzcmMvc2NoZW1hcy9yZWFzb25pbmctZGV0YWlscy50c1xuaW1wb3J0IHsgeiB9IGZyb20gXCJ6b2QvdjRcIjtcbnZhciBSZWFzb25pbmdEZXRhaWxTdW1tYXJ5U2NoZW1hID0gei5vYmplY3Qoe1xuICB0eXBlOiB6LmxpdGVyYWwoXCJyZWFzb25pbmcuc3VtbWFyeVwiIC8qIFN1bW1hcnkgKi8pLFxuICBzdW1tYXJ5OiB6LnN0cmluZygpXG59KTtcbnZhciBSZWFzb25pbmdEZXRhaWxFbmNyeXB0ZWRTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHR5cGU6IHoubGl0ZXJhbChcInJlYXNvbmluZy5lbmNyeXB0ZWRcIiAvKiBFbmNyeXB0ZWQgKi8pLFxuICBkYXRhOiB6LnN0cmluZygpXG59KTtcbnZhciBSZWFzb25pbmdEZXRhaWxUZXh0U2NoZW1hID0gei5vYmplY3Qoe1xuICB0eXBlOiB6LmxpdGVyYWwoXCJyZWFzb25pbmcudGV4dFwiIC8qIFRleHQgKi8pLFxuICB0ZXh0OiB6LnN0cmluZygpLm51bGxpc2goKSxcbiAgc2lnbmF0dXJlOiB6LnN0cmluZygpLm51bGxpc2goKVxufSk7XG52YXIgUmVhc29uaW5nRGV0YWlsVW5pb25TY2hlbWEgPSB6LnVuaW9uKFtcbiAgUmVhc29uaW5nRGV0YWlsU3VtbWFyeVNjaGVtYSxcbiAgUmVhc29uaW5nRGV0YWlsRW5jcnlwdGVkU2NoZW1hLFxuICBSZWFzb25pbmdEZXRhaWxUZXh0U2NoZW1hXG5dKTtcbnZhciBSZWFzb25pbmdEZXRhaWxzV2l0aFVua25vd25TY2hlbWEgPSB6LnVuaW9uKFtcbiAgUmVhc29uaW5nRGV0YWlsVW5pb25TY2hlbWEsXG4gIHoudW5rbm93bigpLnRyYW5zZm9ybSgoKSA9PiBudWxsKVxuXSk7XG52YXIgUmVhc29uaW5nRGV0YWlsQXJyYXlTY2hlbWEgPSB6LmFycmF5KFJlYXNvbmluZ0RldGFpbHNXaXRoVW5rbm93blNjaGVtYSkudHJhbnNmb3JtKChkKSA9PiBkLmZpbHRlcigoZDIpID0+ICEhZDIpKTtcblxuLy8gc3JjL3NjaGVtYXMvZXJyb3ItcmVzcG9uc2UudHNcbmltcG9ydCB7IHogYXMgejIgfSBmcm9tIFwiem9kL3Y0XCI7XG52YXIgT3BlblJvdXRlckVycm9yUmVzcG9uc2VTY2hlbWEgPSB6Mi5vYmplY3Qoe1xuICBlcnJvcjogejIub2JqZWN0KHtcbiAgICBjb2RlOiB6Mi51bmlvbihbejIuc3RyaW5nKCksIHoyLm51bWJlcigpXSkubnVsbGFibGUoKS5vcHRpb25hbCgpLmRlZmF1bHQobnVsbCksXG4gICAgbWVzc2FnZTogejIuc3RyaW5nKCksXG4gICAgdHlwZTogejIuc3RyaW5nKCkubnVsbGFibGUoKS5vcHRpb25hbCgpLmRlZmF1bHQobnVsbCksXG4gICAgcGFyYW06IHoyLmFueSgpLm51bGxhYmxlKCkub3B0aW9uYWwoKS5kZWZhdWx0KG51bGwpXG4gIH0pXG59KTtcbnZhciBvcGVucm91dGVyRmFpbGVkUmVzcG9uc2VIYW5kbGVyID0gY3JlYXRlSnNvbkVycm9yUmVzcG9uc2VIYW5kbGVyKHtcbiAgZXJyb3JTY2hlbWE6IE9wZW5Sb3V0ZXJFcnJvclJlc3BvbnNlU2NoZW1hLFxuICBlcnJvclRvTWVzc2FnZTogKGRhdGEpID0+IGRhdGEuZXJyb3IubWVzc2FnZVxufSk7XG5cbi8vIHNyYy91dGlscy9tYXAtZmluaXNoLXJlYXNvbi50c1xuZnVuY3Rpb24gbWFwT3BlblJvdXRlckZpbmlzaFJlYXNvbihmaW5pc2hSZWFzb24pIHtcbiAgc3dpdGNoIChmaW5pc2hSZWFzb24pIHtcbiAgICBjYXNlIFwic3RvcFwiOlxuICAgICAgcmV0dXJuIFwic3RvcFwiO1xuICAgIGNhc2UgXCJsZW5ndGhcIjpcbiAgICAgIHJldHVybiBcImxlbmd0aFwiO1xuICAgIGNhc2UgXCJjb250ZW50X2ZpbHRlclwiOlxuICAgICAgcmV0dXJuIFwiY29udGVudC1maWx0ZXJcIjtcbiAgICBjYXNlIFwiZnVuY3Rpb25fY2FsbFwiOlxuICAgIGNhc2UgXCJ0b29sX2NhbGxzXCI6XG4gICAgICByZXR1cm4gXCJ0b29sLWNhbGxzXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcInVua25vd25cIjtcbiAgfVxufVxuXG4vLyBzcmMvY2hhdC9pcy11cmwudHNcbmZ1bmN0aW9uIGlzVXJsKHtcbiAgdXJsLFxuICBwcm90b2NvbHNcbn0pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKHVybCk7XG4gICAgcmV0dXJuIHByb3RvY29scy5oYXModXJsT2JqLnByb3RvY29sKTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBzcmMvY2hhdC9maWxlLXVybC11dGlscy50c1xuZnVuY3Rpb24gZ2V0RmlsZVVybCh7XG4gIHBhcnQsXG4gIGRlZmF1bHRNZWRpYVR5cGVcbn0pIHtcbiAgdmFyIF9hMTUsIF9iO1xuICBpZiAocGFydC5kYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIGNvbnN0IGJhc2U2NCA9IGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQocGFydC5kYXRhKTtcbiAgICByZXR1cm4gYGRhdGE6JHsoX2ExNSA9IHBhcnQubWVkaWFUeXBlKSAhPSBudWxsID8gX2ExNSA6IGRlZmF1bHRNZWRpYVR5cGV9O2Jhc2U2NCwke2Jhc2U2NH1gO1xuICB9XG4gIGNvbnN0IHN0cmluZ1VybCA9IHBhcnQuZGF0YS50b1N0cmluZygpO1xuICBpZiAoaXNVcmwoe1xuICAgIHVybDogc3RyaW5nVXJsLFxuICAgIHByb3RvY29sczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiaHR0cDpcIiwgXCJodHRwczpcIl0pXG4gIH0pKSB7XG4gICAgcmV0dXJuIHN0cmluZ1VybDtcbiAgfVxuICByZXR1cm4gc3RyaW5nVXJsLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSA/IHN0cmluZ1VybCA6IGBkYXRhOiR7KF9iID0gcGFydC5tZWRpYVR5cGUpICE9IG51bGwgPyBfYiA6IGRlZmF1bHRNZWRpYVR5cGV9O2Jhc2U2NCwke3N0cmluZ1VybH1gO1xufVxuZnVuY3Rpb24gZ2V0TWVkaWFUeXBlKGRhdGFVcmwsIGRlZmF1bHRNZWRpYVR5cGUpIHtcbiAgdmFyIF9hMTU7XG4gIGNvbnN0IG1hdGNoID0gZGF0YVVybC5tYXRjaCgvXmRhdGE6KFteO10rKS8pO1xuICByZXR1cm4gbWF0Y2ggPyAoX2ExNSA9IG1hdGNoWzFdKSAhPSBudWxsID8gX2ExNSA6IGRlZmF1bHRNZWRpYVR5cGUgOiBkZWZhdWx0TWVkaWFUeXBlO1xufVxuZnVuY3Rpb24gZ2V0QmFzZTY0RnJvbURhdGFVcmwoZGF0YVVybCkge1xuICBjb25zdCBtYXRjaCA9IGRhdGFVcmwubWF0Y2goL15kYXRhOlteO10qO2Jhc2U2NCwoLispJC8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IGRhdGFVcmw7XG59XG5cbi8vIHNyYy9jaGF0L2NvbnZlcnQtdG8tb3BlbnJvdXRlci1jaGF0LW1lc3NhZ2VzLnRzXG5mdW5jdGlvbiBnZXRDYWNoZUNvbnRyb2wocHJvdmlkZXJNZXRhZGF0YSkge1xuICB2YXIgX2ExNSwgX2IsIF9jO1xuICBjb25zdCBhbnRocm9waWMgPSBwcm92aWRlck1ldGFkYXRhID09IG51bGwgPyB2b2lkIDAgOiBwcm92aWRlck1ldGFkYXRhLmFudGhyb3BpYztcbiAgY29uc3Qgb3BlbnJvdXRlcjIgPSBwcm92aWRlck1ldGFkYXRhID09IG51bGwgPyB2b2lkIDAgOiBwcm92aWRlck1ldGFkYXRhLm9wZW5yb3V0ZXI7XG4gIHJldHVybiAoX2MgPSAoX2IgPSAoX2ExNSA9IG9wZW5yb3V0ZXIyID09IG51bGwgPyB2b2lkIDAgOiBvcGVucm91dGVyMi5jYWNoZUNvbnRyb2wpICE9IG51bGwgPyBfYTE1IDogb3BlbnJvdXRlcjIgPT0gbnVsbCA/IHZvaWQgMCA6IG9wZW5yb3V0ZXIyLmNhY2hlX2NvbnRyb2wpICE9IG51bGwgPyBfYiA6IGFudGhyb3BpYyA9PSBudWxsID8gdm9pZCAwIDogYW50aHJvcGljLmNhY2hlQ29udHJvbCkgIT0gbnVsbCA/IF9jIDogYW50aHJvcGljID09IG51bGwgPyB2b2lkIDAgOiBhbnRocm9waWMuY2FjaGVfY29udHJvbDtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb09wZW5Sb3V0ZXJDaGF0TWVzc2FnZXMocHJvbXB0KSB7XG4gIHZhciBfYTE1LCBfYiwgX2M7XG4gIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gIGZvciAoY29uc3QgeyByb2xlLCBjb250ZW50LCBwcm92aWRlck9wdGlvbnMgfSBvZiBwcm9tcHQpIHtcbiAgICBzd2l0Y2ggKHJvbGUpIHtcbiAgICAgIGNhc2UgXCJzeXN0ZW1cIjoge1xuICAgICAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgY2FjaGVfY29udHJvbDogZ2V0Q2FjaGVDb250cm9sKHByb3ZpZGVyT3B0aW9ucylcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICBpZiAoY29udGVudC5sZW5ndGggPT09IDEgJiYgKChfYTE1ID0gY29udGVudFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTUudHlwZSkgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgY29uc3QgY2FjaGVDb250cm9sID0gKF9iID0gZ2V0Q2FjaGVDb250cm9sKHByb3ZpZGVyT3B0aW9ucykpICE9IG51bGwgPyBfYiA6IGdldENhY2hlQ29udHJvbChjb250ZW50WzBdLnByb3ZpZGVyT3B0aW9ucyk7XG4gICAgICAgICAgY29uc3QgY29udGVudFdpdGhDYWNoZUNvbnRyb2wgPSBjYWNoZUNvbnRyb2wgPyBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICB0ZXh0OiBjb250ZW50WzBdLnRleHQsXG4gICAgICAgICAgICAgIGNhY2hlX2NvbnRyb2w6IGNhY2hlQ29udHJvbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0gOiBjb250ZW50WzBdLnRleHQ7XG4gICAgICAgICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnRXaXRoQ2FjaGVDb250cm9sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZUNhY2hlQ29udHJvbCA9IGdldENhY2hlQ29udHJvbChwcm92aWRlck9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjb250ZW50UGFydHMgPSBjb250ZW50Lm1hcChcbiAgICAgICAgICAocGFydCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hMTYsIF9iMiwgX2MyLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVDb250cm9sID0gKF9hMTYgPSBnZXRDYWNoZUNvbnRyb2wocGFydC5wcm92aWRlck9wdGlvbnMpKSAhPSBudWxsID8gX2ExNiA6IG1lc3NhZ2VDYWNoZUNvbnRyb2w7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICAgIC8vIEZvciB0ZXh0IHBhcnRzLCBvbmx5IHVzZSBwYXJ0LXNwZWNpZmljIGNhY2hlIGNvbnRyb2xcbiAgICAgICAgICAgICAgICAgIGNhY2hlX2NvbnRyb2w6IGNhY2hlQ29udHJvbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgICBpZiAoKF9iMiA9IHBhcnQubWVkaWFUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGdldEZpbGVVcmwoe1xuICAgICAgICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TWVkaWFUeXBlOiBcImltYWdlL2pwZWdcIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlX3VybFwiLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZV91cmw6IHtcbiAgICAgICAgICAgICAgICAgICAgICB1cmxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGltYWdlIHBhcnRzLCB1c2UgcGFydC1zcGVjaWZpYyBvciBtZXNzYWdlLWxldmVsIGNhY2hlIGNvbnRyb2xcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVfY29udHJvbDogY2FjaGVDb250cm9sXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IFN0cmluZyhcbiAgICAgICAgICAgICAgICAgIChfZiA9IChfZSA9IChfZCA9IChfYzIgPSBwYXJ0LnByb3ZpZGVyT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jMi5vcGVucm91dGVyKSA9PSBudWxsID8gdm9pZCAwIDogX2QuZmlsZW5hbWUpICE9IG51bGwgPyBfZSA6IHBhcnQuZmlsZW5hbWUpICE9IG51bGwgPyBfZiA6IFwiXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVEYXRhID0gZ2V0RmlsZVVybCh7XG4gICAgICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICAgICAgZGVmYXVsdE1lZGlhVHlwZTogXCJhcHBsaWNhdGlvbi9wZGZcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpc1VybCh7XG4gICAgICAgICAgICAgICAgICB1cmw6IGZpbGVEYXRhLFxuICAgICAgICAgICAgICAgICAgcHJvdG9jb2xzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJodHRwOlwiLCBcImh0dHBzOlwiXSlcbiAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgZmlsZV9kYXRhOiBmaWxlRGF0YVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgICBmaWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZV9kYXRhOiBmaWxlRGF0YVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGNhY2hlX2NvbnRyb2w6IGNhY2hlQ29udHJvbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICBjYWNoZV9jb250cm9sOiBjYWNoZUNvbnRyb2xcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjb250ZW50OiBjb250ZW50UGFydHNcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImFzc2lzdGFudFwiOiB7XG4gICAgICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICAgICAgbGV0IHJlYXNvbmluZyA9IFwiXCI7XG4gICAgICAgIGNvbnN0IHJlYXNvbmluZ0RldGFpbHMgPSBbXTtcbiAgICAgICAgY29uc3QgdG9vbENhbGxzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBjb250ZW50KSB7XG4gICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgdGV4dCArPSBwYXJ0LnRleHQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgICAgIHRvb2xDYWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgbmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5zdHJpbmdpZnkocGFydC5pbnB1dClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmdcIjoge1xuICAgICAgICAgICAgICByZWFzb25pbmcgKz0gcGFydC50ZXh0O1xuICAgICAgICAgICAgICByZWFzb25pbmdEZXRhaWxzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLnRleHRcIiAvKiBUZXh0ICovLFxuICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgY29udGVudDogdGV4dCxcbiAgICAgICAgICB0b29sX2NhbGxzOiB0b29sQ2FsbHMubGVuZ3RoID4gMCA/IHRvb2xDYWxscyA6IHZvaWQgMCxcbiAgICAgICAgICByZWFzb25pbmc6IHJlYXNvbmluZyB8fCB2b2lkIDAsXG4gICAgICAgICAgcmVhc29uaW5nX2RldGFpbHM6IHJlYXNvbmluZ0RldGFpbHMubGVuZ3RoID4gMCA/IHJlYXNvbmluZ0RldGFpbHMgOiB2b2lkIDAsXG4gICAgICAgICAgY2FjaGVfY29udHJvbDogZ2V0Q2FjaGVDb250cm9sKHByb3ZpZGVyT3B0aW9ucylcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgICBmb3IgKGNvbnN0IHRvb2xSZXNwb25zZSBvZiBjb250ZW50KSB7XG4gICAgICAgICAgY29uc3QgY29udGVudDIgPSBnZXRUb29sUmVzdWx0Q29udGVudCh0b29sUmVzcG9uc2UpO1xuICAgICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgICAgICB0b29sX2NhbGxfaWQ6IHRvb2xSZXNwb25zZS50b29sQ2FsbElkLFxuICAgICAgICAgICAgY29udGVudDogY29udGVudDIsXG4gICAgICAgICAgICBjYWNoZV9jb250cm9sOiAoX2MgPSBnZXRDYWNoZUNvbnRyb2wocHJvdmlkZXJPcHRpb25zKSkgIT0gbnVsbCA/IF9jIDogZ2V0Q2FjaGVDb250cm9sKHRvb2xSZXNwb25zZS5wcm92aWRlck9wdGlvbnMpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWVzc2FnZXM7XG59XG5mdW5jdGlvbiBnZXRUb29sUmVzdWx0Q29udGVudChpbnB1dCkge1xuICByZXR1cm4gaW5wdXQub3V0cHV0LnR5cGUgPT09IFwidGV4dFwiID8gaW5wdXQub3V0cHV0LnZhbHVlIDogSlNPTi5zdHJpbmdpZnkoaW5wdXQub3V0cHV0LnZhbHVlKTtcbn1cblxuLy8gc3JjL2NoYXQvZ2V0LXRvb2wtY2hvaWNlLnRzXG5pbXBvcnQgeyB6IGFzIHozIH0gZnJvbSBcInpvZC92NFwiO1xudmFyIENoYXRDb21wbGV0aW9uVG9vbENob2ljZVNjaGVtYSA9IHozLnVuaW9uKFtcbiAgejMubGl0ZXJhbChcImF1dG9cIiksXG4gIHozLmxpdGVyYWwoXCJub25lXCIpLFxuICB6My5saXRlcmFsKFwicmVxdWlyZWRcIiksXG4gIHozLm9iamVjdCh7XG4gICAgdHlwZTogejMubGl0ZXJhbChcImZ1bmN0aW9uXCIpLFxuICAgIGZ1bmN0aW9uOiB6My5vYmplY3Qoe1xuICAgICAgbmFtZTogejMuc3RyaW5nKClcbiAgICB9KVxuICB9KVxuXSk7XG5mdW5jdGlvbiBnZXRDaGF0Q29tcGxldGlvblRvb2xDaG9pY2UodG9vbENob2ljZSkge1xuICBzd2l0Y2ggKHRvb2xDaG9pY2UudHlwZSkge1xuICAgIGNhc2UgXCJhdXRvXCI6XG4gICAgY2FzZSBcIm5vbmVcIjpcbiAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgIHJldHVybiB0b29sQ2hvaWNlLnR5cGU7XG4gICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBmdW5jdGlvbjogeyBuYW1lOiB0b29sQ2hvaWNlLnRvb2xOYW1lIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRvb2xDaG9pY2U7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdG9vbCBjaG9pY2UgdHlwZTogJHt0b29sQ2hvaWNlfWApO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvY2hhdC9zY2hlbWFzLnRzXG5pbXBvcnQgeyB6IGFzIHo2IH0gZnJvbSBcInpvZC92NFwiO1xuXG4vLyBzcmMvc2NoZW1hcy9pbWFnZS50c1xuaW1wb3J0IHsgeiBhcyB6NSB9IGZyb20gXCJ6b2QvdjRcIjtcbnZhciBJbWFnZVJlc3BvbnNlU2NoZW1hID0gejUub2JqZWN0KHtcbiAgdHlwZTogejUubGl0ZXJhbChcImltYWdlX3VybFwiKSxcbiAgaW1hZ2VfdXJsOiB6NS5vYmplY3Qoe1xuICAgIHVybDogejUuc3RyaW5nKClcbiAgfSlcbn0pO1xudmFyIEltYWdlUmVzcG9uc2VXaXRoVW5rbm93blNjaGVtYSA9IHo1LnVuaW9uKFtcbiAgSW1hZ2VSZXNwb25zZVNjaGVtYSxcbiAgejUudW5rbm93bigpLnRyYW5zZm9ybSgoKSA9PiBudWxsKVxuXSk7XG52YXIgSW1hZ2VSZXNwb25zZUFycmF5U2NoZW1hID0gejUuYXJyYXkoSW1hZ2VSZXNwb25zZVdpdGhVbmtub3duU2NoZW1hKS50cmFuc2Zvcm0oKGQpID0+IGQuZmlsdGVyKChkMikgPT4gISFkMikpO1xuXG4vLyBzcmMvY2hhdC9zY2hlbWFzLnRzXG52YXIgT3BlblJvdXRlckNoYXRDb21wbGV0aW9uQmFzZVJlc3BvbnNlU2NoZW1hID0gejYub2JqZWN0KHtcbiAgaWQ6IHo2LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIG1vZGVsOiB6Ni5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBwcm92aWRlcjogejYuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgdXNhZ2U6IHo2Lm9iamVjdCh7XG4gICAgcHJvbXB0X3Rva2VuczogejYubnVtYmVyKCksXG4gICAgcHJvbXB0X3Rva2Vuc19kZXRhaWxzOiB6Ni5vYmplY3Qoe1xuICAgICAgY2FjaGVkX3Rva2VuczogejYubnVtYmVyKClcbiAgICB9KS5udWxsaXNoKCksXG4gICAgY29tcGxldGlvbl90b2tlbnM6IHo2Lm51bWJlcigpLFxuICAgIGNvbXBsZXRpb25fdG9rZW5zX2RldGFpbHM6IHo2Lm9iamVjdCh7XG4gICAgICByZWFzb25pbmdfdG9rZW5zOiB6Ni5udW1iZXIoKVxuICAgIH0pLm51bGxpc2goKSxcbiAgICB0b3RhbF90b2tlbnM6IHo2Lm51bWJlcigpLFxuICAgIGNvc3Q6IHo2Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgY29zdF9kZXRhaWxzOiB6Ni5vYmplY3Qoe1xuICAgICAgdXBzdHJlYW1faW5mZXJlbmNlX2Nvc3Q6IHo2Lm51bWJlcigpLm51bGxpc2goKVxuICAgIH0pLm51bGxpc2goKVxuICB9KS5udWxsaXNoKClcbn0pO1xudmFyIE9wZW5Sb3V0ZXJOb25TdHJlYW1DaGF0Q29tcGxldGlvblJlc3BvbnNlU2NoZW1hID0gT3BlblJvdXRlckNoYXRDb21wbGV0aW9uQmFzZVJlc3BvbnNlU2NoZW1hLmV4dGVuZCh7XG4gIGNob2ljZXM6IHo2LmFycmF5KFxuICAgIHo2Lm9iamVjdCh7XG4gICAgICBtZXNzYWdlOiB6Ni5vYmplY3Qoe1xuICAgICAgICByb2xlOiB6Ni5saXRlcmFsKFwiYXNzaXN0YW50XCIpLFxuICAgICAgICBjb250ZW50OiB6Ni5zdHJpbmcoKS5udWxsYWJsZSgpLm9wdGlvbmFsKCksXG4gICAgICAgIHJlYXNvbmluZzogejYuc3RyaW5nKCkubnVsbGFibGUoKS5vcHRpb25hbCgpLFxuICAgICAgICByZWFzb25pbmdfZGV0YWlsczogUmVhc29uaW5nRGV0YWlsQXJyYXlTY2hlbWEubnVsbGlzaCgpLFxuICAgICAgICBpbWFnZXM6IEltYWdlUmVzcG9uc2VBcnJheVNjaGVtYS5udWxsaXNoKCksXG4gICAgICAgIHRvb2xfY2FsbHM6IHo2LmFycmF5KFxuICAgICAgICAgIHo2Lm9iamVjdCh7XG4gICAgICAgICAgICBpZDogejYuc3RyaW5nKCkub3B0aW9uYWwoKS5udWxsYWJsZSgpLFxuICAgICAgICAgICAgdHlwZTogejYubGl0ZXJhbChcImZ1bmN0aW9uXCIpLFxuICAgICAgICAgICAgZnVuY3Rpb246IHo2Lm9iamVjdCh7XG4gICAgICAgICAgICAgIG5hbWU6IHo2LnN0cmluZygpLFxuICAgICAgICAgICAgICBhcmd1bWVudHM6IHo2LnN0cmluZygpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgICkub3B0aW9uYWwoKSxcbiAgICAgICAgYW5ub3RhdGlvbnM6IHo2LmFycmF5KFxuICAgICAgICAgIHo2Lm9iamVjdCh7XG4gICAgICAgICAgICB0eXBlOiB6Ni5lbnVtKFtcInVybF9jaXRhdGlvblwiXSksXG4gICAgICAgICAgICB1cmxfY2l0YXRpb246IHo2Lm9iamVjdCh7XG4gICAgICAgICAgICAgIGVuZF9pbmRleDogejYubnVtYmVyKCksXG4gICAgICAgICAgICAgIHN0YXJ0X2luZGV4OiB6Ni5udW1iZXIoKSxcbiAgICAgICAgICAgICAgdGl0bGU6IHo2LnN0cmluZygpLFxuICAgICAgICAgICAgICB1cmw6IHo2LnN0cmluZygpLFxuICAgICAgICAgICAgICBjb250ZW50OiB6Ni5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgICkubnVsbGlzaCgpXG4gICAgICB9KSxcbiAgICAgIGluZGV4OiB6Ni5udW1iZXIoKS5udWxsaXNoKCksXG4gICAgICBsb2dwcm9iczogejYub2JqZWN0KHtcbiAgICAgICAgY29udGVudDogejYuYXJyYXkoXG4gICAgICAgICAgejYub2JqZWN0KHtcbiAgICAgICAgICAgIHRva2VuOiB6Ni5zdHJpbmcoKSxcbiAgICAgICAgICAgIGxvZ3Byb2I6IHo2Lm51bWJlcigpLFxuICAgICAgICAgICAgdG9wX2xvZ3Byb2JzOiB6Ni5hcnJheShcbiAgICAgICAgICAgICAgejYub2JqZWN0KHtcbiAgICAgICAgICAgICAgICB0b2tlbjogejYuc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgbG9ncHJvYjogejYubnVtYmVyKClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KVxuICAgICAgICApLm51bGxhYmxlKClcbiAgICAgIH0pLm51bGxhYmxlKCkub3B0aW9uYWwoKSxcbiAgICAgIGZpbmlzaF9yZWFzb246IHo2LnN0cmluZygpLm9wdGlvbmFsKCkubnVsbGFibGUoKVxuICAgIH0pXG4gIClcbn0pO1xudmFyIE9wZW5Sb3V0ZXJTdHJlYW1DaGF0Q29tcGxldGlvbkNodW5rU2NoZW1hID0gejYudW5pb24oW1xuICBPcGVuUm91dGVyQ2hhdENvbXBsZXRpb25CYXNlUmVzcG9uc2VTY2hlbWEuZXh0ZW5kKHtcbiAgICBjaG9pY2VzOiB6Ni5hcnJheShcbiAgICAgIHo2Lm9iamVjdCh7XG4gICAgICAgIGRlbHRhOiB6Ni5vYmplY3Qoe1xuICAgICAgICAgIHJvbGU6IHo2LmVudW0oW1wiYXNzaXN0YW50XCJdKS5vcHRpb25hbCgpLFxuICAgICAgICAgIGNvbnRlbnQ6IHo2LnN0cmluZygpLm51bGxpc2goKSxcbiAgICAgICAgICByZWFzb25pbmc6IHo2LnN0cmluZygpLm51bGxpc2goKS5vcHRpb25hbCgpLFxuICAgICAgICAgIHJlYXNvbmluZ19kZXRhaWxzOiBSZWFzb25pbmdEZXRhaWxBcnJheVNjaGVtYS5udWxsaXNoKCksXG4gICAgICAgICAgaW1hZ2VzOiBJbWFnZVJlc3BvbnNlQXJyYXlTY2hlbWEubnVsbGlzaCgpLFxuICAgICAgICAgIHRvb2xfY2FsbHM6IHo2LmFycmF5KFxuICAgICAgICAgICAgejYub2JqZWN0KHtcbiAgICAgICAgICAgICAgaW5kZXg6IHo2Lm51bWJlcigpLm51bGxpc2goKSxcbiAgICAgICAgICAgICAgaWQ6IHo2LnN0cmluZygpLm51bGxpc2goKSxcbiAgICAgICAgICAgICAgdHlwZTogejYubGl0ZXJhbChcImZ1bmN0aW9uXCIpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGZ1bmN0aW9uOiB6Ni5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIG5hbWU6IHo2LnN0cmluZygpLm51bGxpc2goKSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IHo2LnN0cmluZygpLm51bGxpc2goKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLm51bGxpc2goKSxcbiAgICAgICAgICBhbm5vdGF0aW9uczogejYuYXJyYXkoXG4gICAgICAgICAgICB6Ni5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6Ni5lbnVtKFtcInVybF9jaXRhdGlvblwiXSksXG4gICAgICAgICAgICAgIHVybF9jaXRhdGlvbjogejYub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBlbmRfaW5kZXg6IHo2Lm51bWJlcigpLFxuICAgICAgICAgICAgICAgIHN0YXJ0X2luZGV4OiB6Ni5udW1iZXIoKSxcbiAgICAgICAgICAgICAgICB0aXRsZTogejYuc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgdXJsOiB6Ni5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB6Ni5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICkubnVsbGlzaCgpXG4gICAgICAgIH0pLm51bGxpc2goKSxcbiAgICAgICAgbG9ncHJvYnM6IHo2Lm9iamVjdCh7XG4gICAgICAgICAgY29udGVudDogejYuYXJyYXkoXG4gICAgICAgICAgICB6Ni5vYmplY3Qoe1xuICAgICAgICAgICAgICB0b2tlbjogejYuc3RyaW5nKCksXG4gICAgICAgICAgICAgIGxvZ3Byb2I6IHo2Lm51bWJlcigpLFxuICAgICAgICAgICAgICB0b3BfbG9ncHJvYnM6IHo2LmFycmF5KFxuICAgICAgICAgICAgICAgIHo2Lm9iamVjdCh7XG4gICAgICAgICAgICAgICAgICB0b2tlbjogejYuc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICBsb2dwcm9iOiB6Ni5udW1iZXIoKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKS5udWxsYWJsZSgpXG4gICAgICAgIH0pLm51bGxpc2goKSxcbiAgICAgICAgZmluaXNoX3JlYXNvbjogejYuc3RyaW5nKCkubnVsbGFibGUoKS5vcHRpb25hbCgpLFxuICAgICAgICBpbmRleDogejYubnVtYmVyKCkubnVsbGlzaCgpXG4gICAgICB9KVxuICAgIClcbiAgfSksXG4gIE9wZW5Sb3V0ZXJFcnJvclJlc3BvbnNlU2NoZW1hXG5dKTtcblxuLy8gc3JjL2NoYXQvaW5kZXgudHNcbnZhciBPcGVuUm91dGVyQ2hhdExhbmd1YWdlTW9kZWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG1vZGVsSWQsIHNldHRpbmdzLCBjb25maWcpIHtcbiAgICB0aGlzLnNwZWNpZmljYXRpb25WZXJzaW9uID0gXCJ2MlwiO1xuICAgIHRoaXMucHJvdmlkZXIgPSBcIm9wZW5yb3V0ZXJcIjtcbiAgICB0aGlzLmRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZSA9IFwidG9vbFwiO1xuICAgIHRoaXMuc3VwcG9ydGVkVXJscyA9IHtcbiAgICAgIFwiaW1hZ2UvKlwiOiBbXG4gICAgICAgIC9eZGF0YTppbWFnZVxcL1thLXpBLVpdKztiYXNlNjQsLyxcbiAgICAgICAgL15odHRwcz86XFwvXFwvLitcXC4oanBnfGpwZWd8cG5nfGdpZnx3ZWJwKSQvaVxuICAgICAgXSxcbiAgICAgIC8vICd0ZXh0LyonOiBbL15kYXRhOnRleHRcXC8vLCAvXmh0dHBzPzpcXC9cXC8uKyQvXSxcbiAgICAgIFwiYXBwbGljYXRpb24vKlwiOiBbL15kYXRhOmFwcGxpY2F0aW9uXFwvLywgL15odHRwcz86XFwvXFwvLiskL11cbiAgICB9O1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG4gIGdldEFyZ3Moe1xuICAgIHByb21wdCxcbiAgICBtYXhPdXRwdXRUb2tlbnMsXG4gICAgdGVtcGVyYXR1cmUsXG4gICAgdG9wUCxcbiAgICBmcmVxdWVuY3lQZW5hbHR5LFxuICAgIHByZXNlbmNlUGVuYWx0eSxcbiAgICBzZWVkLFxuICAgIHN0b3BTZXF1ZW5jZXMsXG4gICAgcmVzcG9uc2VGb3JtYXQsXG4gICAgdG9wSyxcbiAgICB0b29scyxcbiAgICB0b29sQ2hvaWNlXG4gIH0pIHtcbiAgICB2YXIgX2ExNTtcbiAgICBjb25zdCBiYXNlQXJncyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIC8vIG1vZGVsIGlkOlxuICAgICAgbW9kZWw6IHRoaXMubW9kZWxJZCxcbiAgICAgIG1vZGVsczogdGhpcy5zZXR0aW5ncy5tb2RlbHMsXG4gICAgICAvLyBtb2RlbCBzcGVjaWZpYyBzZXR0aW5nczpcbiAgICAgIGxvZ2l0X2JpYXM6IHRoaXMuc2V0dGluZ3MubG9naXRCaWFzLFxuICAgICAgbG9ncHJvYnM6IHRoaXMuc2V0dGluZ3MubG9ncHJvYnMgPT09IHRydWUgfHwgdHlwZW9mIHRoaXMuc2V0dGluZ3MubG9ncHJvYnMgPT09IFwibnVtYmVyXCIgPyB0cnVlIDogdm9pZCAwLFxuICAgICAgdG9wX2xvZ3Byb2JzOiB0eXBlb2YgdGhpcy5zZXR0aW5ncy5sb2dwcm9icyA9PT0gXCJudW1iZXJcIiA/IHRoaXMuc2V0dGluZ3MubG9ncHJvYnMgOiB0eXBlb2YgdGhpcy5zZXR0aW5ncy5sb2dwcm9icyA9PT0gXCJib29sZWFuXCIgPyB0aGlzLnNldHRpbmdzLmxvZ3Byb2JzID8gMCA6IHZvaWQgMCA6IHZvaWQgMCxcbiAgICAgIHVzZXI6IHRoaXMuc2V0dGluZ3MudXNlcixcbiAgICAgIHBhcmFsbGVsX3Rvb2xfY2FsbHM6IHRoaXMuc2V0dGluZ3MucGFyYWxsZWxUb29sQ2FsbHMsXG4gICAgICAvLyBzdGFuZGFyZGl6ZWQgc2V0dGluZ3M6XG4gICAgICBtYXhfdG9rZW5zOiBtYXhPdXRwdXRUb2tlbnMsXG4gICAgICB0ZW1wZXJhdHVyZSxcbiAgICAgIHRvcF9wOiB0b3BQLFxuICAgICAgZnJlcXVlbmN5X3BlbmFsdHk6IGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICBwcmVzZW5jZV9wZW5hbHR5OiBwcmVzZW5jZVBlbmFsdHksXG4gICAgICBzZWVkLFxuICAgICAgc3RvcDogc3RvcFNlcXVlbmNlcyxcbiAgICAgIHJlc3BvbnNlX2Zvcm1hdDogcmVzcG9uc2VGb3JtYXQsXG4gICAgICB0b3BfazogdG9wSyxcbiAgICAgIC8vIG1lc3NhZ2VzOlxuICAgICAgbWVzc2FnZXM6IGNvbnZlcnRUb09wZW5Sb3V0ZXJDaGF0TWVzc2FnZXMocHJvbXB0KSxcbiAgICAgIC8vIE9wZW5Sb3V0ZXIgc3BlY2lmaWMgc2V0dGluZ3M6XG4gICAgICBpbmNsdWRlX3JlYXNvbmluZzogdGhpcy5zZXR0aW5ncy5pbmNsdWRlUmVhc29uaW5nLFxuICAgICAgcmVhc29uaW5nOiB0aGlzLnNldHRpbmdzLnJlYXNvbmluZyxcbiAgICAgIHVzYWdlOiB0aGlzLnNldHRpbmdzLnVzYWdlLFxuICAgICAgLy8gV2ViIHNlYXJjaCBzZXR0aW5nczpcbiAgICAgIHBsdWdpbnM6IHRoaXMuc2V0dGluZ3MucGx1Z2lucyxcbiAgICAgIHdlYl9zZWFyY2hfb3B0aW9uczogdGhpcy5zZXR0aW5ncy53ZWJfc2VhcmNoX29wdGlvbnMsXG4gICAgICAvLyBQcm92aWRlciByb3V0aW5nIHNldHRpbmdzOlxuICAgICAgcHJvdmlkZXI6IHRoaXMuc2V0dGluZ3MucHJvdmlkZXJcbiAgICB9LCB0aGlzLmNvbmZpZy5leHRyYUJvZHkpLCB0aGlzLnNldHRpbmdzLmV4dHJhQm9keSk7XG4gICAgaWYgKChyZXNwb25zZUZvcm1hdCA9PSBudWxsID8gdm9pZCAwIDogcmVzcG9uc2VGb3JtYXQudHlwZSkgPT09IFwianNvblwiICYmIHJlc3BvbnNlRm9ybWF0LnNjaGVtYSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYmFzZUFyZ3MpLCB7XG4gICAgICAgIHJlc3BvbnNlX2Zvcm1hdDoge1xuICAgICAgICAgIHR5cGU6IFwianNvbl9zY2hlbWFcIixcbiAgICAgICAgICBqc29uX3NjaGVtYTogX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICAgICAgc2NoZW1hOiByZXNwb25zZUZvcm1hdC5zY2hlbWEsXG4gICAgICAgICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICAgICAgICBuYW1lOiAoX2ExNSA9IHJlc3BvbnNlRm9ybWF0Lm5hbWUpICE9IG51bGwgPyBfYTE1IDogXCJyZXNwb25zZVwiXG4gICAgICAgICAgfSwgcmVzcG9uc2VGb3JtYXQuZGVzY3JpcHRpb24gJiYge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IHJlc3BvbnNlRm9ybWF0LmRlc2NyaXB0aW9uXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0b29scyAmJiB0b29scy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBtYXBwZWRUb29scyA9IHRvb2xzLmZpbHRlcigodG9vbCkgPT4gdG9vbC50eXBlID09PSBcImZ1bmN0aW9uXCIpLm1hcCgodG9vbCkgPT4gKHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgIG5hbWU6IHRvb2wubmFtZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbC5kZXNjcmlwdGlvbixcbiAgICAgICAgICBwYXJhbWV0ZXJzOiB0b29sLmlucHV0U2NoZW1hXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBiYXNlQXJncyksIHtcbiAgICAgICAgdG9vbHM6IG1hcHBlZFRvb2xzLFxuICAgICAgICB0b29sX2Nob2ljZTogdG9vbENob2ljZSA/IGdldENoYXRDb21wbGV0aW9uVG9vbENob2ljZSh0b29sQ2hvaWNlKSA6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlQXJncztcbiAgfVxuICBhc3luYyBkb0dlbmVyYXRlKG9wdGlvbnMpIHtcbiAgICB2YXIgX2ExNSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9pLCBfaiwgX2ssIF9sLCBfbSwgX24sIF9vLCBfcCwgX3EsIF9yLCBfcywgX3QsIF91LCBfdiwgX3csIF94O1xuICAgIGNvbnN0IHByb3ZpZGVyT3B0aW9ucyA9IG9wdGlvbnMucHJvdmlkZXJPcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IG9wZW5yb3V0ZXJPcHRpb25zID0gcHJvdmlkZXJPcHRpb25zLm9wZW5yb3V0ZXIgfHwge307XG4gICAgY29uc3QgYXJncyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLmdldEFyZ3Mob3B0aW9ucykpLCBvcGVucm91dGVyT3B0aW9ucyk7XG4gICAgY29uc3QgeyB2YWx1ZTogcmVzcG9uc2UsIHJlc3BvbnNlSGVhZGVycyB9ID0gYXdhaXQgcG9zdEpzb25Ub0FwaSh7XG4gICAgICB1cmw6IHRoaXMuY29uZmlnLnVybCh7XG4gICAgICAgIHBhdGg6IFwiL2NoYXQvY29tcGxldGlvbnNcIixcbiAgICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbElkXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IGNvbWJpbmVIZWFkZXJzKHRoaXMuY29uZmlnLmhlYWRlcnMoKSwgb3B0aW9ucy5oZWFkZXJzKSxcbiAgICAgIGJvZHk6IGFyZ3MsXG4gICAgICBmYWlsZWRSZXNwb25zZUhhbmRsZXI6IG9wZW5yb3V0ZXJGYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gICAgICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyOiBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyKFxuICAgICAgICBPcGVuUm91dGVyTm9uU3RyZWFtQ2hhdENvbXBsZXRpb25SZXNwb25zZVNjaGVtYVxuICAgICAgKSxcbiAgICAgIGFib3J0U2lnbmFsOiBvcHRpb25zLmFib3J0U2lnbmFsLFxuICAgICAgZmV0Y2g6IHRoaXMuY29uZmlnLmZldGNoXG4gICAgfSk7XG4gICAgY29uc3QgY2hvaWNlID0gcmVzcG9uc2UuY2hvaWNlc1swXTtcbiAgICBpZiAoIWNob2ljZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2hvaWNlIGluIHJlc3BvbnNlXCIpO1xuICAgIH1cbiAgICBjb25zdCB1c2FnZUluZm8gPSByZXNwb25zZS51c2FnZSA/IHtcbiAgICAgIGlucHV0VG9rZW5zOiAoX2ExNSA9IHJlc3BvbnNlLnVzYWdlLnByb21wdF90b2tlbnMpICE9IG51bGwgPyBfYTE1IDogMCxcbiAgICAgIG91dHB1dFRva2VuczogKF9iID0gcmVzcG9uc2UudXNhZ2UuY29tcGxldGlvbl90b2tlbnMpICE9IG51bGwgPyBfYiA6IDAsXG4gICAgICB0b3RhbFRva2VuczogKChfYyA9IHJlc3BvbnNlLnVzYWdlLnByb21wdF90b2tlbnMpICE9IG51bGwgPyBfYyA6IDApICsgKChfZCA9IHJlc3BvbnNlLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zKSAhPSBudWxsID8gX2QgOiAwKSxcbiAgICAgIHJlYXNvbmluZ1Rva2VuczogKF9mID0gKF9lID0gcmVzcG9uc2UudXNhZ2UuY29tcGxldGlvbl90b2tlbnNfZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLnJlYXNvbmluZ190b2tlbnMpICE9IG51bGwgPyBfZiA6IDAsXG4gICAgICBjYWNoZWRJbnB1dFRva2VuczogKF9oID0gKF9nID0gcmVzcG9uc2UudXNhZ2UucHJvbXB0X3Rva2Vuc19kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2cuY2FjaGVkX3Rva2VucykgIT0gbnVsbCA/IF9oIDogMFxuICAgIH0gOiB7XG4gICAgICBpbnB1dFRva2VuczogMCxcbiAgICAgIG91dHB1dFRva2VuczogMCxcbiAgICAgIHRvdGFsVG9rZW5zOiAwLFxuICAgICAgcmVhc29uaW5nVG9rZW5zOiAwLFxuICAgICAgY2FjaGVkSW5wdXRUb2tlbnM6IDBcbiAgICB9O1xuICAgIGNvbnN0IHJlYXNvbmluZ0RldGFpbHMgPSAoX2kgPSBjaG9pY2UubWVzc2FnZS5yZWFzb25pbmdfZGV0YWlscykgIT0gbnVsbCA/IF9pIDogW107XG4gICAgY29uc3QgcmVhc29uaW5nID0gcmVhc29uaW5nRGV0YWlscy5sZW5ndGggPiAwID8gcmVhc29uaW5nRGV0YWlscy5tYXAoKGRldGFpbCkgPT4ge1xuICAgICAgc3dpdGNoIChkZXRhaWwudHlwZSkge1xuICAgICAgICBjYXNlIFwicmVhc29uaW5nLnRleHRcIiAvKiBUZXh0ICovOiB7XG4gICAgICAgICAgaWYgKGRldGFpbC50ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgICB0ZXh0OiBkZXRhaWwudGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJlYXNvbmluZy5zdW1tYXJ5XCIgLyogU3VtbWFyeSAqLzoge1xuICAgICAgICAgIGlmIChkZXRhaWwuc3VtbWFyeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICAgICAgdGV4dDogZGV0YWlsLnN1bW1hcnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyZWFzb25pbmcuZW5jcnlwdGVkXCIgLyogRW5jcnlwdGVkICovOiB7XG4gICAgICAgICAgaWYgKGRldGFpbC5kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgICB0ZXh0OiBcIltSRURBQ1RFRF1cIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGRldGFpbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSkuZmlsdGVyKChwKSA9PiBwICE9PSBudWxsKSA6IGNob2ljZS5tZXNzYWdlLnJlYXNvbmluZyA/IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgdGV4dDogY2hvaWNlLm1lc3NhZ2UucmVhc29uaW5nXG4gICAgICB9XG4gICAgXSA6IFtdO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBbXTtcbiAgICBjb250ZW50LnB1c2goLi4ucmVhc29uaW5nKTtcbiAgICBpZiAoY2hvaWNlLm1lc3NhZ2UuY29udGVudCkge1xuICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgIHRleHQ6IGNob2ljZS5tZXNzYWdlLmNvbnRlbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoY2hvaWNlLm1lc3NhZ2UudG9vbF9jYWxscykge1xuICAgICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiBjaG9pY2UubWVzc2FnZS50b29sX2NhbGxzKSB7XG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICB0b29sQ2FsbElkOiAoX2ogPSB0b29sQ2FsbC5pZCkgIT0gbnVsbCA/IF9qIDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgIGlucHV0OiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaG9pY2UubWVzc2FnZS5pbWFnZXMpIHtcbiAgICAgIGZvciAoY29uc3QgaW1hZ2Ugb2YgY2hvaWNlLm1lc3NhZ2UuaW1hZ2VzKSB7XG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgbWVkaWFUeXBlOiBnZXRNZWRpYVR5cGUoaW1hZ2UuaW1hZ2VfdXJsLnVybCwgXCJpbWFnZS9qcGVnXCIpLFxuICAgICAgICAgIGRhdGE6IGdldEJhc2U2NEZyb21EYXRhVXJsKGltYWdlLmltYWdlX3VybC51cmwpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2hvaWNlLm1lc3NhZ2UuYW5ub3RhdGlvbnMpIHtcbiAgICAgIGZvciAoY29uc3QgYW5ub3RhdGlvbiBvZiBjaG9pY2UubWVzc2FnZS5hbm5vdGF0aW9ucykge1xuICAgICAgICBpZiAoYW5ub3RhdGlvbi50eXBlID09PSBcInVybF9jaXRhdGlvblwiKSB7XG4gICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwic291cmNlXCIsXG4gICAgICAgICAgICBzb3VyY2VUeXBlOiBcInVybFwiLFxuICAgICAgICAgICAgaWQ6IGFubm90YXRpb24udXJsX2NpdGF0aW9uLnVybCxcbiAgICAgICAgICAgIHVybDogYW5ub3RhdGlvbi51cmxfY2l0YXRpb24udXJsLFxuICAgICAgICAgICAgdGl0bGU6IGFubm90YXRpb24udXJsX2NpdGF0aW9uLnRpdGxlLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YToge1xuICAgICAgICAgICAgICBvcGVucm91dGVyOiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogYW5ub3RhdGlvbi51cmxfY2l0YXRpb24uY29udGVudCB8fCBcIlwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudCxcbiAgICAgIGZpbmlzaFJlYXNvbjogbWFwT3BlblJvdXRlckZpbmlzaFJlYXNvbihjaG9pY2UuZmluaXNoX3JlYXNvbiksXG4gICAgICB1c2FnZTogdXNhZ2VJbmZvLFxuICAgICAgd2FybmluZ3M6IFtdLFxuICAgICAgcHJvdmlkZXJNZXRhZGF0YToge1xuICAgICAgICBvcGVucm91dGVyOiB7XG4gICAgICAgICAgcHJvdmlkZXI6IChfayA9IHJlc3BvbnNlLnByb3ZpZGVyKSAhPSBudWxsID8gX2sgOiBcIlwiLFxuICAgICAgICAgIHVzYWdlOiB7XG4gICAgICAgICAgICBwcm9tcHRUb2tlbnM6IChfbCA9IHVzYWdlSW5mby5pbnB1dFRva2VucykgIT0gbnVsbCA/IF9sIDogMCxcbiAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IChfbSA9IHVzYWdlSW5mby5vdXRwdXRUb2tlbnMpICE9IG51bGwgPyBfbSA6IDAsXG4gICAgICAgICAgICB0b3RhbFRva2VuczogKF9uID0gdXNhZ2VJbmZvLnRvdGFsVG9rZW5zKSAhPSBudWxsID8gX24gOiAwLFxuICAgICAgICAgICAgY29zdDogKF9vID0gcmVzcG9uc2UudXNhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfby5jb3N0LFxuICAgICAgICAgICAgcHJvbXB0VG9rZW5zRGV0YWlsczoge1xuICAgICAgICAgICAgICBjYWNoZWRUb2tlbnM6IChfciA9IChfcSA9IChfcCA9IHJlc3BvbnNlLnVzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX3AucHJvbXB0X3Rva2Vuc19kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX3EuY2FjaGVkX3Rva2VucykgIT0gbnVsbCA/IF9yIDogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnNEZXRhaWxzOiB7XG4gICAgICAgICAgICAgIHJlYXNvbmluZ1Rva2VuczogKF91ID0gKF90ID0gKF9zID0gcmVzcG9uc2UudXNhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfcy5jb21wbGV0aW9uX3Rva2Vuc19kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX3QucmVhc29uaW5nX3Rva2VucykgIT0gbnVsbCA/IF91IDogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvc3REZXRhaWxzOiB7XG4gICAgICAgICAgICAgIHVwc3RyZWFtSW5mZXJlbmNlQ29zdDogKF94ID0gKF93ID0gKF92ID0gcmVzcG9uc2UudXNhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfdi5jb3N0X2RldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfdy51cHN0cmVhbV9pbmZlcmVuY2VfY29zdCkgIT0gbnVsbCA/IF94IDogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlcXVlc3Q6IHsgYm9keTogYXJncyB9LFxuICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgaWQ6IHJlc3BvbnNlLmlkLFxuICAgICAgICBtb2RlbElkOiByZXNwb25zZS5tb2RlbCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBhc3luYyBkb1N0cmVhbShvcHRpb25zKSB7XG4gICAgdmFyIF9hMTU7XG4gICAgY29uc3QgcHJvdmlkZXJPcHRpb25zID0gb3B0aW9ucy5wcm92aWRlck9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgb3BlbnJvdXRlck9wdGlvbnMgPSBwcm92aWRlck9wdGlvbnMub3BlbnJvdXRlciB8fCB7fTtcbiAgICBjb25zdCBhcmdzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuZ2V0QXJncyhvcHRpb25zKSksIG9wZW5yb3V0ZXJPcHRpb25zKTtcbiAgICBjb25zdCB7IHZhbHVlOiByZXNwb25zZSwgcmVzcG9uc2VIZWFkZXJzIH0gPSBhd2FpdCBwb3N0SnNvblRvQXBpKHtcbiAgICAgIHVybDogdGhpcy5jb25maWcudXJsKHtcbiAgICAgICAgcGF0aDogXCIvY2hhdC9jb21wbGV0aW9uc1wiLFxuICAgICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWRcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogY29tYmluZUhlYWRlcnModGhpcy5jb25maWcuaGVhZGVycygpLCBvcHRpb25zLmhlYWRlcnMpLFxuICAgICAgYm9keTogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYXJncyksIHtcbiAgICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgICAvLyBvbmx5IGluY2x1ZGUgc3RyZWFtX29wdGlvbnMgd2hlbiBpbiBzdHJpY3QgY29tcGF0aWJpbGl0eSBtb2RlOlxuICAgICAgICBzdHJlYW1fb3B0aW9uczogdGhpcy5jb25maWcuY29tcGF0aWJpbGl0eSA9PT0gXCJzdHJpY3RcIiA/IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICBpbmNsdWRlX3VzYWdlOiB0cnVlXG4gICAgICAgIH0sICgoX2ExNSA9IHRoaXMuc2V0dGluZ3MudXNhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTE1LmluY2x1ZGUpID8geyBpbmNsdWRlX3VzYWdlOiB0cnVlIH0gOiB7fSkgOiB2b2lkIDBcbiAgICAgIH0pLFxuICAgICAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyOiBvcGVucm91dGVyRmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICAgICAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcjogY3JlYXRlRXZlbnRTb3VyY2VSZXNwb25zZUhhbmRsZXIoXG4gICAgICAgIE9wZW5Sb3V0ZXJTdHJlYW1DaGF0Q29tcGxldGlvbkNodW5rU2NoZW1hXG4gICAgICApLFxuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICBmZXRjaDogdGhpcy5jb25maWcuZmV0Y2hcbiAgICB9KTtcbiAgICBjb25zdCB0b29sQ2FsbHMgPSBbXTtcbiAgICBsZXQgZmluaXNoUmVhc29uID0gXCJvdGhlclwiO1xuICAgIGNvbnN0IHVzYWdlID0ge1xuICAgICAgaW5wdXRUb2tlbnM6IE51bWJlci5OYU4sXG4gICAgICBvdXRwdXRUb2tlbnM6IE51bWJlci5OYU4sXG4gICAgICB0b3RhbFRva2VuczogTnVtYmVyLk5hTixcbiAgICAgIHJlYXNvbmluZ1Rva2VuczogTnVtYmVyLk5hTixcbiAgICAgIGNhY2hlZElucHV0VG9rZW5zOiBOdW1iZXIuTmFOXG4gICAgfTtcbiAgICBjb25zdCBvcGVucm91dGVyVXNhZ2UgPSB7fTtcbiAgICBsZXQgdGV4dFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBsZXQgcmVhc29uaW5nU3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCB0ZXh0SWQ7XG4gICAgbGV0IHJlYXNvbmluZ0lkO1xuICAgIGxldCBvcGVucm91dGVyUmVzcG9uc2VJZDtcbiAgICBsZXQgcHJvdmlkZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmVhbTogcmVzcG9uc2UucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgdmFyIF9hMTYsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaSwgX2osIF9rLCBfbCwgX20sIF9uO1xuICAgICAgICAgICAgaWYgKCFjaHVuay5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgIGZpbmlzaFJlYXNvbiA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvcjogY2h1bmsuZXJyb3IgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2h1bmsudmFsdWU7XG4gICAgICAgICAgICBpZiAoXCJlcnJvclwiIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgIGZpbmlzaFJlYXNvbiA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvcjogdmFsdWUuZXJyb3IgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS5wcm92aWRlcikge1xuICAgICAgICAgICAgICBwcm92aWRlciA9IHZhbHVlLnByb3ZpZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLmlkKSB7XG4gICAgICAgICAgICAgIG9wZW5yb3V0ZXJSZXNwb25zZUlkID0gdmFsdWUuaWQ7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZXNwb25zZS1tZXRhZGF0YVwiLFxuICAgICAgICAgICAgICAgIGlkOiB2YWx1ZS5pZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS5tb2RlbCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVzcG9uc2UtbWV0YWRhdGFcIixcbiAgICAgICAgICAgICAgICBtb2RlbElkOiB2YWx1ZS5tb2RlbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS51c2FnZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHVzYWdlLmlucHV0VG9rZW5zID0gdmFsdWUudXNhZ2UucHJvbXB0X3Rva2VucztcbiAgICAgICAgICAgICAgdXNhZ2Uub3V0cHV0VG9rZW5zID0gdmFsdWUudXNhZ2UuY29tcGxldGlvbl90b2tlbnM7XG4gICAgICAgICAgICAgIHVzYWdlLnRvdGFsVG9rZW5zID0gdmFsdWUudXNhZ2UucHJvbXB0X3Rva2VucyArIHZhbHVlLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zO1xuICAgICAgICAgICAgICBvcGVucm91dGVyVXNhZ2UucHJvbXB0VG9rZW5zID0gdmFsdWUudXNhZ2UucHJvbXB0X3Rva2VucztcbiAgICAgICAgICAgICAgaWYgKHZhbHVlLnVzYWdlLnByb21wdF90b2tlbnNfZGV0YWlscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZElucHV0VG9rZW5zID0gKF9hMTYgPSB2YWx1ZS51c2FnZS5wcm9tcHRfdG9rZW5zX2RldGFpbHMuY2FjaGVkX3Rva2VucykgIT0gbnVsbCA/IF9hMTYgOiAwO1xuICAgICAgICAgICAgICAgIHVzYWdlLmNhY2hlZElucHV0VG9rZW5zID0gY2FjaGVkSW5wdXRUb2tlbnM7XG4gICAgICAgICAgICAgICAgb3BlbnJvdXRlclVzYWdlLnByb21wdFRva2Vuc0RldGFpbHMgPSB7XG4gICAgICAgICAgICAgICAgICBjYWNoZWRUb2tlbnM6IGNhY2hlZElucHV0VG9rZW5zXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcGVucm91dGVyVXNhZ2UuY29tcGxldGlvblRva2VucyA9IHZhbHVlLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zO1xuICAgICAgICAgICAgICBpZiAodmFsdWUudXNhZ2UuY29tcGxldGlvbl90b2tlbnNfZGV0YWlscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYXNvbmluZ1Rva2VucyA9IChfYiA9IHZhbHVlLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zX2RldGFpbHMucmVhc29uaW5nX3Rva2VucykgIT0gbnVsbCA/IF9iIDogMDtcbiAgICAgICAgICAgICAgICB1c2FnZS5yZWFzb25pbmdUb2tlbnMgPSByZWFzb25pbmdUb2tlbnM7XG4gICAgICAgICAgICAgICAgb3BlbnJvdXRlclVzYWdlLmNvbXBsZXRpb25Ub2tlbnNEZXRhaWxzID0ge1xuICAgICAgICAgICAgICAgICAgcmVhc29uaW5nVG9rZW5zXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcGVucm91dGVyVXNhZ2UuY29zdCA9IHZhbHVlLnVzYWdlLmNvc3Q7XG4gICAgICAgICAgICAgIG9wZW5yb3V0ZXJVc2FnZS50b3RhbFRva2VucyA9IHZhbHVlLnVzYWdlLnRvdGFsX3Rva2VucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNob2ljZSA9IHZhbHVlLmNob2ljZXNbMF07XG4gICAgICAgICAgICBpZiAoKGNob2ljZSA9PSBudWxsID8gdm9pZCAwIDogY2hvaWNlLmZpbmlzaF9yZWFzb24pICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gbWFwT3BlblJvdXRlckZpbmlzaFJlYXNvbihjaG9pY2UuZmluaXNoX3JlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGNob2ljZSA9PSBudWxsID8gdm9pZCAwIDogY2hvaWNlLmRlbHRhKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gY2hvaWNlLmRlbHRhO1xuICAgICAgICAgICAgY29uc3QgZW1pdFJlYXNvbmluZ0NodW5rID0gKGNodW5rVGV4dCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXJlYXNvbmluZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICByZWFzb25pbmdJZCA9IG9wZW5yb3V0ZXJSZXNwb25zZUlkIHx8IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctc3RhcnRcIixcbiAgICAgICAgICAgICAgICAgIGlkOiByZWFzb25pbmdJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlYXNvbmluZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctZGVsdGFcIixcbiAgICAgICAgICAgICAgICBkZWx0YTogY2h1bmtUZXh0LFxuICAgICAgICAgICAgICAgIGlkOiByZWFzb25pbmdJZCB8fCBnZW5lcmF0ZUlkKClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGRlbHRhLnJlYXNvbmluZ19kZXRhaWxzICYmIGRlbHRhLnJlYXNvbmluZ19kZXRhaWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBkZXRhaWwgb2YgZGVsdGEucmVhc29uaW5nX2RldGFpbHMpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRldGFpbC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLnRleHRcIiAvKiBUZXh0ICovOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXRhaWwudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGVtaXRSZWFzb25pbmdDaHVuayhkZXRhaWwudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLmVuY3J5cHRlZFwiIC8qIEVuY3J5cHRlZCAqLzoge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGV0YWlsLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlbWl0UmVhc29uaW5nQ2h1bmsoXCJbUkVEQUNURURdXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy5zdW1tYXJ5XCIgLyogU3VtbWFyeSAqLzoge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGV0YWlsLnN1bW1hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlbWl0UmVhc29uaW5nQ2h1bmsoZGV0YWlsLnN1bW1hcnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWx0YS5yZWFzb25pbmcpIHtcbiAgICAgICAgICAgICAgZW1pdFJlYXNvbmluZ0NodW5rKGRlbHRhLnJlYXNvbmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVsdGEuY29udGVudCkge1xuICAgICAgICAgICAgICBpZiAocmVhc29uaW5nU3RhcnRlZCAmJiAhdGV4dFN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctZW5kXCIsXG4gICAgICAgICAgICAgICAgICBpZDogcmVhc29uaW5nSWQgfHwgZ2VuZXJhdGVJZCgpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVhc29uaW5nU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghdGV4dFN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0SWQgPSBvcGVucm91dGVyUmVzcG9uc2VJZCB8fCBnZW5lcmF0ZUlkKCk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1zdGFydFwiLFxuICAgICAgICAgICAgICAgICAgaWQ6IHRleHRJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRleHRTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgIGRlbHRhOiBkZWx0YS5jb250ZW50LFxuICAgICAgICAgICAgICAgIGlkOiB0ZXh0SWQgfHwgZ2VuZXJhdGVJZCgpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbHRhLmFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgYW5ub3RhdGlvbiBvZiBkZWx0YS5hbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uLnR5cGUgPT09IFwidXJsX2NpdGF0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic291cmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVR5cGU6IFwidXJsXCIsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBhbm5vdGF0aW9uLnVybF9jaXRhdGlvbi51cmwsXG4gICAgICAgICAgICAgICAgICAgIHVybDogYW5ub3RhdGlvbi51cmxfY2l0YXRpb24udXJsLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogYW5ub3RhdGlvbi51cmxfY2l0YXRpb24udGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvcGVucm91dGVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBhbm5vdGF0aW9uLnVybF9jaXRhdGlvbi5jb250ZW50IHx8IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbHRhLnRvb2xfY2FsbHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsRGVsdGEgb2YgZGVsdGEudG9vbF9jYWxscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gKF9jID0gdG9vbENhbGxEZWx0YS5pbmRleCkgIT0gbnVsbCA/IF9jIDogdG9vbENhbGxzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2xDYWxsc1tpbmRleF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRvb2xDYWxsRGVsdGEudHlwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRvb2xDYWxsRGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkICdmdW5jdGlvbicgdHlwZS5gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRvb2xDYWxsRGVsdGEuaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0b29sQ2FsbERlbHRhLFxuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCAnaWQnIHRvIGJlIGEgc3RyaW5nLmBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoKChfZCA9IHRvb2xDYWxsRGVsdGEuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZC5uYW1lKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRvb2xDYWxsRGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkICdmdW5jdGlvbi5uYW1lJyB0byBiZSBhIHN0cmluZy5gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxzW2luZGV4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRvb2xDYWxsRGVsdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sQ2FsbERlbHRhLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiAoX2UgPSB0b29sQ2FsbERlbHRhLmZ1bmN0aW9uLmFyZ3VtZW50cykgIT0gbnVsbCA/IF9lIDogXCJcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpbnB1dFN0YXJ0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBzZW50OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsMiA9IHRvb2xDYWxsc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICBpZiAodG9vbENhbGwyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vbCBjYWxsIGlzIG1pc3NpbmdcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoKChfZiA9IHRvb2xDYWxsMi5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLm5hbWUpICE9IG51bGwgJiYgKChfZyA9IHRvb2xDYWxsMi5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLmFyZ3VtZW50cykgIT0gbnVsbCAmJiBpc1BhcnNhYmxlSnNvbih0b29sQ2FsbDIuZnVuY3Rpb24uYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbDIuaW5wdXRTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtaW5wdXQtc3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwyLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbDIuZnVuY3Rpb24ubmFtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtaW5wdXQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwyLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhOiB0b29sQ2FsbDIuZnVuY3Rpb24uYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1pbnB1dC1lbmRcIixcbiAgICAgICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwyLmlkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwyLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbDIuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogdG9vbENhbGwyLmZ1bmN0aW9uLmFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGwyLnNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsID0gdG9vbENhbGxzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAodG9vbENhbGwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vbCBjYWxsIGlzIG1pc3NpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdG9vbENhbGwuaW5wdXRTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbC5pbnB1dFN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWlucHV0LXN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWVcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKChfaCA9IHRvb2xDYWxsRGVsdGEuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfaC5hcmd1bWVudHMpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyArPSAoX2ogPSAoX2kgPSB0b29sQ2FsbERlbHRhLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2kuYXJndW1lbnRzKSAhPSBudWxsID8gX2ogOiBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWlucHV0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgICBkZWx0YTogKF9rID0gdG9vbENhbGxEZWx0YS5mdW5jdGlvbi5hcmd1bWVudHMpICE9IG51bGwgPyBfayA6IFwiXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoKChfbCA9IHRvb2xDYWxsLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2wubmFtZSkgIT0gbnVsbCAmJiAoKF9tID0gdG9vbENhbGwuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfbS5hcmd1bWVudHMpICE9IG51bGwgJiYgaXNQYXJzYWJsZUpzb24odG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogKF9uID0gdG9vbENhbGwuaWQpICE9IG51bGwgPyBfbiA6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGwuc2VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVsdGEuaW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBpbWFnZSBvZiBkZWx0YS5pbWFnZXMpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgICBtZWRpYVR5cGU6IGdldE1lZGlhVHlwZShpbWFnZS5pbWFnZV91cmwudXJsLCBcImltYWdlL2pwZWdcIiksXG4gICAgICAgICAgICAgICAgICBkYXRhOiBnZXRCYXNlNjRGcm9tRGF0YVVybChpbWFnZS5pbWFnZV91cmwudXJsKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICB2YXIgX2ExNjtcbiAgICAgICAgICAgIGlmIChmaW5pc2hSZWFzb24gPT09IFwidG9vbC1jYWxsc1wiKSB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2YgdG9vbENhbGxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2xDYWxsICYmICF0b29sQ2FsbC5zZW50KSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiAoX2ExNiA9IHRvb2xDYWxsLmlkKSAhPSBudWxsID8gX2ExNiA6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSBpbnZhbGlkIGFyZ3VtZW50cyB0byBhbiBlbXB0eSBKU09OIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogaXNQYXJzYWJsZUpzb24odG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzKSA/IHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyA6IFwie31cIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbC5zZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWFzb25pbmdTdGFydGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctZW5kXCIsXG4gICAgICAgICAgICAgICAgaWQ6IHJlYXNvbmluZ0lkIHx8IGdlbmVyYXRlSWQoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXh0U3RhcnRlZCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1lbmRcIixcbiAgICAgICAgICAgICAgICBpZDogdGV4dElkIHx8IGdlbmVyYXRlSWQoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wZW5yb3V0ZXJNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgdXNhZ2U6IG9wZW5yb3V0ZXJVc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlciAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIG9wZW5yb3V0ZXJNZXRhZGF0YS5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJmaW5pc2hcIixcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIG9wZW5yb3V0ZXI6IG9wZW5yb3V0ZXJNZXRhZGF0YVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgd2FybmluZ3M6IFtdLFxuICAgICAgcmVxdWVzdDogeyBib2R5OiBhcmdzIH0sXG4gICAgICByZXNwb25zZTogeyBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMgfVxuICAgIH07XG4gIH1cbn07XG5cbi8vIHNyYy9jb21wbGV0aW9uL2NvbnZlcnQtdG8tb3BlbnJvdXRlci1jb21wbGV0aW9uLXByb21wdC50c1xuZnVuY3Rpb24gY29udmVydFRvT3BlblJvdXRlckNvbXBsZXRpb25Qcm9tcHQoe1xuICBwcm9tcHQsXG4gIGlucHV0Rm9ybWF0LFxuICB1c2VyID0gXCJ1c2VyXCIsXG4gIGFzc2lzdGFudCA9IFwiYXNzaXN0YW50XCJcbn0pIHtcbiAgaWYgKGlucHV0Rm9ybWF0ID09PSBcInByb21wdFwiICYmIHByb21wdC5sZW5ndGggPT09IDEgJiYgcHJvbXB0WzBdICYmIHByb21wdFswXS5yb2xlID09PSBcInVzZXJcIiAmJiBwcm9tcHRbMF0uY29udGVudC5sZW5ndGggPT09IDEgJiYgcHJvbXB0WzBdLmNvbnRlbnRbMF0gJiYgcHJvbXB0WzBdLmNvbnRlbnRbMF0udHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICByZXR1cm4geyBwcm9tcHQ6IHByb21wdFswXS5jb250ZW50WzBdLnRleHQgfTtcbiAgfVxuICBsZXQgdGV4dCA9IFwiXCI7XG4gIGlmIChwcm9tcHRbMF0gJiYgcHJvbXB0WzBdLnJvbGUgPT09IFwic3lzdGVtXCIpIHtcbiAgICB0ZXh0ICs9IGAke3Byb21wdFswXS5jb250ZW50fVxuXG5gO1xuICAgIHByb21wdCA9IHByb21wdC5zbGljZSgxKTtcbiAgfVxuICBmb3IgKGNvbnN0IHsgcm9sZSwgY29udGVudCB9IG9mIHByb21wdCkge1xuICAgIHN3aXRjaCAocm9sZSkge1xuICAgICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IGBVbmV4cGVjdGVkIHN5c3RlbSBtZXNzYWdlIGluIHByb21wdDogJHtjb250ZW50fWAsXG4gICAgICAgICAgcHJvbXB0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICBjb25zdCB1c2VyTWVzc2FnZSA9IGNvbnRlbnQubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yKHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcImZpbGUgYXR0YWNobWVudHNcIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKFwiXCIpO1xuICAgICAgICB0ZXh0ICs9IGAke3VzZXJ9OlxuJHt1c2VyTWVzc2FnZX1cblxuYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgICAgY29uc3QgYXNzaXN0YW50TWVzc2FnZSA9IGNvbnRlbnQubWFwKFxuICAgICAgICAgIChwYXJ0KSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudGV4dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25hbGl0eTogXCJ0b29sLWNhbGwgbWVzc2FnZXNcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yKHtcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwidG9vbC1yZXN1bHQgbWVzc2FnZXNcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmdcIjoge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcInJlYXNvbmluZyBtZXNzYWdlc1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcImZpbGUgYXR0YWNobWVudHNcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKS5qb2luKFwiXCIpO1xuICAgICAgICB0ZXh0ICs9IGAke2Fzc2lzdGFudH06XG4ke2Fzc2lzdGFudE1lc3NhZ2V9XG5cbmA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwidG9vbCBtZXNzYWdlc1wiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGV4dCArPSBgJHthc3Npc3RhbnR9OlxuYDtcbiAgcmV0dXJuIHtcbiAgICBwcm9tcHQ6IHRleHRcbiAgfTtcbn1cblxuLy8gc3JjL2NvbXBsZXRpb24vc2NoZW1hcy50c1xuaW1wb3J0IHsgeiBhcyB6NyB9IGZyb20gXCJ6b2QvdjRcIjtcbnZhciBPcGVuUm91dGVyQ29tcGxldGlvbkNodW5rU2NoZW1hID0gejcudW5pb24oW1xuICB6Ny5vYmplY3Qoe1xuICAgIGlkOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIG1vZGVsOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGNob2ljZXM6IHo3LmFycmF5KFxuICAgICAgejcub2JqZWN0KHtcbiAgICAgICAgdGV4dDogejcuc3RyaW5nKCksXG4gICAgICAgIHJlYXNvbmluZzogejcuc3RyaW5nKCkubnVsbGlzaCgpLm9wdGlvbmFsKCksXG4gICAgICAgIHJlYXNvbmluZ19kZXRhaWxzOiBSZWFzb25pbmdEZXRhaWxBcnJheVNjaGVtYS5udWxsaXNoKCksXG4gICAgICAgIGZpbmlzaF9yZWFzb246IHo3LnN0cmluZygpLm51bGxpc2goKSxcbiAgICAgICAgaW5kZXg6IHo3Lm51bWJlcigpLm51bGxpc2goKSxcbiAgICAgICAgbG9ncHJvYnM6IHo3Lm9iamVjdCh7XG4gICAgICAgICAgdG9rZW5zOiB6Ny5hcnJheSh6Ny5zdHJpbmcoKSksXG4gICAgICAgICAgdG9rZW5fbG9ncHJvYnM6IHo3LmFycmF5KHo3Lm51bWJlcigpKSxcbiAgICAgICAgICB0b3BfbG9ncHJvYnM6IHo3LmFycmF5KHo3LnJlY29yZCh6Ny5zdHJpbmcoKSwgejcubnVtYmVyKCkpKS5udWxsYWJsZSgpXG4gICAgICAgIH0pLm51bGxhYmxlKCkub3B0aW9uYWwoKVxuICAgICAgfSlcbiAgICApLFxuICAgIHVzYWdlOiB6Ny5vYmplY3Qoe1xuICAgICAgcHJvbXB0X3Rva2VuczogejcubnVtYmVyKCksXG4gICAgICBwcm9tcHRfdG9rZW5zX2RldGFpbHM6IHo3Lm9iamVjdCh7XG4gICAgICAgIGNhY2hlZF90b2tlbnM6IHo3Lm51bWJlcigpXG4gICAgICB9KS5udWxsaXNoKCksXG4gICAgICBjb21wbGV0aW9uX3Rva2VuczogejcubnVtYmVyKCksXG4gICAgICBjb21wbGV0aW9uX3Rva2Vuc19kZXRhaWxzOiB6Ny5vYmplY3Qoe1xuICAgICAgICByZWFzb25pbmdfdG9rZW5zOiB6Ny5udW1iZXIoKVxuICAgICAgfSkubnVsbGlzaCgpLFxuICAgICAgdG90YWxfdG9rZW5zOiB6Ny5udW1iZXIoKSxcbiAgICAgIGNvc3Q6IHo3Lm51bWJlcigpLm9wdGlvbmFsKClcbiAgICB9KS5udWxsaXNoKClcbiAgfSksXG4gIE9wZW5Sb3V0ZXJFcnJvclJlc3BvbnNlU2NoZW1hXG5dKTtcblxuLy8gc3JjL2NvbXBsZXRpb24vaW5kZXgudHNcbnZhciBPcGVuUm91dGVyQ29tcGxldGlvbkxhbmd1YWdlTW9kZWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG1vZGVsSWQsIHNldHRpbmdzLCBjb25maWcpIHtcbiAgICB0aGlzLnNwZWNpZmljYXRpb25WZXJzaW9uID0gXCJ2MlwiO1xuICAgIHRoaXMucHJvdmlkZXIgPSBcIm9wZW5yb3V0ZXJcIjtcbiAgICB0aGlzLnN1cHBvcnRlZFVybHMgPSB7XG4gICAgICBcImltYWdlLypcIjogW1xuICAgICAgICAvXmRhdGE6aW1hZ2VcXC9bYS16QS1aXSs7YmFzZTY0LC8sXG4gICAgICAgIC9eaHR0cHM/OlxcL1xcLy4rXFwuKGpwZ3xqcGVnfHBuZ3xnaWZ8d2VicCkkL2lcbiAgICAgIF0sXG4gICAgICBcInRleHQvKlwiOiBbL15kYXRhOnRleHRcXC8vLCAvXmh0dHBzPzpcXC9cXC8uKyQvXSxcbiAgICAgIFwiYXBwbGljYXRpb24vKlwiOiBbL15kYXRhOmFwcGxpY2F0aW9uXFwvLywgL15odHRwcz86XFwvXFwvLiskL11cbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdE9iamVjdEdlbmVyYXRpb25Nb2RlID0gdm9pZCAwO1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG4gIGdldEFyZ3Moe1xuICAgIHByb21wdCxcbiAgICBtYXhPdXRwdXRUb2tlbnMsXG4gICAgdGVtcGVyYXR1cmUsXG4gICAgdG9wUCxcbiAgICBmcmVxdWVuY3lQZW5hbHR5LFxuICAgIHByZXNlbmNlUGVuYWx0eSxcbiAgICBzZWVkLFxuICAgIHJlc3BvbnNlRm9ybWF0LFxuICAgIHRvcEssXG4gICAgc3RvcFNlcXVlbmNlcyxcbiAgICB0b29scyxcbiAgICB0b29sQ2hvaWNlXG4gIH0pIHtcbiAgICBjb25zdCB7IHByb21wdDogY29tcGxldGlvblByb21wdCB9ID0gY29udmVydFRvT3BlblJvdXRlckNvbXBsZXRpb25Qcm9tcHQoe1xuICAgICAgcHJvbXB0LFxuICAgICAgaW5wdXRGb3JtYXQ6IFwicHJvbXB0XCJcbiAgICB9KTtcbiAgICBpZiAodG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yKHtcbiAgICAgICAgZnVuY3Rpb25hbGl0eTogXCJ0b29sc1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRvb2xDaG9pY2UpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwidG9vbENob2ljZVwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIC8vIG1vZGVsIGlkOlxuICAgICAgbW9kZWw6IHRoaXMubW9kZWxJZCxcbiAgICAgIG1vZGVsczogdGhpcy5zZXR0aW5ncy5tb2RlbHMsXG4gICAgICAvLyBtb2RlbCBzcGVjaWZpYyBzZXR0aW5nczpcbiAgICAgIGxvZ2l0X2JpYXM6IHRoaXMuc2V0dGluZ3MubG9naXRCaWFzLFxuICAgICAgbG9ncHJvYnM6IHR5cGVvZiB0aGlzLnNldHRpbmdzLmxvZ3Byb2JzID09PSBcIm51bWJlclwiID8gdGhpcy5zZXR0aW5ncy5sb2dwcm9icyA6IHR5cGVvZiB0aGlzLnNldHRpbmdzLmxvZ3Byb2JzID09PSBcImJvb2xlYW5cIiA/IHRoaXMuc2V0dGluZ3MubG9ncHJvYnMgPyAwIDogdm9pZCAwIDogdm9pZCAwLFxuICAgICAgc3VmZml4OiB0aGlzLnNldHRpbmdzLnN1ZmZpeCxcbiAgICAgIHVzZXI6IHRoaXMuc2V0dGluZ3MudXNlcixcbiAgICAgIC8vIHN0YW5kYXJkaXplZCBzZXR0aW5nczpcbiAgICAgIG1heF90b2tlbnM6IG1heE91dHB1dFRva2VucyxcbiAgICAgIHRlbXBlcmF0dXJlLFxuICAgICAgdG9wX3A6IHRvcFAsXG4gICAgICBmcmVxdWVuY3lfcGVuYWx0eTogZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgIHByZXNlbmNlX3BlbmFsdHk6IHByZXNlbmNlUGVuYWx0eSxcbiAgICAgIHNlZWQsXG4gICAgICBzdG9wOiBzdG9wU2VxdWVuY2VzLFxuICAgICAgcmVzcG9uc2VfZm9ybWF0OiByZXNwb25zZUZvcm1hdCxcbiAgICAgIHRvcF9rOiB0b3BLLFxuICAgICAgLy8gcHJvbXB0OlxuICAgICAgcHJvbXB0OiBjb21wbGV0aW9uUHJvbXB0LFxuICAgICAgLy8gT3BlblJvdXRlciBzcGVjaWZpYyBzZXR0aW5nczpcbiAgICAgIGluY2x1ZGVfcmVhc29uaW5nOiB0aGlzLnNldHRpbmdzLmluY2x1ZGVSZWFzb25pbmcsXG4gICAgICByZWFzb25pbmc6IHRoaXMuc2V0dGluZ3MucmVhc29uaW5nXG4gICAgfSwgdGhpcy5jb25maWcuZXh0cmFCb2R5KSwgdGhpcy5zZXR0aW5ncy5leHRyYUJvZHkpO1xuICB9XG4gIGFzeW5jIGRvR2VuZXJhdGUob3B0aW9ucykge1xuICAgIHZhciBfYTE1LCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2ksIF9qLCBfaywgX2wsIF9tLCBfbiwgX287XG4gICAgY29uc3QgcHJvdmlkZXJPcHRpb25zID0gb3B0aW9ucy5wcm92aWRlck9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgb3BlbnJvdXRlck9wdGlvbnMgPSBwcm92aWRlck9wdGlvbnMub3BlbnJvdXRlciB8fCB7fTtcbiAgICBjb25zdCBhcmdzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuZ2V0QXJncyhvcHRpb25zKSksIG9wZW5yb3V0ZXJPcHRpb25zKTtcbiAgICBjb25zdCB7IHZhbHVlOiByZXNwb25zZSwgcmVzcG9uc2VIZWFkZXJzIH0gPSBhd2FpdCBwb3N0SnNvblRvQXBpKHtcbiAgICAgIHVybDogdGhpcy5jb25maWcudXJsKHtcbiAgICAgICAgcGF0aDogXCIvY29tcGxldGlvbnNcIixcbiAgICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbElkXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IGNvbWJpbmVIZWFkZXJzKHRoaXMuY29uZmlnLmhlYWRlcnMoKSwgb3B0aW9ucy5oZWFkZXJzKSxcbiAgICAgIGJvZHk6IGFyZ3MsXG4gICAgICBmYWlsZWRSZXNwb25zZUhhbmRsZXI6IG9wZW5yb3V0ZXJGYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gICAgICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyOiBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyKFxuICAgICAgICBPcGVuUm91dGVyQ29tcGxldGlvbkNodW5rU2NoZW1hXG4gICAgICApLFxuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICBmZXRjaDogdGhpcy5jb25maWcuZmV0Y2hcbiAgICB9KTtcbiAgICBpZiAoXCJlcnJvclwiIGluIHJlc3BvbnNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzcG9uc2UuZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgY29uc3QgY2hvaWNlID0gcmVzcG9uc2UuY2hvaWNlc1swXTtcbiAgICBpZiAoIWNob2ljZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2hvaWNlIGluIE9wZW5Sb3V0ZXIgY29tcGxldGlvbiByZXNwb25zZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgIHRleHQ6IChfYTE1ID0gY2hvaWNlLnRleHQpICE9IG51bGwgPyBfYTE1IDogXCJcIlxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgZmluaXNoUmVhc29uOiBtYXBPcGVuUm91dGVyRmluaXNoUmVhc29uKGNob2ljZS5maW5pc2hfcmVhc29uKSxcbiAgICAgIHVzYWdlOiB7XG4gICAgICAgIGlucHV0VG9rZW5zOiAoX2MgPSAoX2IgPSByZXNwb25zZS51c2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnByb21wdF90b2tlbnMpICE9IG51bGwgPyBfYyA6IDAsXG4gICAgICAgIG91dHB1dFRva2VuczogKF9lID0gKF9kID0gcmVzcG9uc2UudXNhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfZC5jb21wbGV0aW9uX3Rva2VucykgIT0gbnVsbCA/IF9lIDogMCxcbiAgICAgICAgdG90YWxUb2tlbnM6ICgoX2cgPSAoX2YgPSByZXNwb25zZS51c2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnByb21wdF90b2tlbnMpICE9IG51bGwgPyBfZyA6IDApICsgKChfaSA9IChfaCA9IHJlc3BvbnNlLnVzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2guY29tcGxldGlvbl90b2tlbnMpICE9IG51bGwgPyBfaSA6IDApLFxuICAgICAgICByZWFzb25pbmdUb2tlbnM6IChfbCA9IChfayA9IChfaiA9IHJlc3BvbnNlLnVzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2ouY29tcGxldGlvbl90b2tlbnNfZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9rLnJlYXNvbmluZ190b2tlbnMpICE9IG51bGwgPyBfbCA6IDAsXG4gICAgICAgIGNhY2hlZElucHV0VG9rZW5zOiAoX28gPSAoX24gPSAoX20gPSByZXNwb25zZS51c2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tLnByb21wdF90b2tlbnNfZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9uLmNhY2hlZF90b2tlbnMpICE9IG51bGwgPyBfbyA6IDBcbiAgICAgIH0sXG4gICAgICB3YXJuaW5nczogW10sXG4gICAgICByZXNwb25zZToge1xuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnNcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGFzeW5jIGRvU3RyZWFtKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwcm92aWRlck9wdGlvbnMgPSBvcHRpb25zLnByb3ZpZGVyT3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBvcGVucm91dGVyT3B0aW9ucyA9IHByb3ZpZGVyT3B0aW9ucy5vcGVucm91dGVyIHx8IHt9O1xuICAgIGNvbnN0IGFyZ3MgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5nZXRBcmdzKG9wdGlvbnMpKSwgb3BlbnJvdXRlck9wdGlvbnMpO1xuICAgIGNvbnN0IHsgdmFsdWU6IHJlc3BvbnNlLCByZXNwb25zZUhlYWRlcnMgfSA9IGF3YWl0IHBvc3RKc29uVG9BcGkoe1xuICAgICAgdXJsOiB0aGlzLmNvbmZpZy51cmwoe1xuICAgICAgICBwYXRoOiBcIi9jb21wbGV0aW9uc1wiLFxuICAgICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWRcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogY29tYmluZUhlYWRlcnModGhpcy5jb25maWcuaGVhZGVycygpLCBvcHRpb25zLmhlYWRlcnMpLFxuICAgICAgYm9keTogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYXJncyksIHtcbiAgICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgICAvLyBvbmx5IGluY2x1ZGUgc3RyZWFtX29wdGlvbnMgd2hlbiBpbiBzdHJpY3QgY29tcGF0aWJpbGl0eSBtb2RlOlxuICAgICAgICBzdHJlYW1fb3B0aW9uczogdGhpcy5jb25maWcuY29tcGF0aWJpbGl0eSA9PT0gXCJzdHJpY3RcIiA/IHsgaW5jbHVkZV91c2FnZTogdHJ1ZSB9IDogdm9pZCAwXG4gICAgICB9KSxcbiAgICAgIGZhaWxlZFJlc3BvbnNlSGFuZGxlcjogb3BlbnJvdXRlckZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgICAgIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXI6IGNyZWF0ZUV2ZW50U291cmNlUmVzcG9uc2VIYW5kbGVyKFxuICAgICAgICBPcGVuUm91dGVyQ29tcGxldGlvbkNodW5rU2NoZW1hXG4gICAgICApLFxuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICBmZXRjaDogdGhpcy5jb25maWcuZmV0Y2hcbiAgICB9KTtcbiAgICBsZXQgZmluaXNoUmVhc29uID0gXCJvdGhlclwiO1xuICAgIGNvbnN0IHVzYWdlID0ge1xuICAgICAgaW5wdXRUb2tlbnM6IE51bWJlci5OYU4sXG4gICAgICBvdXRwdXRUb2tlbnM6IE51bWJlci5OYU4sXG4gICAgICB0b3RhbFRva2VuczogTnVtYmVyLk5hTixcbiAgICAgIHJlYXNvbmluZ1Rva2VuczogTnVtYmVyLk5hTixcbiAgICAgIGNhY2hlZElucHV0VG9rZW5zOiBOdW1iZXIuTmFOXG4gICAgfTtcbiAgICBjb25zdCBvcGVucm91dGVyVXNhZ2UgPSB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RyZWFtOiByZXNwb25zZS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICB2YXIgX2ExNSwgX2I7XG4gICAgICAgICAgICBpZiAoIWNodW5rLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yOiBjaHVuay5lcnJvciB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjaHVuay52YWx1ZTtcbiAgICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yOiB2YWx1ZS5lcnJvciB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLnVzYWdlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdXNhZ2UuaW5wdXRUb2tlbnMgPSB2YWx1ZS51c2FnZS5wcm9tcHRfdG9rZW5zO1xuICAgICAgICAgICAgICB1c2FnZS5vdXRwdXRUb2tlbnMgPSB2YWx1ZS51c2FnZS5jb21wbGV0aW9uX3Rva2VucztcbiAgICAgICAgICAgICAgdXNhZ2UudG90YWxUb2tlbnMgPSB2YWx1ZS51c2FnZS5wcm9tcHRfdG9rZW5zICsgdmFsdWUudXNhZ2UuY29tcGxldGlvbl90b2tlbnM7XG4gICAgICAgICAgICAgIG9wZW5yb3V0ZXJVc2FnZS5wcm9tcHRUb2tlbnMgPSB2YWx1ZS51c2FnZS5wcm9tcHRfdG9rZW5zO1xuICAgICAgICAgICAgICBpZiAodmFsdWUudXNhZ2UucHJvbXB0X3Rva2Vuc19kZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkSW5wdXRUb2tlbnMgPSAoX2ExNSA9IHZhbHVlLnVzYWdlLnByb21wdF90b2tlbnNfZGV0YWlscy5jYWNoZWRfdG9rZW5zKSAhPSBudWxsID8gX2ExNSA6IDA7XG4gICAgICAgICAgICAgICAgdXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnMgPSBjYWNoZWRJbnB1dFRva2VucztcbiAgICAgICAgICAgICAgICBvcGVucm91dGVyVXNhZ2UucHJvbXB0VG9rZW5zRGV0YWlscyA9IHtcbiAgICAgICAgICAgICAgICAgIGNhY2hlZFRva2VuczogY2FjaGVkSW5wdXRUb2tlbnNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9wZW5yb3V0ZXJVc2FnZS5jb21wbGV0aW9uVG9rZW5zID0gdmFsdWUudXNhZ2UuY29tcGxldGlvbl90b2tlbnM7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZS51c2FnZS5jb21wbGV0aW9uX3Rva2Vuc19kZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhc29uaW5nVG9rZW5zID0gKF9iID0gdmFsdWUudXNhZ2UuY29tcGxldGlvbl90b2tlbnNfZGV0YWlscy5yZWFzb25pbmdfdG9rZW5zKSAhPSBudWxsID8gX2IgOiAwO1xuICAgICAgICAgICAgICAgIHVzYWdlLnJlYXNvbmluZ1Rva2VucyA9IHJlYXNvbmluZ1Rva2VucztcbiAgICAgICAgICAgICAgICBvcGVucm91dGVyVXNhZ2UuY29tcGxldGlvblRva2Vuc0RldGFpbHMgPSB7XG4gICAgICAgICAgICAgICAgICByZWFzb25pbmdUb2tlbnNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9wZW5yb3V0ZXJVc2FnZS5jb3N0ID0gdmFsdWUudXNhZ2UuY29zdDtcbiAgICAgICAgICAgICAgb3BlbnJvdXRlclVzYWdlLnRvdGFsVG9rZW5zID0gdmFsdWUudXNhZ2UudG90YWxfdG9rZW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hvaWNlID0gdmFsdWUuY2hvaWNlc1swXTtcbiAgICAgICAgICAgIGlmICgoY2hvaWNlID09IG51bGwgPyB2b2lkIDAgOiBjaG9pY2UuZmluaXNoX3JlYXNvbikgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBmaW5pc2hSZWFzb24gPSBtYXBPcGVuUm91dGVyRmluaXNoUmVhc29uKGNob2ljZS5maW5pc2hfcmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoY2hvaWNlID09IG51bGwgPyB2b2lkIDAgOiBjaG9pY2UudGV4dCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgIGRlbHRhOiBjaG9pY2UudGV4dCxcbiAgICAgICAgICAgICAgICBpZDogZ2VuZXJhdGVJZCgpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJmaW5pc2hcIixcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIG9wZW5yb3V0ZXI6IHtcbiAgICAgICAgICAgICAgICAgIHVzYWdlOiBvcGVucm91dGVyVXNhZ2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICByZXNwb25zZToge1xuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnNcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvZmFjYWRlLnRzXG52YXIgT3BlblJvdXRlciA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgT3BlblJvdXRlciBwcm92aWRlciBpbnN0YW5jZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHZhciBfYTE1LCBfYjtcbiAgICB0aGlzLmJhc2VVUkwgPSAoX2IgPSB3aXRob3V0VHJhaWxpbmdTbGFzaCgoX2ExNSA9IG9wdGlvbnMuYmFzZVVSTCkgIT0gbnVsbCA/IF9hMTUgOiBvcHRpb25zLmJhc2VVcmwpKSAhPSBudWxsID8gX2IgOiBcImh0dHBzOi8vb3BlbnJvdXRlci5haS9hcGkvdjFcIjtcbiAgICB0aGlzLmFwaUtleSA9IG9wdGlvbnMuYXBpS2V5O1xuICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycztcbiAgfVxuICBnZXQgYmFzZUNvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmFzZVVSTDogdGhpcy5iYXNlVVJMLFxuICAgICAgaGVhZGVyczogKCkgPT4gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7bG9hZEFwaUtleSh7XG4gICAgICAgICAgYXBpS2V5OiB0aGlzLmFwaUtleSxcbiAgICAgICAgICBlbnZpcm9ubWVudFZhcmlhYmxlTmFtZTogXCJPUEVOUk9VVEVSX0FQSV9LRVlcIixcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJPcGVuUm91dGVyXCJcbiAgICAgICAgfSl9YFxuICAgICAgfSwgdGhpcy5oZWFkZXJzKVxuICAgIH07XG4gIH1cbiAgY2hhdChtb2RlbElkLCBzZXR0aW5ncyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBPcGVuUm91dGVyQ2hhdExhbmd1YWdlTW9kZWwobW9kZWxJZCwgc2V0dGluZ3MsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgcHJvdmlkZXI6IFwib3BlbnJvdXRlci5jaGF0XCJcbiAgICB9LCB0aGlzLmJhc2VDb25maWcpLCB7XG4gICAgICBjb21wYXRpYmlsaXR5OiBcInN0cmljdFwiLFxuICAgICAgdXJsOiAoeyBwYXRoIH0pID0+IGAke3RoaXMuYmFzZVVSTH0ke3BhdGh9YFxuICAgIH0pKTtcbiAgfVxuICBjb21wbGV0aW9uKG1vZGVsSWQsIHNldHRpbmdzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IE9wZW5Sb3V0ZXJDb21wbGV0aW9uTGFuZ3VhZ2VNb2RlbChtb2RlbElkLCBzZXR0aW5ncywgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBwcm92aWRlcjogXCJvcGVucm91dGVyLmNvbXBsZXRpb25cIlxuICAgIH0sIHRoaXMuYmFzZUNvbmZpZyksIHtcbiAgICAgIGNvbXBhdGliaWxpdHk6IFwic3RyaWN0XCIsXG4gICAgICB1cmw6ICh7IHBhdGggfSkgPT4gYCR7dGhpcy5iYXNlVVJMfSR7cGF0aH1gXG4gICAgfSkpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZU9wZW5Sb3V0ZXIob3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYTE1LCBfYiwgX2M7XG4gIGNvbnN0IGJhc2VVUkwgPSAoX2IgPSB3aXRob3V0VHJhaWxpbmdTbGFzaCgoX2ExNSA9IG9wdGlvbnMuYmFzZVVSTCkgIT0gbnVsbCA/IF9hMTUgOiBvcHRpb25zLmJhc2VVcmwpKSAhPSBudWxsID8gX2IgOiBcImh0dHBzOi8vb3BlbnJvdXRlci5haS9hcGkvdjFcIjtcbiAgY29uc3QgY29tcGF0aWJpbGl0eSA9IChfYyA9IG9wdGlvbnMuY29tcGF0aWJpbGl0eSkgIT0gbnVsbCA/IF9jIDogXCJjb21wYXRpYmxlXCI7XG4gIGNvbnN0IGdldEhlYWRlcnMgPSAoKSA9PiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2xvYWRBcGlLZXkoe1xuICAgICAgYXBpS2V5OiBvcHRpb25zLmFwaUtleSxcbiAgICAgIGVudmlyb25tZW50VmFyaWFibGVOYW1lOiBcIk9QRU5ST1VURVJfQVBJX0tFWVwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiT3BlblJvdXRlclwiXG4gICAgfSl9YFxuICB9LCBvcHRpb25zLmhlYWRlcnMpO1xuICBjb25zdCBjcmVhdGVDaGF0TW9kZWwgPSAobW9kZWxJZCwgc2V0dGluZ3MgPSB7fSkgPT4gbmV3IE9wZW5Sb3V0ZXJDaGF0TGFuZ3VhZ2VNb2RlbChtb2RlbElkLCBzZXR0aW5ncywge1xuICAgIHByb3ZpZGVyOiBcIm9wZW5yb3V0ZXIuY2hhdFwiLFxuICAgIHVybDogKHsgcGF0aCB9KSA9PiBgJHtiYXNlVVJMfSR7cGF0aH1gLFxuICAgIGhlYWRlcnM6IGdldEhlYWRlcnMsXG4gICAgY29tcGF0aWJpbGl0eSxcbiAgICBmZXRjaDogb3B0aW9ucy5mZXRjaCxcbiAgICBleHRyYUJvZHk6IG9wdGlvbnMuZXh0cmFCb2R5XG4gIH0pO1xuICBjb25zdCBjcmVhdGVDb21wbGV0aW9uTW9kZWwgPSAobW9kZWxJZCwgc2V0dGluZ3MgPSB7fSkgPT4gbmV3IE9wZW5Sb3V0ZXJDb21wbGV0aW9uTGFuZ3VhZ2VNb2RlbChtb2RlbElkLCBzZXR0aW5ncywge1xuICAgIHByb3ZpZGVyOiBcIm9wZW5yb3V0ZXIuY29tcGxldGlvblwiLFxuICAgIHVybDogKHsgcGF0aCB9KSA9PiBgJHtiYXNlVVJMfSR7cGF0aH1gLFxuICAgIGhlYWRlcnM6IGdldEhlYWRlcnMsXG4gICAgY29tcGF0aWJpbGl0eSxcbiAgICBmZXRjaDogb3B0aW9ucy5mZXRjaCxcbiAgICBleHRyYUJvZHk6IG9wdGlvbnMuZXh0cmFCb2R5XG4gIH0pO1xuICBjb25zdCBjcmVhdGVMYW5ndWFnZU1vZGVsID0gKG1vZGVsSWQsIHNldHRpbmdzKSA9PiB7XG4gICAgaWYgKG5ldy50YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJUaGUgT3BlblJvdXRlciBtb2RlbCBmdW5jdGlvbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBrZXl3b3JkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobW9kZWxJZCA9PT0gXCJvcGVuYWkvZ3B0LTMuNS10dXJiby1pbnN0cnVjdFwiKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ29tcGxldGlvbk1vZGVsKFxuICAgICAgICBtb2RlbElkLFxuICAgICAgICBzZXR0aW5nc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYXRNb2RlbChtb2RlbElkLCBzZXR0aW5ncyk7XG4gIH07XG4gIGNvbnN0IHByb3ZpZGVyID0gKG1vZGVsSWQsIHNldHRpbmdzKSA9PiBjcmVhdGVMYW5ndWFnZU1vZGVsKG1vZGVsSWQsIHNldHRpbmdzKTtcbiAgcHJvdmlkZXIubGFuZ3VhZ2VNb2RlbCA9IGNyZWF0ZUxhbmd1YWdlTW9kZWw7XG4gIHByb3ZpZGVyLmNoYXQgPSBjcmVhdGVDaGF0TW9kZWw7XG4gIHByb3ZpZGVyLmNvbXBsZXRpb24gPSBjcmVhdGVDb21wbGV0aW9uTW9kZWw7XG4gIHJldHVybiBwcm92aWRlcjtcbn1cbnZhciBvcGVucm91dGVyID0gY3JlYXRlT3BlblJvdXRlcih7XG4gIGNvbXBhdGliaWxpdHk6IFwic3RyaWN0XCJcbiAgLy8gc3RyaWN0IGZvciBPcGVuUm91dGVyIEFQSVxufSk7XG5leHBvcnQge1xuICBPcGVuUm91dGVyLFxuICBjcmVhdGVPcGVuUm91dGVyLFxuICBvcGVucm91dGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@openrouter+ai-sdk-provider@1.2.0_ai@5.0.47_zod@3.25.76__zod@3.25.76/node_modules/@openrouter/ai-sdk-provider/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@openrouter+ai-sdk-provider@1.2.0_ai@5.0.47_zod@3.25.76__zod@3.25.76/node_modules/@openrouter/ai-sdk-provider/dist/index.mjs":
/*!*********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@openrouter+ai-sdk-provider@1.2.0_ai@5.0.47_zod@3.25.76__zod@3.25.76/node_modules/@openrouter/ai-sdk-provider/dist/index.mjs ***!
  \*********************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OpenRouter: () => (/* binding */ OpenRouter),\n/* harmony export */   createOpenRouter: () => (/* binding */ createOpenRouter),\n/* harmony export */   openrouter: () => (/* binding */ openrouter)\n/* harmony export */ });\n/* harmony import */ var zod_v4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod/v4 */ \"(ssr)/./node_modules/.pnpm/zod@3.25.76/node_modules/zod/v4/classic/schemas.js\");\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\n// node_modules/.pnpm/@ai-sdk+provider@2.0.0/node_modules/@ai-sdk/provider/dist/index.mjs\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError2 extends Error {\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name: name14,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a] = true;\n    this.name = name14;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error) {\n    return _AISDKError2.hasMarker(error, marker);\n  }\n  static hasMarker(error, marker15) {\n    const markerSymbol = Symbol.for(marker15);\n    return error != null && typeof error === \"object\" && markerSymbol in error && typeof error[markerSymbol] === \"boolean\" && error[markerSymbol] === true;\n  }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar APICallError = class extends AISDKError {\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null && (statusCode === 408 || // request timeout\n    statusCode === 409 || // conflict\n    statusCode === 429 || // too many requests\n    statusCode >= 500),\n    // server error\n    data\n  }) {\n    super({ name, message, cause });\n    this[_a2] = true;\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker2);\n  }\n};\n_a2 = symbol2;\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar EmptyResponseBodyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message = \"Empty response body\" } = {}) {\n    super({ name: name2, message });\n    this[_a3] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker3);\n  }\n};\n_a3 = symbol3;\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\nvar name3 = \"AI_InvalidArgumentError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidArgumentError = class extends AISDKError {\n  constructor({\n    message,\n    cause,\n    argument\n  }) {\n    super({ name: name3, message, cause });\n    this[_a4] = true;\n    this.argument = argument;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker4);\n  }\n};\n_a4 = symbol4;\nvar name4 = \"AI_InvalidPromptError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidPromptError = class extends AISDKError {\n  constructor({\n    prompt,\n    message,\n    cause\n  }) {\n    super({ name: name4, message: `Invalid prompt: ${message}`, cause });\n    this[_a5] = true;\n    this.prompt = prompt;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker5);\n  }\n};\n_a5 = symbol5;\nvar name5 = \"AI_InvalidResponseDataError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar InvalidResponseDataError = class extends AISDKError {\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`\n  }) {\n    super({ name: name5, message });\n    this[_a6] = true;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker6);\n  }\n};\n_a6 = symbol6;\nvar name6 = \"AI_JSONParseError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar JSONParseError = class extends AISDKError {\n  constructor({ text, cause }) {\n    super({\n      name: name6,\n      message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a7] = true;\n    this.text = text;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker7);\n  }\n};\n_a7 = symbol7;\nvar name7 = \"AI_LoadAPIKeyError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar LoadAPIKeyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name7, message });\n    this[_a8] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker8);\n  }\n};\n_a8 = symbol8;\nvar name8 = \"AI_LoadSettingError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\n_a9 = symbol9;\nvar name9 = \"AI_NoContentGeneratedError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\n_a10 = symbol10;\nvar name10 = \"AI_NoSuchModelError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\n_a11 = symbol11;\nvar name11 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\n_a12 = symbol12;\nvar name12 = \"AI_TypeValidationError\";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar _TypeValidationError = class _TypeValidationError2 extends AISDKError {\n  constructor({ value, cause }) {\n    super({\n      name: name12,\n      message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a13] = true;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker13);\n  }\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause\n  }) {\n    return _TypeValidationError2.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError2({ value, cause });\n  }\n};\n_a13 = symbol13;\nvar TypeValidationError = _TypeValidationError;\nvar name13 = \"AI_UnsupportedFunctionalityError\";\nvar marker14 = `vercel.ai.error.${name13}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar UnsupportedFunctionalityError = class extends AISDKError {\n  constructor({\n    functionality,\n    message = `'${functionality}' functionality not supported.`\n  }) {\n    super({ name: name13, message });\n    this[_a14] = true;\n    this.functionality = functionality;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker14);\n  }\n};\n_a14 = symbol14;\n\n// node_modules/.pnpm/eventsource-parser@3.0.3/node_modules/eventsource-parser/dist/index.js\nvar ParseError = class extends Error {\n  constructor(message, options) {\n    super(message), this.name = \"ParseError\", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;\n  }\n};\nfunction noop(_arg) {\n}\nfunction createParser(callbacks) {\n  if (typeof callbacks == \"function\")\n    throw new TypeError(\n      \"`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?\"\n    );\n  const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;\n  let incompleteLine = \"\", isFirstChunk = true, id, data = \"\", eventType = \"\";\n  function feed(newChunk) {\n    const chunk = isFirstChunk ? newChunk.replace(/^\\xEF\\xBB\\xBF/, \"\") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);\n    for (const line of complete)\n      parseLine(line);\n    incompleteLine = incomplete, isFirstChunk = false;\n  }\n  function parseLine(line) {\n    if (line === \"\") {\n      dispatchEvent();\n      return;\n    }\n    if (line.startsWith(\":\")) {\n      onComment && onComment(line.slice(line.startsWith(\": \") ? 2 : 1));\n      return;\n    }\n    const fieldSeparatorIndex = line.indexOf(\":\");\n    if (fieldSeparatorIndex !== -1) {\n      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === \" \" ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);\n      processField(field, value, line);\n      return;\n    }\n    processField(line, \"\", line);\n  }\n  function processField(field, value, line) {\n    switch (field) {\n      case \"event\":\n        eventType = value;\n        break;\n      case \"data\":\n        data = `${data}${value}\n`;\n        break;\n      case \"id\":\n        id = value.includes(\"\\0\") ? void 0 : value;\n        break;\n      case \"retry\":\n        /^\\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(\n          new ParseError(`Invalid \\`retry\\` value: \"${value}\"`, {\n            type: \"invalid-retry\",\n            value,\n            line\n          })\n        );\n        break;\n      default:\n        onError(\n          new ParseError(\n            `Unknown field \"${field.length > 20 ? `${field.slice(0, 20)}\\u2026` : field}\"`,\n            { type: \"unknown-field\", field, value, line }\n          )\n        );\n        break;\n    }\n  }\n  function dispatchEvent() {\n    data.length > 0 && onEvent({\n      id,\n      event: eventType || void 0,\n      // If the data buffer's last character is a U+000A LINE FEED (LF) character,\n      // then remove the last character from the data buffer.\n      data: data.endsWith(`\n`) ? data.slice(0, -1) : data\n    }), id = void 0, data = \"\", eventType = \"\";\n  }\n  function reset(options = {}) {\n    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = \"\", eventType = \"\", incompleteLine = \"\";\n  }\n  return { feed, reset };\n}\nfunction splitLines(chunk) {\n  const lines = [];\n  let incompleteLine = \"\", searchIndex = 0;\n  for (; searchIndex < chunk.length; ) {\n    const crIndex = chunk.indexOf(\"\\r\", searchIndex), lfIndex = chunk.indexOf(`\n`, searchIndex);\n    let lineEnd = -1;\n    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {\n      incompleteLine = chunk.slice(searchIndex);\n      break;\n    } else {\n      const line = chunk.slice(searchIndex, lineEnd);\n      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === \"\\r\" && chunk[searchIndex] === `\n` && searchIndex++;\n    }\n  }\n  return [lines, incompleteLine];\n}\n\n// node_modules/.pnpm/eventsource-parser@3.0.3/node_modules/eventsource-parser/dist/stream.js\nvar EventSourceParserStream = class extends TransformStream {\n  constructor({ onError, onRetry, onComment } = {}) {\n    let parser;\n    super({\n      start(controller) {\n        parser = createParser({\n          onEvent: (event) => {\n            controller.enqueue(event);\n          },\n          onError(error) {\n            onError === \"terminate\" ? controller.error(error) : typeof onError == \"function\" && onError(error);\n          },\n          onRetry,\n          onComment\n        });\n      },\n      transform(chunk) {\n        parser.feed(chunk);\n      }\n    });\n  }\n};\n\n// node_modules/.pnpm/@ai-sdk+provider-utils@3.0.1_zod@3.25.76/node_modules/@ai-sdk/provider-utils/dist/index.mjs\n\n\n// node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/Options.js\nvar ignoreOverride = Symbol(\"Let zodToJsonSchema decide on which parser to use\");\n\n// node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/selectParser.js\n\n\n// node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/array.js\n\n\n// node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/record.js\n\n\n// node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/string.js\nvar ALPHA_NUMERIC = new Set(\"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\");\n\n// node_modules/.pnpm/@ai-sdk+provider-utils@3.0.1_zod@3.25.76/node_modules/@ai-sdk/provider-utils/dist/index.mjs\nfunction combineHeaders(...headers) {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => __spreadValues(__spreadValues({}, combinedHeaders), currentHeaders != null ? currentHeaders : {}),\n    {}\n  );\n}\nfunction extractResponseHeaders(response) {\n  return Object.fromEntries([...response.headers]);\n}\nvar createIdGenerator = ({\n  prefix,\n  size = 16,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  separator = \"-\"\n} = {}) => {\n  const generator = () => {\n    const alphabetLength = alphabet.length;\n    const chars = new Array(size);\n    for (let i = 0; i < size; i++) {\n      chars[i] = alphabet[Math.random() * alphabetLength | 0];\n    }\n    return chars.join(\"\");\n  };\n  if (prefix == null) {\n    return generator;\n  }\n  if (alphabet.includes(separator)) {\n    throw new InvalidArgumentError({\n      argument: \"separator\",\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`\n    });\n  }\n  return () => `${prefix}${separator}${generator()}`;\n};\nvar generateId = createIdGenerator();\nfunction isAbortError(error) {\n  return (error instanceof Error || error instanceof DOMException) && (error.name === \"AbortError\" || error.name === \"ResponseAborted\" || // Next.js\n  error.name === \"TimeoutError\");\n}\nvar FETCH_FAILED_ERROR_MESSAGES = [\"fetch failed\", \"failed to fetch\"];\nfunction handleFetchError({\n  error,\n  url,\n  requestBodyValues\n}) {\n  if (isAbortError(error)) {\n    return error;\n  }\n  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())) {\n    const cause = error.cause;\n    if (cause != null) {\n      return new APICallError({\n        message: `Cannot connect to API: ${cause.message}`,\n        cause,\n        url,\n        requestBodyValues,\n        isRetryable: true\n        // retry when network error\n      });\n    }\n  }\n  return error;\n}\nfunction removeUndefinedEntries(record) {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null)\n  );\n}\nfunction loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description\n}) {\n  if (typeof apiKey === \"string\") {\n    return apiKey;\n  }\n  if (apiKey != null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  apiKey = process.env[environmentVariableName];\n  if (apiKey == null) {\n    throw new LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof apiKey !== \"string\") {\n    throw new LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return apiKey;\n}\nvar suspectProtoRx = /\"__proto__\"\\s*:/;\nvar suspectConstructorRx = /\"constructor\"\\s*:/;\nfunction _parse(text) {\n  const obj = JSON.parse(text);\n  if (obj === null || typeof obj !== \"object\") {\n    return obj;\n  }\n  if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n    return obj;\n  }\n  return filter(obj);\n}\nfunction filter(obj) {\n  let next = [obj];\n  while (next.length) {\n    const nodes = next;\n    next = [];\n    for (const node of nodes) {\n      if (Object.prototype.hasOwnProperty.call(node, \"__proto__\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      if (Object.prototype.hasOwnProperty.call(node, \"constructor\") && Object.prototype.hasOwnProperty.call(node.constructor, \"prototype\")) {\n        throw new SyntaxError(\"Object contains forbidden prototype property\");\n      }\n      for (const key in node) {\n        const value = node[key];\n        if (value && typeof value === \"object\") {\n          next.push(value);\n        }\n      }\n    }\n  }\n  return obj;\n}\nfunction secureJsonParse(text) {\n  const { stackTraceLimit } = Error;\n  Error.stackTraceLimit = 0;\n  try {\n    return _parse(text);\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit;\n  }\n}\nvar validatorSymbol = Symbol.for(\"vercel.ai.validator\");\nfunction validator(validate) {\n  return { [validatorSymbol]: true, validate };\n}\nfunction isValidator(value) {\n  return typeof value === \"object\" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && \"validate\" in value;\n}\nfunction asValidator(value) {\n  return isValidator(value) ? value : standardSchemaValidator(value);\n}\nfunction standardSchemaValidator(standardSchema) {\n  return validator(async (value) => {\n    const result = await standardSchema[\"~standard\"].validate(value);\n    return result.issues == null ? { success: true, value: result.value } : {\n      success: false,\n      error: new TypeValidationError({\n        value,\n        cause: result.issues\n      })\n    };\n  });\n}\nasync function validateTypes({\n  value,\n  schema\n}) {\n  const result = await safeValidateTypes({ value, schema });\n  if (!result.success) {\n    throw TypeValidationError.wrap({ value, cause: result.error });\n  }\n  return result.value;\n}\nasync function safeValidateTypes({\n  value,\n  schema\n}) {\n  const validator2 = asValidator(schema);\n  try {\n    if (validator2.validate == null) {\n      return { success: true, value, rawValue: value };\n    }\n    const result = await validator2.validate(value);\n    if (result.success) {\n      return { success: true, value: result.value, rawValue: value };\n    }\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: result.error }),\n      rawValue: value\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: TypeValidationError.wrap({ value, cause: error }),\n      rawValue: value\n    };\n  }\n}\nasync function parseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secureJsonParse(text);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (JSONParseError.isInstance(error) || TypeValidationError.isInstance(error)) {\n      throw error;\n    }\n    throw new JSONParseError({ text, cause: error });\n  }\n}\nasync function safeParseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secureJsonParse(text);\n    if (schema == null) {\n      return { success: true, value, rawValue: value };\n    }\n    return await safeValidateTypes({ value, schema });\n  } catch (error) {\n    return {\n      success: false,\n      error: JSONParseError.isInstance(error) ? error : new JSONParseError({ text, cause: error }),\n      rawValue: void 0\n    };\n  }\n}\nfunction isParsableJson(input) {\n  try {\n    secureJsonParse(input);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction parseJsonEventStream({\n  stream,\n  schema\n}) {\n  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(\n    new TransformStream({\n      async transform({ data }, controller) {\n        if (data === \"[DONE]\") {\n          return;\n        }\n        controller.enqueue(await safeParseJSON({ text: data, schema }));\n      }\n    })\n  );\n}\nvar getOriginalFetch2 = () => globalThis.fetch;\nvar postJsonToApi = async ({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers: __spreadValues({\n    \"Content-Type\": \"application/json\"\n  }, headers),\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postToApi = async ({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch2()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values\n        });\n      } catch (error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n        throw new APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || APICallError.isInstance(error)) {\n          throw error;\n        }\n      }\n      throw new APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error) {\n    throw handleFetchError({ error, url, requestBodyValues: body.values });\n  }\n};\nvar createJsonErrorResponseHandler = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = await parseJSON({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: errorToMessage(parsedError),\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new EmptyResponseBodyError({});\n  }\n  return {\n    responseHeaders,\n    value: parseJsonEventStream({\n      stream: response.body,\n      schema: chunkSchema\n    })\n  };\n};\nvar createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const parsedResult = await safeParseJSON({\n    text: responseBody,\n    schema: responseSchema\n  });\n  const responseHeaders = extractResponseHeaders(response);\n  if (!parsedResult.success) {\n    throw new APICallError({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value,\n    rawValue: parsedResult.rawValue\n  };\n};\nvar schemaSymbol = Symbol.for(\"vercel.ai.schema\");\nvar { btoa, atob } = globalThis;\nfunction convertUint8ArrayToBase64(array) {\n  let latin1string = \"\";\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n  return btoa(latin1string);\n}\nfunction withoutTrailingSlash(url) {\n  return url == null ? void 0 : url.replace(/\\/$/, \"\");\n}\n\n// src/schemas/reasoning-details.ts\n\nvar ReasoningDetailSummarySchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"reasoning.summary\" /* Summary */),\n  summary: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string()\n});\nvar ReasoningDetailEncryptedSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"reasoning.encrypted\" /* Encrypted */),\n  data: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string()\n});\nvar ReasoningDetailTextSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"reasoning.text\" /* Text */),\n  text: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish(),\n  signature: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish()\n});\nvar ReasoningDetailUnionSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.union([\n  ReasoningDetailSummarySchema,\n  ReasoningDetailEncryptedSchema,\n  ReasoningDetailTextSchema\n]);\nvar ReasoningDetailsWithUnknownSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.union([\n  ReasoningDetailUnionSchema,\n  zod_v4__WEBPACK_IMPORTED_MODULE_0__.unknown().transform(() => null)\n]);\nvar ReasoningDetailArraySchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(ReasoningDetailsWithUnknownSchema).transform((d) => d.filter((d2) => !!d2));\n\n// src/schemas/error-response.ts\n\nvar OpenRouterErrorResponseSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n  error: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n    code: zod_v4__WEBPACK_IMPORTED_MODULE_0__.union([zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()]).nullable().optional().default(null),\n    message: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullable().optional().default(null),\n    param: zod_v4__WEBPACK_IMPORTED_MODULE_0__.any().nullable().optional().default(null)\n  })\n});\nvar openrouterFailedResponseHandler = createJsonErrorResponseHandler({\n  errorSchema: OpenRouterErrorResponseSchema,\n  errorToMessage: (data) => data.error.message\n});\n\n// src/utils/map-finish-reason.ts\nfunction mapOpenRouterFinishReason(finishReason) {\n  switch (finishReason) {\n    case \"stop\":\n      return \"stop\";\n    case \"length\":\n      return \"length\";\n    case \"content_filter\":\n      return \"content-filter\";\n    case \"function_call\":\n    case \"tool_calls\":\n      return \"tool-calls\";\n    default:\n      return \"unknown\";\n  }\n}\n\n// src/chat/is-url.ts\nfunction isUrl({\n  url,\n  protocols\n}) {\n  try {\n    const urlObj = new URL(url);\n    return protocols.has(urlObj.protocol);\n  } catch (_) {\n    return false;\n  }\n}\n\n// src/chat/file-url-utils.ts\nfunction getFileUrl({\n  part,\n  defaultMediaType\n}) {\n  var _a15, _b;\n  if (part.data instanceof Uint8Array) {\n    const base64 = convertUint8ArrayToBase64(part.data);\n    return `data:${(_a15 = part.mediaType) != null ? _a15 : defaultMediaType};base64,${base64}`;\n  }\n  const stringUrl = part.data.toString();\n  if (isUrl({\n    url: stringUrl,\n    protocols: /* @__PURE__ */ new Set([\"http:\", \"https:\"])\n  })) {\n    return stringUrl;\n  }\n  return stringUrl.startsWith(\"data:\") ? stringUrl : `data:${(_b = part.mediaType) != null ? _b : defaultMediaType};base64,${stringUrl}`;\n}\nfunction getMediaType(dataUrl, defaultMediaType) {\n  var _a15;\n  const match = dataUrl.match(/^data:([^;]+)/);\n  return match ? (_a15 = match[1]) != null ? _a15 : defaultMediaType : defaultMediaType;\n}\nfunction getBase64FromDataUrl(dataUrl) {\n  const match = dataUrl.match(/^data:[^;]*;base64,(.+)$/);\n  return match ? match[1] : dataUrl;\n}\n\n// src/chat/convert-to-openrouter-chat-messages.ts\nfunction getCacheControl(providerMetadata) {\n  var _a15, _b, _c;\n  const anthropic = providerMetadata == null ? void 0 : providerMetadata.anthropic;\n  const openrouter2 = providerMetadata == null ? void 0 : providerMetadata.openrouter;\n  return (_c = (_b = (_a15 = openrouter2 == null ? void 0 : openrouter2.cacheControl) != null ? _a15 : openrouter2 == null ? void 0 : openrouter2.cache_control) != null ? _b : anthropic == null ? void 0 : anthropic.cacheControl) != null ? _c : anthropic == null ? void 0 : anthropic.cache_control;\n}\nfunction convertToOpenRouterChatMessages(prompt) {\n  var _a15, _b, _c;\n  const messages = [];\n  for (const { role, content, providerOptions } of prompt) {\n    switch (role) {\n      case \"system\": {\n        messages.push({\n          role: \"system\",\n          content,\n          cache_control: getCacheControl(providerOptions)\n        });\n        break;\n      }\n      case \"user\": {\n        if (content.length === 1 && ((_a15 = content[0]) == null ? void 0 : _a15.type) === \"text\") {\n          const cacheControl = (_b = getCacheControl(providerOptions)) != null ? _b : getCacheControl(content[0].providerOptions);\n          const contentWithCacheControl = cacheControl ? [\n            {\n              type: \"text\",\n              text: content[0].text,\n              cache_control: cacheControl\n            }\n          ] : content[0].text;\n          messages.push({\n            role: \"user\",\n            content: contentWithCacheControl\n          });\n          break;\n        }\n        const messageCacheControl = getCacheControl(providerOptions);\n        const contentParts = content.map(\n          (part) => {\n            var _a16, _b2, _c2, _d, _e, _f;\n            const cacheControl = (_a16 = getCacheControl(part.providerOptions)) != null ? _a16 : messageCacheControl;\n            switch (part.type) {\n              case \"text\":\n                return {\n                  type: \"text\",\n                  text: part.text,\n                  // For text parts, only use part-specific cache control\n                  cache_control: cacheControl\n                };\n              case \"file\": {\n                if ((_b2 = part.mediaType) == null ? void 0 : _b2.startsWith(\"image/\")) {\n                  const url = getFileUrl({\n                    part,\n                    defaultMediaType: \"image/jpeg\"\n                  });\n                  return {\n                    type: \"image_url\",\n                    image_url: {\n                      url\n                    },\n                    // For image parts, use part-specific or message-level cache control\n                    cache_control: cacheControl\n                  };\n                }\n                const fileName = String(\n                  (_f = (_e = (_d = (_c2 = part.providerOptions) == null ? void 0 : _c2.openrouter) == null ? void 0 : _d.filename) != null ? _e : part.filename) != null ? _f : \"\"\n                );\n                const fileData = getFileUrl({\n                  part,\n                  defaultMediaType: \"application/pdf\"\n                });\n                if (isUrl({\n                  url: fileData,\n                  protocols: /* @__PURE__ */ new Set([\"http:\", \"https:\"])\n                })) {\n                  return {\n                    type: \"file\",\n                    file: {\n                      filename: fileName,\n                      file_data: fileData\n                    }\n                  };\n                }\n                return {\n                  type: \"file\",\n                  file: {\n                    filename: fileName,\n                    file_data: fileData\n                  },\n                  cache_control: cacheControl\n                };\n              }\n              default: {\n                return {\n                  type: \"text\",\n                  text: \"\",\n                  cache_control: cacheControl\n                };\n              }\n            }\n          }\n        );\n        messages.push({\n          role: \"user\",\n          content: contentParts\n        });\n        break;\n      }\n      case \"assistant\": {\n        let text = \"\";\n        let reasoning = \"\";\n        const reasoningDetails = [];\n        const toolCalls = [];\n        for (const part of content) {\n          switch (part.type) {\n            case \"text\": {\n              text += part.text;\n              break;\n            }\n            case \"tool-call\": {\n              toolCalls.push({\n                id: part.toolCallId,\n                type: \"function\",\n                function: {\n                  name: part.toolName,\n                  arguments: JSON.stringify(part.input)\n                }\n              });\n              break;\n            }\n            case \"reasoning\": {\n              reasoning += part.text;\n              reasoningDetails.push({\n                type: \"reasoning.text\" /* Text */,\n                text: part.text\n              });\n              break;\n            }\n            case \"file\":\n              break;\n            default: {\n              break;\n            }\n          }\n        }\n        messages.push({\n          role: \"assistant\",\n          content: text,\n          tool_calls: toolCalls.length > 0 ? toolCalls : void 0,\n          reasoning: reasoning || void 0,\n          reasoning_details: reasoningDetails.length > 0 ? reasoningDetails : void 0,\n          cache_control: getCacheControl(providerOptions)\n        });\n        break;\n      }\n      case \"tool\": {\n        for (const toolResponse of content) {\n          const content2 = getToolResultContent(toolResponse);\n          messages.push({\n            role: \"tool\",\n            tool_call_id: toolResponse.toolCallId,\n            content: content2,\n            cache_control: (_c = getCacheControl(providerOptions)) != null ? _c : getCacheControl(toolResponse.providerOptions)\n          });\n        }\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n  }\n  return messages;\n}\nfunction getToolResultContent(input) {\n  return input.output.type === \"text\" ? input.output.value : JSON.stringify(input.output.value);\n}\n\n// src/chat/get-tool-choice.ts\n\nvar ChatCompletionToolChoiceSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.union([\n  zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"auto\"),\n  zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"none\"),\n  zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"required\"),\n  zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n    type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"function\"),\n    function: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n      name: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string()\n    })\n  })\n]);\nfunction getChatCompletionToolChoice(toolChoice) {\n  switch (toolChoice.type) {\n    case \"auto\":\n    case \"none\":\n    case \"required\":\n      return toolChoice.type;\n    case \"tool\": {\n      return {\n        type: \"function\",\n        function: { name: toolChoice.toolName }\n      };\n    }\n    default: {\n      toolChoice;\n      throw new Error(`Invalid tool choice type: ${toolChoice}`);\n    }\n  }\n}\n\n// src/chat/schemas.ts\n\n\n// src/schemas/image.ts\n\nvar ImageResponseSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"image_url\"),\n  image_url: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n    url: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string()\n  })\n});\nvar ImageResponseWithUnknownSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.union([\n  ImageResponseSchema,\n  zod_v4__WEBPACK_IMPORTED_MODULE_0__.unknown().transform(() => null)\n]);\nvar ImageResponseArraySchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(ImageResponseWithUnknownSchema).transform((d) => d.filter((d2) => !!d2));\n\n// src/chat/schemas.ts\nvar OpenRouterChatCompletionBaseResponseSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n  id: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n  model: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n  provider: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n  usage: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n    prompt_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n    prompt_tokens_details: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n      cached_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()\n    }).nullish(),\n    completion_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n    completion_tokens_details: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n      reasoning_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()\n    }).nullish(),\n    total_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n    cost: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().optional(),\n    cost_details: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n      upstream_inference_cost: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().nullish()\n    }).nullish()\n  }).nullish()\n});\nvar OpenRouterNonStreamChatCompletionResponseSchema = OpenRouterChatCompletionBaseResponseSchema.extend({\n  choices: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n    zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n      message: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n        role: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"assistant\"),\n        content: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullable().optional(),\n        reasoning: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullable().optional(),\n        reasoning_details: ReasoningDetailArraySchema.nullish(),\n        images: ImageResponseArraySchema.nullish(),\n        tool_calls: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n          zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n            id: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional().nullable(),\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"function\"),\n            function: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n              name: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n              arguments: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string()\n            })\n          })\n        ).optional(),\n        annotations: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n          zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\"url_citation\"]),\n            url_citation: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n              end_index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n              start_index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n              title: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n              url: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n              content: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional()\n            })\n          })\n        ).nullish()\n      }),\n      index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().nullish(),\n      logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n        content: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n          zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n            token: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n            logprob: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n            top_logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n              zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n                token: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n                logprob: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()\n              })\n            )\n          })\n        ).nullable()\n      }).nullable().optional(),\n      finish_reason: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional().nullable()\n    })\n  )\n});\nvar OpenRouterStreamChatCompletionChunkSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.union([\n  OpenRouterChatCompletionBaseResponseSchema.extend({\n    choices: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n      zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n        delta: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n          role: zod_v4__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\"assistant\"]).optional(),\n          content: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish(),\n          reasoning: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish().optional(),\n          reasoning_details: ReasoningDetailArraySchema.nullish(),\n          images: ImageResponseArraySchema.nullish(),\n          tool_calls: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n            zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n              index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().nullish(),\n              id: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish(),\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_0__.literal(\"function\").optional(),\n              function: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n                name: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish(),\n                arguments: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish()\n              })\n            })\n          ).nullish(),\n          annotations: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n            zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_0__[\"enum\"]([\"url_citation\"]),\n              url_citation: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n                end_index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n                start_index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n                title: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n                url: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n                content: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional()\n              })\n            })\n          ).nullish()\n        }).nullish(),\n        logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n          content: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n            zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n              token: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n              logprob: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n              top_logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n                zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n                  token: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n                  logprob: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()\n                })\n              )\n            })\n          ).nullable()\n        }).nullish(),\n        finish_reason: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullable().optional(),\n        index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().nullish()\n      })\n    )\n  }),\n  OpenRouterErrorResponseSchema\n]);\n\n// src/chat/index.ts\nvar OpenRouterChatLanguageModel = class {\n  constructor(modelId, settings, config) {\n    this.specificationVersion = \"v2\";\n    this.provider = \"openrouter\";\n    this.defaultObjectGenerationMode = \"tool\";\n    this.supportedUrls = {\n      \"image/*\": [\n        /^data:image\\/[a-zA-Z]+;base64,/,\n        /^https?:\\/\\/.+\\.(jpg|jpeg|png|gif|webp)$/i\n      ],\n      // 'text/*': [/^data:text\\//, /^https?:\\/\\/.+$/],\n      \"application/*\": [/^data:application\\//, /^https?:\\/\\/.+$/]\n    };\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n  getArgs({\n    prompt,\n    maxOutputTokens,\n    temperature,\n    topP,\n    frequencyPenalty,\n    presencePenalty,\n    seed,\n    stopSequences,\n    responseFormat,\n    topK,\n    tools,\n    toolChoice\n  }) {\n    var _a15;\n    const baseArgs = __spreadValues(__spreadValues({\n      // model id:\n      model: this.modelId,\n      models: this.settings.models,\n      // model specific settings:\n      logit_bias: this.settings.logitBias,\n      logprobs: this.settings.logprobs === true || typeof this.settings.logprobs === \"number\" ? true : void 0,\n      top_logprobs: typeof this.settings.logprobs === \"number\" ? this.settings.logprobs : typeof this.settings.logprobs === \"boolean\" ? this.settings.logprobs ? 0 : void 0 : void 0,\n      user: this.settings.user,\n      parallel_tool_calls: this.settings.parallelToolCalls,\n      // standardized settings:\n      max_tokens: maxOutputTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      seed,\n      stop: stopSequences,\n      response_format: responseFormat,\n      top_k: topK,\n      // messages:\n      messages: convertToOpenRouterChatMessages(prompt),\n      // OpenRouter specific settings:\n      include_reasoning: this.settings.includeReasoning,\n      reasoning: this.settings.reasoning,\n      usage: this.settings.usage,\n      // Web search settings:\n      plugins: this.settings.plugins,\n      web_search_options: this.settings.web_search_options,\n      // Provider routing settings:\n      provider: this.settings.provider\n    }, this.config.extraBody), this.settings.extraBody);\n    if ((responseFormat == null ? void 0 : responseFormat.type) === \"json\" && responseFormat.schema != null) {\n      return __spreadProps(__spreadValues({}, baseArgs), {\n        response_format: {\n          type: \"json_schema\",\n          json_schema: __spreadValues({\n            schema: responseFormat.schema,\n            strict: true,\n            name: (_a15 = responseFormat.name) != null ? _a15 : \"response\"\n          }, responseFormat.description && {\n            description: responseFormat.description\n          })\n        }\n      });\n    }\n    if (tools && tools.length > 0) {\n      const mappedTools = tools.filter((tool) => tool.type === \"function\").map((tool) => ({\n        type: \"function\",\n        function: {\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.inputSchema\n        }\n      }));\n      return __spreadProps(__spreadValues({}, baseArgs), {\n        tools: mappedTools,\n        tool_choice: toolChoice ? getChatCompletionToolChoice(toolChoice) : void 0\n      });\n    }\n    return baseArgs;\n  }\n  async doGenerate(options) {\n    var _a15, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;\n    const providerOptions = options.providerOptions || {};\n    const openrouterOptions = providerOptions.openrouter || {};\n    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: \"/chat/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: openrouterFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        OpenRouterNonStreamChatCompletionResponseSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const choice = response.choices[0];\n    if (!choice) {\n      throw new Error(\"No choice in response\");\n    }\n    const usageInfo = response.usage ? {\n      inputTokens: (_a15 = response.usage.prompt_tokens) != null ? _a15 : 0,\n      outputTokens: (_b = response.usage.completion_tokens) != null ? _b : 0,\n      totalTokens: ((_c = response.usage.prompt_tokens) != null ? _c : 0) + ((_d = response.usage.completion_tokens) != null ? _d : 0),\n      reasoningTokens: (_f = (_e = response.usage.completion_tokens_details) == null ? void 0 : _e.reasoning_tokens) != null ? _f : 0,\n      cachedInputTokens: (_h = (_g = response.usage.prompt_tokens_details) == null ? void 0 : _g.cached_tokens) != null ? _h : 0\n    } : {\n      inputTokens: 0,\n      outputTokens: 0,\n      totalTokens: 0,\n      reasoningTokens: 0,\n      cachedInputTokens: 0\n    };\n    const reasoningDetails = (_i = choice.message.reasoning_details) != null ? _i : [];\n    const reasoning = reasoningDetails.length > 0 ? reasoningDetails.map((detail) => {\n      switch (detail.type) {\n        case \"reasoning.text\" /* Text */: {\n          if (detail.text) {\n            return {\n              type: \"reasoning\",\n              text: detail.text\n            };\n          }\n          break;\n        }\n        case \"reasoning.summary\" /* Summary */: {\n          if (detail.summary) {\n            return {\n              type: \"reasoning\",\n              text: detail.summary\n            };\n          }\n          break;\n        }\n        case \"reasoning.encrypted\" /* Encrypted */: {\n          if (detail.data) {\n            return {\n              type: \"reasoning\",\n              text: \"[REDACTED]\"\n            };\n          }\n          break;\n        }\n        default: {\n          detail;\n        }\n      }\n      return null;\n    }).filter((p) => p !== null) : choice.message.reasoning ? [\n      {\n        type: \"reasoning\",\n        text: choice.message.reasoning\n      }\n    ] : [];\n    const content = [];\n    content.push(...reasoning);\n    if (choice.message.content) {\n      content.push({\n        type: \"text\",\n        text: choice.message.content\n      });\n    }\n    if (choice.message.tool_calls) {\n      for (const toolCall of choice.message.tool_calls) {\n        content.push({\n          type: \"tool-call\",\n          toolCallId: (_j = toolCall.id) != null ? _j : generateId(),\n          toolName: toolCall.function.name,\n          input: toolCall.function.arguments\n        });\n      }\n    }\n    if (choice.message.images) {\n      for (const image of choice.message.images) {\n        content.push({\n          type: \"file\",\n          mediaType: getMediaType(image.image_url.url, \"image/jpeg\"),\n          data: getBase64FromDataUrl(image.image_url.url)\n        });\n      }\n    }\n    if (choice.message.annotations) {\n      for (const annotation of choice.message.annotations) {\n        if (annotation.type === \"url_citation\") {\n          content.push({\n            type: \"source\",\n            sourceType: \"url\",\n            id: annotation.url_citation.url,\n            url: annotation.url_citation.url,\n            title: annotation.url_citation.title,\n            providerMetadata: {\n              openrouter: {\n                content: annotation.url_citation.content || \"\"\n              }\n            }\n          });\n        }\n      }\n    }\n    return {\n      content,\n      finishReason: mapOpenRouterFinishReason(choice.finish_reason),\n      usage: usageInfo,\n      warnings: [],\n      providerMetadata: {\n        openrouter: {\n          provider: (_k = response.provider) != null ? _k : \"\",\n          usage: {\n            promptTokens: (_l = usageInfo.inputTokens) != null ? _l : 0,\n            completionTokens: (_m = usageInfo.outputTokens) != null ? _m : 0,\n            totalTokens: (_n = usageInfo.totalTokens) != null ? _n : 0,\n            cost: (_o = response.usage) == null ? void 0 : _o.cost,\n            promptTokensDetails: {\n              cachedTokens: (_r = (_q = (_p = response.usage) == null ? void 0 : _p.prompt_tokens_details) == null ? void 0 : _q.cached_tokens) != null ? _r : 0\n            },\n            completionTokensDetails: {\n              reasoningTokens: (_u = (_t = (_s = response.usage) == null ? void 0 : _s.completion_tokens_details) == null ? void 0 : _t.reasoning_tokens) != null ? _u : 0\n            },\n            costDetails: {\n              upstreamInferenceCost: (_x = (_w = (_v = response.usage) == null ? void 0 : _v.cost_details) == null ? void 0 : _w.upstream_inference_cost) != null ? _x : 0\n            }\n          }\n        }\n      },\n      request: { body: args },\n      response: {\n        id: response.id,\n        modelId: response.model,\n        headers: responseHeaders\n      }\n    };\n  }\n  async doStream(options) {\n    var _a15;\n    const providerOptions = options.providerOptions || {};\n    const openrouterOptions = providerOptions.openrouter || {};\n    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: \"/chat/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: __spreadProps(__spreadValues({}, args), {\n        stream: true,\n        // only include stream_options when in strict compatibility mode:\n        stream_options: this.config.compatibility === \"strict\" ? __spreadValues({\n          include_usage: true\n        }, ((_a15 = this.settings.usage) == null ? void 0 : _a15.include) ? { include_usage: true } : {}) : void 0\n      }),\n      failedResponseHandler: openrouterFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        OpenRouterStreamChatCompletionChunkSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    const toolCalls = [];\n    let finishReason = \"other\";\n    const usage = {\n      inputTokens: Number.NaN,\n      outputTokens: Number.NaN,\n      totalTokens: Number.NaN,\n      reasoningTokens: Number.NaN,\n      cachedInputTokens: Number.NaN\n    };\n    const openrouterUsage = {};\n    let textStarted = false;\n    let reasoningStarted = false;\n    let textId;\n    let reasoningId;\n    let openrouterResponseId;\n    let provider;\n    return {\n      stream: response.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            var _a16, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;\n            if (!chunk.success) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: chunk.error });\n              return;\n            }\n            const value = chunk.value;\n            if (\"error\" in value) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: value.error });\n              return;\n            }\n            if (value.provider) {\n              provider = value.provider;\n            }\n            if (value.id) {\n              openrouterResponseId = value.id;\n              controller.enqueue({\n                type: \"response-metadata\",\n                id: value.id\n              });\n            }\n            if (value.model) {\n              controller.enqueue({\n                type: \"response-metadata\",\n                modelId: value.model\n              });\n            }\n            if (value.usage != null) {\n              usage.inputTokens = value.usage.prompt_tokens;\n              usage.outputTokens = value.usage.completion_tokens;\n              usage.totalTokens = value.usage.prompt_tokens + value.usage.completion_tokens;\n              openrouterUsage.promptTokens = value.usage.prompt_tokens;\n              if (value.usage.prompt_tokens_details) {\n                const cachedInputTokens = (_a16 = value.usage.prompt_tokens_details.cached_tokens) != null ? _a16 : 0;\n                usage.cachedInputTokens = cachedInputTokens;\n                openrouterUsage.promptTokensDetails = {\n                  cachedTokens: cachedInputTokens\n                };\n              }\n              openrouterUsage.completionTokens = value.usage.completion_tokens;\n              if (value.usage.completion_tokens_details) {\n                const reasoningTokens = (_b = value.usage.completion_tokens_details.reasoning_tokens) != null ? _b : 0;\n                usage.reasoningTokens = reasoningTokens;\n                openrouterUsage.completionTokensDetails = {\n                  reasoningTokens\n                };\n              }\n              openrouterUsage.cost = value.usage.cost;\n              openrouterUsage.totalTokens = value.usage.total_tokens;\n            }\n            const choice = value.choices[0];\n            if ((choice == null ? void 0 : choice.finish_reason) != null) {\n              finishReason = mapOpenRouterFinishReason(choice.finish_reason);\n            }\n            if ((choice == null ? void 0 : choice.delta) == null) {\n              return;\n            }\n            const delta = choice.delta;\n            const emitReasoningChunk = (chunkText) => {\n              if (!reasoningStarted) {\n                reasoningId = openrouterResponseId || generateId();\n                controller.enqueue({\n                  type: \"reasoning-start\",\n                  id: reasoningId\n                });\n                reasoningStarted = true;\n              }\n              controller.enqueue({\n                type: \"reasoning-delta\",\n                delta: chunkText,\n                id: reasoningId || generateId()\n              });\n            };\n            if (delta.reasoning_details && delta.reasoning_details.length > 0) {\n              for (const detail of delta.reasoning_details) {\n                switch (detail.type) {\n                  case \"reasoning.text\" /* Text */: {\n                    if (detail.text) {\n                      emitReasoningChunk(detail.text);\n                    }\n                    break;\n                  }\n                  case \"reasoning.encrypted\" /* Encrypted */: {\n                    if (detail.data) {\n                      emitReasoningChunk(\"[REDACTED]\");\n                    }\n                    break;\n                  }\n                  case \"reasoning.summary\" /* Summary */: {\n                    if (detail.summary) {\n                      emitReasoningChunk(detail.summary);\n                    }\n                    break;\n                  }\n                  default: {\n                    detail;\n                    break;\n                  }\n                }\n              }\n            } else if (delta.reasoning) {\n              emitReasoningChunk(delta.reasoning);\n            }\n            if (delta.content) {\n              if (reasoningStarted && !textStarted) {\n                controller.enqueue({\n                  type: \"reasoning-end\",\n                  id: reasoningId || generateId()\n                });\n                reasoningStarted = false;\n              }\n              if (!textStarted) {\n                textId = openrouterResponseId || generateId();\n                controller.enqueue({\n                  type: \"text-start\",\n                  id: textId\n                });\n                textStarted = true;\n              }\n              controller.enqueue({\n                type: \"text-delta\",\n                delta: delta.content,\n                id: textId || generateId()\n              });\n            }\n            if (delta.annotations) {\n              for (const annotation of delta.annotations) {\n                if (annotation.type === \"url_citation\") {\n                  controller.enqueue({\n                    type: \"source\",\n                    sourceType: \"url\",\n                    id: annotation.url_citation.url,\n                    url: annotation.url_citation.url,\n                    title: annotation.url_citation.title,\n                    providerMetadata: {\n                      openrouter: {\n                        content: annotation.url_citation.content || \"\"\n                      }\n                    }\n                  });\n                }\n              }\n            }\n            if (delta.tool_calls != null) {\n              for (const toolCallDelta of delta.tool_calls) {\n                const index = (_c = toolCallDelta.index) != null ? _c : toolCalls.length - 1;\n                if (toolCalls[index] == null) {\n                  if (toolCallDelta.type !== \"function\") {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function' type.`\n                    });\n                  }\n                  if (toolCallDelta.id == null) {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'id' to be a string.`\n                    });\n                  }\n                  if (((_d = toolCallDelta.function) == null ? void 0 : _d.name) == null) {\n                    throw new InvalidResponseDataError({\n                      data: toolCallDelta,\n                      message: `Expected 'function.name' to be a string.`\n                    });\n                  }\n                  toolCalls[index] = {\n                    id: toolCallDelta.id,\n                    type: \"function\",\n                    function: {\n                      name: toolCallDelta.function.name,\n                      arguments: (_e = toolCallDelta.function.arguments) != null ? _e : \"\"\n                    },\n                    inputStarted: false,\n                    sent: false\n                  };\n                  const toolCall2 = toolCalls[index];\n                  if (toolCall2 == null) {\n                    throw new Error(\"Tool call is missing\");\n                  }\n                  if (((_f = toolCall2.function) == null ? void 0 : _f.name) != null && ((_g = toolCall2.function) == null ? void 0 : _g.arguments) != null && isParsableJson(toolCall2.function.arguments)) {\n                    toolCall2.inputStarted = true;\n                    controller.enqueue({\n                      type: \"tool-input-start\",\n                      id: toolCall2.id,\n                      toolName: toolCall2.function.name\n                    });\n                    controller.enqueue({\n                      type: \"tool-input-delta\",\n                      id: toolCall2.id,\n                      delta: toolCall2.function.arguments\n                    });\n                    controller.enqueue({\n                      type: \"tool-input-end\",\n                      id: toolCall2.id\n                    });\n                    controller.enqueue({\n                      type: \"tool-call\",\n                      toolCallId: toolCall2.id,\n                      toolName: toolCall2.function.name,\n                      input: toolCall2.function.arguments\n                    });\n                    toolCall2.sent = true;\n                  }\n                  continue;\n                }\n                const toolCall = toolCalls[index];\n                if (toolCall == null) {\n                  throw new Error(\"Tool call is missing\");\n                }\n                if (!toolCall.inputStarted) {\n                  toolCall.inputStarted = true;\n                  controller.enqueue({\n                    type: \"tool-input-start\",\n                    id: toolCall.id,\n                    toolName: toolCall.function.name\n                  });\n                }\n                if (((_h = toolCallDelta.function) == null ? void 0 : _h.arguments) != null) {\n                  toolCall.function.arguments += (_j = (_i = toolCallDelta.function) == null ? void 0 : _i.arguments) != null ? _j : \"\";\n                }\n                controller.enqueue({\n                  type: \"tool-input-delta\",\n                  id: toolCall.id,\n                  delta: (_k = toolCallDelta.function.arguments) != null ? _k : \"\"\n                });\n                if (((_l = toolCall.function) == null ? void 0 : _l.name) != null && ((_m = toolCall.function) == null ? void 0 : _m.arguments) != null && isParsableJson(toolCall.function.arguments)) {\n                  controller.enqueue({\n                    type: \"tool-call\",\n                    toolCallId: (_n = toolCall.id) != null ? _n : generateId(),\n                    toolName: toolCall.function.name,\n                    input: toolCall.function.arguments\n                  });\n                  toolCall.sent = true;\n                }\n              }\n            }\n            if (delta.images != null) {\n              for (const image of delta.images) {\n                controller.enqueue({\n                  type: \"file\",\n                  mediaType: getMediaType(image.image_url.url, \"image/jpeg\"),\n                  data: getBase64FromDataUrl(image.image_url.url)\n                });\n              }\n            }\n          },\n          flush(controller) {\n            var _a16;\n            if (finishReason === \"tool-calls\") {\n              for (const toolCall of toolCalls) {\n                if (toolCall && !toolCall.sent) {\n                  controller.enqueue({\n                    type: \"tool-call\",\n                    toolCallId: (_a16 = toolCall.id) != null ? _a16 : generateId(),\n                    toolName: toolCall.function.name,\n                    // Coerce invalid arguments to an empty JSON object\n                    input: isParsableJson(toolCall.function.arguments) ? toolCall.function.arguments : \"{}\"\n                  });\n                  toolCall.sent = true;\n                }\n              }\n            }\n            if (reasoningStarted) {\n              controller.enqueue({\n                type: \"reasoning-end\",\n                id: reasoningId || generateId()\n              });\n            }\n            if (textStarted) {\n              controller.enqueue({\n                type: \"text-end\",\n                id: textId || generateId()\n              });\n            }\n            const openrouterMetadata = {\n              usage: openrouterUsage\n            };\n            if (provider !== void 0) {\n              openrouterMetadata.provider = provider;\n            }\n            controller.enqueue({\n              type: \"finish\",\n              finishReason,\n              usage,\n              providerMetadata: {\n                openrouter: openrouterMetadata\n              }\n            });\n          }\n        })\n      ),\n      warnings: [],\n      request: { body: args },\n      response: { headers: responseHeaders }\n    };\n  }\n};\n\n// src/completion/convert-to-openrouter-completion-prompt.ts\nfunction convertToOpenRouterCompletionPrompt({\n  prompt,\n  inputFormat,\n  user = \"user\",\n  assistant = \"assistant\"\n}) {\n  if (inputFormat === \"prompt\" && prompt.length === 1 && prompt[0] && prompt[0].role === \"user\" && prompt[0].content.length === 1 && prompt[0].content[0] && prompt[0].content[0].type === \"text\") {\n    return { prompt: prompt[0].content[0].text };\n  }\n  let text = \"\";\n  if (prompt[0] && prompt[0].role === \"system\") {\n    text += `${prompt[0].content}\n\n`;\n    prompt = prompt.slice(1);\n  }\n  for (const { role, content } of prompt) {\n    switch (role) {\n      case \"system\": {\n        throw new InvalidPromptError({\n          message: `Unexpected system message in prompt: ${content}`,\n          prompt\n        });\n      }\n      case \"user\": {\n        const userMessage = content.map((part) => {\n          switch (part.type) {\n            case \"text\": {\n              return part.text;\n            }\n            case \"file\": {\n              throw new UnsupportedFunctionalityError({\n                functionality: \"file attachments\"\n              });\n            }\n            default: {\n              return \"\";\n            }\n          }\n        }).join(\"\");\n        text += `${user}:\n${userMessage}\n\n`;\n        break;\n      }\n      case \"assistant\": {\n        const assistantMessage = content.map(\n          (part) => {\n            switch (part.type) {\n              case \"text\": {\n                return part.text;\n              }\n              case \"tool-call\": {\n                throw new UnsupportedFunctionalityError({\n                  functionality: \"tool-call messages\"\n                });\n              }\n              case \"tool-result\": {\n                throw new UnsupportedFunctionalityError({\n                  functionality: \"tool-result messages\"\n                });\n              }\n              case \"reasoning\": {\n                throw new UnsupportedFunctionalityError({\n                  functionality: \"reasoning messages\"\n                });\n              }\n              case \"file\": {\n                throw new UnsupportedFunctionalityError({\n                  functionality: \"file attachments\"\n                });\n              }\n              default: {\n                return \"\";\n              }\n            }\n          }\n        ).join(\"\");\n        text += `${assistant}:\n${assistantMessage}\n\n`;\n        break;\n      }\n      case \"tool\": {\n        throw new UnsupportedFunctionalityError({\n          functionality: \"tool messages\"\n        });\n      }\n      default: {\n        break;\n      }\n    }\n  }\n  text += `${assistant}:\n`;\n  return {\n    prompt: text\n  };\n}\n\n// src/completion/schemas.ts\n\nvar OpenRouterCompletionChunkSchema = zod_v4__WEBPACK_IMPORTED_MODULE_0__.union([\n  zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n    id: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n    model: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().optional(),\n    choices: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(\n      zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n        text: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(),\n        reasoning: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish().optional(),\n        reasoning_details: ReasoningDetailArraySchema.nullish(),\n        finish_reason: zod_v4__WEBPACK_IMPORTED_MODULE_0__.string().nullish(),\n        index: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().nullish(),\n        logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n          tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(zod_v4__WEBPACK_IMPORTED_MODULE_0__.string()),\n          token_logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()),\n          top_logprobs: zod_v4__WEBPACK_IMPORTED_MODULE_0__.array(zod_v4__WEBPACK_IMPORTED_MODULE_0__.record(zod_v4__WEBPACK_IMPORTED_MODULE_0__.string(), zod_v4__WEBPACK_IMPORTED_MODULE_0__.number())).nullable()\n        }).nullable().optional()\n      })\n    ),\n    usage: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n      prompt_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n      prompt_tokens_details: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n        cached_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()\n      }).nullish(),\n      completion_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n      completion_tokens_details: zod_v4__WEBPACK_IMPORTED_MODULE_0__.object({\n        reasoning_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number()\n      }).nullish(),\n      total_tokens: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number(),\n      cost: zod_v4__WEBPACK_IMPORTED_MODULE_0__.number().optional()\n    }).nullish()\n  }),\n  OpenRouterErrorResponseSchema\n]);\n\n// src/completion/index.ts\nvar OpenRouterCompletionLanguageModel = class {\n  constructor(modelId, settings, config) {\n    this.specificationVersion = \"v2\";\n    this.provider = \"openrouter\";\n    this.supportedUrls = {\n      \"image/*\": [\n        /^data:image\\/[a-zA-Z]+;base64,/,\n        /^https?:\\/\\/.+\\.(jpg|jpeg|png|gif|webp)$/i\n      ],\n      \"text/*\": [/^data:text\\//, /^https?:\\/\\/.+$/],\n      \"application/*\": [/^data:application\\//, /^https?:\\/\\/.+$/]\n    };\n    this.defaultObjectGenerationMode = void 0;\n    this.modelId = modelId;\n    this.settings = settings;\n    this.config = config;\n  }\n  getArgs({\n    prompt,\n    maxOutputTokens,\n    temperature,\n    topP,\n    frequencyPenalty,\n    presencePenalty,\n    seed,\n    responseFormat,\n    topK,\n    stopSequences,\n    tools,\n    toolChoice\n  }) {\n    const { prompt: completionPrompt } = convertToOpenRouterCompletionPrompt({\n      prompt,\n      inputFormat: \"prompt\"\n    });\n    if (tools == null ? void 0 : tools.length) {\n      throw new UnsupportedFunctionalityError({\n        functionality: \"tools\"\n      });\n    }\n    if (toolChoice) {\n      throw new UnsupportedFunctionalityError({\n        functionality: \"toolChoice\"\n      });\n    }\n    return __spreadValues(__spreadValues({\n      // model id:\n      model: this.modelId,\n      models: this.settings.models,\n      // model specific settings:\n      logit_bias: this.settings.logitBias,\n      logprobs: typeof this.settings.logprobs === \"number\" ? this.settings.logprobs : typeof this.settings.logprobs === \"boolean\" ? this.settings.logprobs ? 0 : void 0 : void 0,\n      suffix: this.settings.suffix,\n      user: this.settings.user,\n      // standardized settings:\n      max_tokens: maxOutputTokens,\n      temperature,\n      top_p: topP,\n      frequency_penalty: frequencyPenalty,\n      presence_penalty: presencePenalty,\n      seed,\n      stop: stopSequences,\n      response_format: responseFormat,\n      top_k: topK,\n      // prompt:\n      prompt: completionPrompt,\n      // OpenRouter specific settings:\n      include_reasoning: this.settings.includeReasoning,\n      reasoning: this.settings.reasoning\n    }, this.config.extraBody), this.settings.extraBody);\n  }\n  async doGenerate(options) {\n    var _a15, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;\n    const providerOptions = options.providerOptions || {};\n    const openrouterOptions = providerOptions.openrouter || {};\n    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: \"/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: args,\n      failedResponseHandler: openrouterFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        OpenRouterCompletionChunkSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    if (\"error\" in response) {\n      throw new Error(`${response.error.message}`);\n    }\n    const choice = response.choices[0];\n    if (!choice) {\n      throw new Error(\"No choice in OpenRouter completion response\");\n    }\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: (_a15 = choice.text) != null ? _a15 : \"\"\n        }\n      ],\n      finishReason: mapOpenRouterFinishReason(choice.finish_reason),\n      usage: {\n        inputTokens: (_c = (_b = response.usage) == null ? void 0 : _b.prompt_tokens) != null ? _c : 0,\n        outputTokens: (_e = (_d = response.usage) == null ? void 0 : _d.completion_tokens) != null ? _e : 0,\n        totalTokens: ((_g = (_f = response.usage) == null ? void 0 : _f.prompt_tokens) != null ? _g : 0) + ((_i = (_h = response.usage) == null ? void 0 : _h.completion_tokens) != null ? _i : 0),\n        reasoningTokens: (_l = (_k = (_j = response.usage) == null ? void 0 : _j.completion_tokens_details) == null ? void 0 : _k.reasoning_tokens) != null ? _l : 0,\n        cachedInputTokens: (_o = (_n = (_m = response.usage) == null ? void 0 : _m.prompt_tokens_details) == null ? void 0 : _n.cached_tokens) != null ? _o : 0\n      },\n      warnings: [],\n      response: {\n        headers: responseHeaders\n      }\n    };\n  }\n  async doStream(options) {\n    const providerOptions = options.providerOptions || {};\n    const openrouterOptions = providerOptions.openrouter || {};\n    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);\n    const { value: response, responseHeaders } = await postJsonToApi({\n      url: this.config.url({\n        path: \"/completions\",\n        modelId: this.modelId\n      }),\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body: __spreadProps(__spreadValues({}, args), {\n        stream: true,\n        // only include stream_options when in strict compatibility mode:\n        stream_options: this.config.compatibility === \"strict\" ? { include_usage: true } : void 0\n      }),\n      failedResponseHandler: openrouterFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        OpenRouterCompletionChunkSchema\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch\n    });\n    let finishReason = \"other\";\n    const usage = {\n      inputTokens: Number.NaN,\n      outputTokens: Number.NaN,\n      totalTokens: Number.NaN,\n      reasoningTokens: Number.NaN,\n      cachedInputTokens: Number.NaN\n    };\n    const openrouterUsage = {};\n    return {\n      stream: response.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            var _a15, _b;\n            if (!chunk.success) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: chunk.error });\n              return;\n            }\n            const value = chunk.value;\n            if (\"error\" in value) {\n              finishReason = \"error\";\n              controller.enqueue({ type: \"error\", error: value.error });\n              return;\n            }\n            if (value.usage != null) {\n              usage.inputTokens = value.usage.prompt_tokens;\n              usage.outputTokens = value.usage.completion_tokens;\n              usage.totalTokens = value.usage.prompt_tokens + value.usage.completion_tokens;\n              openrouterUsage.promptTokens = value.usage.prompt_tokens;\n              if (value.usage.prompt_tokens_details) {\n                const cachedInputTokens = (_a15 = value.usage.prompt_tokens_details.cached_tokens) != null ? _a15 : 0;\n                usage.cachedInputTokens = cachedInputTokens;\n                openrouterUsage.promptTokensDetails = {\n                  cachedTokens: cachedInputTokens\n                };\n              }\n              openrouterUsage.completionTokens = value.usage.completion_tokens;\n              if (value.usage.completion_tokens_details) {\n                const reasoningTokens = (_b = value.usage.completion_tokens_details.reasoning_tokens) != null ? _b : 0;\n                usage.reasoningTokens = reasoningTokens;\n                openrouterUsage.completionTokensDetails = {\n                  reasoningTokens\n                };\n              }\n              openrouterUsage.cost = value.usage.cost;\n              openrouterUsage.totalTokens = value.usage.total_tokens;\n            }\n            const choice = value.choices[0];\n            if ((choice == null ? void 0 : choice.finish_reason) != null) {\n              finishReason = mapOpenRouterFinishReason(choice.finish_reason);\n            }\n            if ((choice == null ? void 0 : choice.text) != null) {\n              controller.enqueue({\n                type: \"text-delta\",\n                delta: choice.text,\n                id: generateId()\n              });\n            }\n          },\n          flush(controller) {\n            controller.enqueue({\n              type: \"finish\",\n              finishReason,\n              usage,\n              providerMetadata: {\n                openrouter: {\n                  usage: openrouterUsage\n                }\n              }\n            });\n          }\n        })\n      ),\n      response: {\n        headers: responseHeaders\n      }\n    };\n  }\n};\n\n// src/facade.ts\nvar OpenRouter = class {\n  /**\n   * Creates a new OpenRouter provider instance.\n   */\n  constructor(options = {}) {\n    var _a15, _b;\n    this.baseURL = (_b = withoutTrailingSlash((_a15 = options.baseURL) != null ? _a15 : options.baseUrl)) != null ? _b : \"https://openrouter.ai/api/v1\";\n    this.apiKey = options.apiKey;\n    this.headers = options.headers;\n  }\n  get baseConfig() {\n    return {\n      baseURL: this.baseURL,\n      headers: () => __spreadValues({\n        Authorization: `Bearer ${loadApiKey({\n          apiKey: this.apiKey,\n          environmentVariableName: \"OPENROUTER_API_KEY\",\n          description: \"OpenRouter\"\n        })}`\n      }, this.headers)\n    };\n  }\n  chat(modelId, settings = {}) {\n    return new OpenRouterChatLanguageModel(modelId, settings, __spreadProps(__spreadValues({\n      provider: \"openrouter.chat\"\n    }, this.baseConfig), {\n      compatibility: \"strict\",\n      url: ({ path }) => `${this.baseURL}${path}`\n    }));\n  }\n  completion(modelId, settings = {}) {\n    return new OpenRouterCompletionLanguageModel(modelId, settings, __spreadProps(__spreadValues({\n      provider: \"openrouter.completion\"\n    }, this.baseConfig), {\n      compatibility: \"strict\",\n      url: ({ path }) => `${this.baseURL}${path}`\n    }));\n  }\n};\n\n// src/provider.ts\nfunction createOpenRouter(options = {}) {\n  var _a15, _b, _c;\n  const baseURL = (_b = withoutTrailingSlash((_a15 = options.baseURL) != null ? _a15 : options.baseUrl)) != null ? _b : \"https://openrouter.ai/api/v1\";\n  const compatibility = (_c = options.compatibility) != null ? _c : \"compatible\";\n  const getHeaders = () => __spreadValues({\n    Authorization: `Bearer ${loadApiKey({\n      apiKey: options.apiKey,\n      environmentVariableName: \"OPENROUTER_API_KEY\",\n      description: \"OpenRouter\"\n    })}`\n  }, options.headers);\n  const createChatModel = (modelId, settings = {}) => new OpenRouterChatLanguageModel(modelId, settings, {\n    provider: \"openrouter.chat\",\n    url: ({ path }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    compatibility,\n    fetch: options.fetch,\n    extraBody: options.extraBody\n  });\n  const createCompletionModel = (modelId, settings = {}) => new OpenRouterCompletionLanguageModel(modelId, settings, {\n    provider: \"openrouter.completion\",\n    url: ({ path }) => `${baseURL}${path}`,\n    headers: getHeaders,\n    compatibility,\n    fetch: options.fetch,\n    extraBody: options.extraBody\n  });\n  const createLanguageModel = (modelId, settings) => {\n    if (new.target) {\n      throw new Error(\n        \"The OpenRouter model function cannot be called with the new keyword.\"\n      );\n    }\n    if (modelId === \"openai/gpt-3.5-turbo-instruct\") {\n      return createCompletionModel(\n        modelId,\n        settings\n      );\n    }\n    return createChatModel(modelId, settings);\n  };\n  const provider = (modelId, settings) => createLanguageModel(modelId, settings);\n  provider.languageModel = createLanguageModel;\n  provider.chat = createChatModel;\n  provider.completion = createCompletionModel;\n  return provider;\n}\nvar openrouter = createOpenRouter({\n  compatibility: \"strict\"\n  // strict for OpenRouter API\n});\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW5yb3V0ZXIrYWktc2RrLXByb3ZpZGVyQDEuMi4wX2FpQDUuMC40N196b2RAMy4yNS43Nl9fem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL0BvcGVucm91dGVyL2FpLXNkay1wcm92aWRlci9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDLElBQUk7QUFDdEQsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxRUFBcUUsc0JBQXNCLElBQUk7QUFDeEcsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1DQUFtQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1DQUFtQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHO0FBQzFHLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0Isa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsUUFBUTtBQUNuRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG1CQUFtQixLQUFLO0FBQ3hCLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNpQztBQUNqQyxzQ0FBc0MseUNBQVE7QUFDOUMsRUFBRSwwQ0FBUztBQUNYLFFBQVEsMENBQVM7QUFDakIsV0FBVywwQ0FBUztBQUNwQixhQUFhLHlDQUFRO0FBQ3JCLE1BQU0sMENBQVM7QUFDZixjQUFjLDBDQUFTO0FBQ3ZCLG1CQUFtQiwwQ0FBUztBQUM1QjtBQUNBLHVCQUF1QiwwQ0FBUztBQUNoQyxlQUFlLDBDQUFTO0FBQ3hCLGtCQUFrQiwwQ0FBUztBQUMzQixrQkFBa0IseUNBQVEsQ0FBQywwQ0FBUztBQUNwQywwQkFBMEIseUNBQVEsQ0FBQywwQ0FBUztBQUM1Qyx3QkFBd0IseUNBQVEsQ0FBQywwQ0FBUyxDQUFDLDBDQUFTLElBQUksMENBQVM7QUFDakUsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLFdBQVcsMENBQVM7QUFDcEIscUJBQXFCLDBDQUFTO0FBQzlCLDZCQUE2QiwwQ0FBUztBQUN0Qyx1QkFBdUIsMENBQVM7QUFDaEMsT0FBTztBQUNQLHlCQUF5QiwwQ0FBUztBQUNsQyxpQ0FBaUMsMENBQVM7QUFDMUMsMEJBQTBCLDBDQUFTO0FBQ25DLE9BQU87QUFDUCxvQkFBb0IsMENBQVM7QUFDN0IsWUFBWSwwQ0FBUztBQUNyQixLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxtRUFBbUUsc0JBQXNCO0FBQ3pGLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUNBQW1DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsbUNBQW1DO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFNBQVMsRUFBRTtBQUNYLE9BQU87QUFDUDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjLE1BQU0sUUFBUSxhQUFhLEVBQUUsS0FBSztBQUNoRCxLQUFLO0FBQ0w7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsTUFBTSxRQUFRLGFBQWEsRUFBRSxLQUFLO0FBQ2hELEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTtBQUNQLEdBQUc7QUFDSCxpREFBaUQ7QUFDakQ7QUFDQSxZQUFZLE1BQU0sUUFBUSxRQUFRLEVBQUUsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx1REFBdUQ7QUFDdkQ7QUFDQSxZQUFZLE1BQU0sUUFBUSxRQUFRLEVBQUUsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUtDO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy91dHNhdnNoYXJtYS9Eb2N1bWVudHMvR2l0SHViL0RpdkhhY2tzMjAyNS9ub2RlX21vZHVsZXMvLnBucG0vQG9wZW5yb3V0ZXIrYWktc2RrLXByb3ZpZGVyQDEuMi4wX2FpQDUuMC40N196b2RAMy4yNS43Nl9fem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL0BvcGVucm91dGVyL2FpLXNkay1wcm92aWRlci9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmUHJvcHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcbnZhciBfX2dldE93blByb3BEZXNjcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzO1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19zcHJlYWRQcm9wcyA9IChhLCBiKSA9PiBfX2RlZlByb3BzKGEsIF9fZ2V0T3duUHJvcERlc2NzKGIpKTtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BhaS1zZGsrcHJvdmlkZXJAMi4wLjAvbm9kZV9tb2R1bGVzL0BhaS1zZGsvcHJvdmlkZXIvZGlzdC9pbmRleC5tanNcbnZhciBtYXJrZXIgPSBcInZlcmNlbC5haS5lcnJvclwiO1xudmFyIHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcbnZhciBfYTtcbnZhciBfQUlTREtFcnJvciA9IGNsYXNzIF9BSVNES0Vycm9yMiBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gQUkgU0RLIEVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNyZWF0aW5nIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm1lc3NhZ2UgLSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAgICogQHBhcmFtIHt1bmtub3dufSBbcGFyYW1zLmNhdXNlXSAtIFRoZSB1bmRlcmx5aW5nIGNhdXNlIG9mIHRoZSBlcnJvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBuYW1lOiBuYW1lMTQsXG4gICAgbWVzc2FnZSxcbiAgICBjYXVzZVxuICB9KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpc1tfYV0gPSB0cnVlO1xuICAgIHRoaXMubmFtZSA9IG5hbWUxNDtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgYW4gQUkgU0RLIEVycm9yLlxuICAgKiBAcGFyYW0ge3Vua25vd259IGVycm9yIC0gVGhlIGVycm9yIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYW4gQUkgU0RLIEVycm9yLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBfQUlTREtFcnJvcjIuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG4gIHN0YXRpYyBoYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjE1KSB7XG4gICAgY29uc3QgbWFya2VyU3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIxNSk7XG4gICAgcmV0dXJuIGVycm9yICE9IG51bGwgJiYgdHlwZW9mIGVycm9yID09PSBcIm9iamVjdFwiICYmIG1hcmtlclN5bWJvbCBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3JbbWFya2VyU3ltYm9sXSA9PT0gXCJib29sZWFuXCIgJiYgZXJyb3JbbWFya2VyU3ltYm9sXSA9PT0gdHJ1ZTtcbiAgfVxufTtcbl9hID0gc3ltYm9sO1xudmFyIEFJU0RLRXJyb3IgPSBfQUlTREtFcnJvcjtcbnZhciBuYW1lID0gXCJBSV9BUElDYWxsRXJyb3JcIjtcbnZhciBtYXJrZXIyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbnZhciBzeW1ib2wyID0gU3ltYm9sLmZvcihtYXJrZXIyKTtcbnZhciBfYTI7XG52YXIgQVBJQ2FsbEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UsXG4gICAgdXJsLFxuICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgIHN0YXR1c0NvZGUsXG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHJlc3BvbnNlQm9keSxcbiAgICBjYXVzZSxcbiAgICBpc1JldHJ5YWJsZSA9IHN0YXR1c0NvZGUgIT0gbnVsbCAmJiAoc3RhdHVzQ29kZSA9PT0gNDA4IHx8IC8vIHJlcXVlc3QgdGltZW91dFxuICAgIHN0YXR1c0NvZGUgPT09IDQwOSB8fCAvLyBjb25mbGljdFxuICAgIHN0YXR1c0NvZGUgPT09IDQyOSB8fCAvLyB0b28gbWFueSByZXF1ZXN0c1xuICAgIHN0YXR1c0NvZGUgPj0gNTAwKSxcbiAgICAvLyBzZXJ2ZXIgZXJyb3JcbiAgICBkYXRhXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2EyXSA9IHRydWU7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5yZXF1ZXN0Qm9keVZhbHVlcyA9IHJlcXVlc3RCb2R5VmFsdWVzO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnM7XG4gICAgdGhpcy5yZXNwb25zZUJvZHkgPSByZXNwb25zZUJvZHk7XG4gICAgdGhpcy5pc1JldHJ5YWJsZSA9IGlzUmV0cnlhYmxlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjIpO1xuICB9XG59O1xuX2EyID0gc3ltYm9sMjtcbnZhciBuYW1lMiA9IFwiQUlfRW1wdHlSZXNwb25zZUJvZHlFcnJvclwiO1xudmFyIG1hcmtlcjMgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTJ9YDtcbnZhciBzeW1ib2wzID0gU3ltYm9sLmZvcihtYXJrZXIzKTtcbnZhciBfYTM7XG52YXIgRW1wdHlSZXNwb25zZUJvZHlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgPSBcIkVtcHR5IHJlc3BvbnNlIGJvZHlcIiB9ID0ge30pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUyLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2EzXSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjMpO1xuICB9XG59O1xuX2EzID0gc3ltYm9sMztcbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgIHJldHVybiBcInVua25vd24gZXJyb3JcIjtcbiAgfVxuICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbn1cbnZhciBuYW1lMyA9IFwiQUlfSW52YWxpZEFyZ3VtZW50RXJyb3JcIjtcbnZhciBtYXJrZXI0ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUzfWA7XG52YXIgc3ltYm9sNCA9IFN5bWJvbC5mb3IobWFya2VyNCk7XG52YXIgX2E0O1xudmFyIEludmFsaWRBcmd1bWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UsXG4gICAgY2F1c2UsXG4gICAgYXJndW1lbnRcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTMsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E0XSA9IHRydWU7XG4gICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI0KTtcbiAgfVxufTtcbl9hNCA9IHN5bWJvbDQ7XG52YXIgbmFtZTQgPSBcIkFJX0ludmFsaWRQcm9tcHRFcnJvclwiO1xudmFyIG1hcmtlcjUgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTR9YDtcbnZhciBzeW1ib2w1ID0gU3ltYm9sLmZvcihtYXJrZXI1KTtcbnZhciBfYTU7XG52YXIgSW52YWxpZFByb21wdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHByb21wdCxcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU0LCBtZXNzYWdlOiBgSW52YWxpZCBwcm9tcHQ6ICR7bWVzc2FnZX1gLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNV0gPSB0cnVlO1xuICAgIHRoaXMucHJvbXB0ID0gcHJvbXB0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI1KTtcbiAgfVxufTtcbl9hNSA9IHN5bWJvbDU7XG52YXIgbmFtZTUgPSBcIkFJX0ludmFsaWRSZXNwb25zZURhdGFFcnJvclwiO1xudmFyIG1hcmtlcjYgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTV9YDtcbnZhciBzeW1ib2w2ID0gU3ltYm9sLmZvcihtYXJrZXI2KTtcbnZhciBfYTY7XG52YXIgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRhdGEsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIHJlc3BvbnNlIGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9LmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTZdID0gdHJ1ZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI2KTtcbiAgfVxufTtcbl9hNiA9IHN5bWJvbDY7XG52YXIgbmFtZTYgPSBcIkFJX0pTT05QYXJzZUVycm9yXCI7XG52YXIgbWFya2VyNyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNn1gO1xudmFyIHN5bWJvbDcgPSBTeW1ib2wuZm9yKG1hcmtlcjcpO1xudmFyIF9hNztcbnZhciBKU09OUGFyc2VFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHsgdGV4dCwgY2F1c2UgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWU2LFxuICAgICAgbWVzc2FnZTogYEpTT04gcGFyc2luZyBmYWlsZWQ6IFRleHQ6ICR7dGV4dH0uXG5FcnJvciBtZXNzYWdlOiAke2dldEVycm9yTWVzc2FnZShjYXVzZSl9YCxcbiAgICAgIGNhdXNlXG4gICAgfSk7XG4gICAgdGhpc1tfYTddID0gdHJ1ZTtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI3KTtcbiAgfVxufTtcbl9hNyA9IHN5bWJvbDc7XG52YXIgbmFtZTcgPSBcIkFJX0xvYWRBUElLZXlFcnJvclwiO1xudmFyIG1hcmtlcjggPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTd9YDtcbnZhciBzeW1ib2w4ID0gU3ltYm9sLmZvcihtYXJrZXI4KTtcbnZhciBfYTg7XG52YXIgTG9hZEFQSUtleUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNywgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hOF0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI4KTtcbiAgfVxufTtcbl9hOCA9IHN5bWJvbDg7XG52YXIgbmFtZTggPSBcIkFJX0xvYWRTZXR0aW5nRXJyb3JcIjtcbnZhciBtYXJrZXI5ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU4fWA7XG52YXIgc3ltYm9sOSA9IFN5bWJvbC5mb3IobWFya2VyOSk7XG52YXIgX2E5O1xuX2E5ID0gc3ltYm9sOTtcbnZhciBuYW1lOSA9IFwiQUlfTm9Db250ZW50R2VuZXJhdGVkRXJyb3JcIjtcbnZhciBtYXJrZXIxMCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOX1gO1xudmFyIHN5bWJvbDEwID0gU3ltYm9sLmZvcihtYXJrZXIxMCk7XG52YXIgX2ExMDtcbl9hMTAgPSBzeW1ib2wxMDtcbnZhciBuYW1lMTAgPSBcIkFJX05vU3VjaE1vZGVsRXJyb3JcIjtcbnZhciBtYXJrZXIxMSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTB9YDtcbnZhciBzeW1ib2wxMSA9IFN5bWJvbC5mb3IobWFya2VyMTEpO1xudmFyIF9hMTE7XG5fYTExID0gc3ltYm9sMTE7XG52YXIgbmFtZTExID0gXCJBSV9Ub29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yXCI7XG52YXIgbWFya2VyMTIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTExfWA7XG52YXIgc3ltYm9sMTIgPSBTeW1ib2wuZm9yKG1hcmtlcjEyKTtcbnZhciBfYTEyO1xuX2ExMiA9IHN5bWJvbDEyO1xudmFyIG5hbWUxMiA9IFwiQUlfVHlwZVZhbGlkYXRpb25FcnJvclwiO1xudmFyIG1hcmtlcjEzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMn1gO1xudmFyIHN5bWJvbDEzID0gU3ltYm9sLmZvcihtYXJrZXIxMyk7XG52YXIgX2ExMztcbnZhciBfVHlwZVZhbGlkYXRpb25FcnJvciA9IGNsYXNzIF9UeXBlVmFsaWRhdGlvbkVycm9yMiBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IHZhbHVlLCBjYXVzZSB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTEyLFxuICAgICAgbWVzc2FnZTogYFR5cGUgdmFsaWRhdGlvbiBmYWlsZWQ6IFZhbHVlOiAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0uXG5FcnJvciBtZXNzYWdlOiAke2dldEVycm9yTWVzc2FnZShjYXVzZSl9YCxcbiAgICAgIGNhdXNlXG4gICAgfSk7XG4gICAgdGhpc1tfYTEzXSA9IHRydWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMyk7XG4gIH1cbiAgLyoqXG4gICAqIFdyYXBzIGFuIGVycm9yIGludG8gYSBUeXBlVmFsaWRhdGlvbkVycm9yLlxuICAgKiBJZiB0aGUgY2F1c2UgaXMgYWxyZWFkeSBhIFR5cGVWYWxpZGF0aW9uRXJyb3Igd2l0aCB0aGUgc2FtZSB2YWx1ZSwgaXQgcmV0dXJucyB0aGUgY2F1c2UuXG4gICAqIE90aGVyd2lzZSwgaXQgY3JlYXRlcyBhIG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHdyYXBwaW5nIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIHt1bmtub3dufSBwYXJhbXMudmFsdWUgLSBUaGUgdmFsdWUgdGhhdCBmYWlsZWQgdmFsaWRhdGlvbi5cbiAgICogQHBhcmFtIHt1bmtub3dufSBwYXJhbXMuY2F1c2UgLSBUaGUgb3JpZ2luYWwgZXJyb3Igb3IgY2F1c2Ugb2YgdGhlIHZhbGlkYXRpb24gZmFpbHVyZS5cbiAgICogQHJldHVybnMge1R5cGVWYWxpZGF0aW9uRXJyb3J9IEEgVHlwZVZhbGlkYXRpb25FcnJvciBpbnN0YW5jZS5cbiAgICovXG4gIHN0YXRpYyB3cmFwKHtcbiAgICB2YWx1ZSxcbiAgICBjYXVzZVxuICB9KSB7XG4gICAgcmV0dXJuIF9UeXBlVmFsaWRhdGlvbkVycm9yMi5pc0luc3RhbmNlKGNhdXNlKSAmJiBjYXVzZS52YWx1ZSA9PT0gdmFsdWUgPyBjYXVzZSA6IG5ldyBfVHlwZVZhbGlkYXRpb25FcnJvcjIoeyB2YWx1ZSwgY2F1c2UgfSk7XG4gIH1cbn07XG5fYTEzID0gc3ltYm9sMTM7XG52YXIgVHlwZVZhbGlkYXRpb25FcnJvciA9IF9UeXBlVmFsaWRhdGlvbkVycm9yO1xudmFyIG5hbWUxMyA9IFwiQUlfVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3JcIjtcbnZhciBtYXJrZXIxNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTN9YDtcbnZhciBzeW1ib2wxNCA9IFN5bWJvbC5mb3IobWFya2VyMTQpO1xudmFyIF9hMTQ7XG52YXIgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZnVuY3Rpb25hbGl0eSxcbiAgICBtZXNzYWdlID0gYCcke2Z1bmN0aW9uYWxpdHl9JyBmdW5jdGlvbmFsaXR5IG5vdCBzdXBwb3J0ZWQuYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMTMsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTE0XSA9IHRydWU7XG4gICAgdGhpcy5mdW5jdGlvbmFsaXR5ID0gZnVuY3Rpb25hbGl0eTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTQpO1xuICB9XG59O1xuX2ExNCA9IHN5bWJvbDE0O1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vZXZlbnRzb3VyY2UtcGFyc2VyQDMuMC4zL25vZGVfbW9kdWxlcy9ldmVudHNvdXJjZS1wYXJzZXIvZGlzdC9pbmRleC5qc1xudmFyIFBhcnNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKG1lc3NhZ2UpLCB0aGlzLm5hbWUgPSBcIlBhcnNlRXJyb3JcIiwgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlLCB0aGlzLmZpZWxkID0gb3B0aW9ucy5maWVsZCwgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWUsIHRoaXMubGluZSA9IG9wdGlvbnMubGluZTtcbiAgfVxufTtcbmZ1bmN0aW9uIG5vb3AoX2FyZykge1xufVxuZnVuY3Rpb24gY3JlYXRlUGFyc2VyKGNhbGxiYWNrcykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrcyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiYGNhbGxiYWNrc2AgbXVzdCBiZSBhbiBvYmplY3QsIGdvdCBhIGZ1bmN0aW9uIGluc3RlYWQuIERpZCB5b3UgbWVhbiBge29uRXZlbnQ6IGZufWA/XCJcbiAgICApO1xuICBjb25zdCB7IG9uRXZlbnQgPSBub29wLCBvbkVycm9yID0gbm9vcCwgb25SZXRyeSA9IG5vb3AsIG9uQ29tbWVudCB9ID0gY2FsbGJhY2tzO1xuICBsZXQgaW5jb21wbGV0ZUxpbmUgPSBcIlwiLCBpc0ZpcnN0Q2h1bmsgPSB0cnVlLCBpZCwgZGF0YSA9IFwiXCIsIGV2ZW50VHlwZSA9IFwiXCI7XG4gIGZ1bmN0aW9uIGZlZWQobmV3Q2h1bmspIHtcbiAgICBjb25zdCBjaHVuayA9IGlzRmlyc3RDaHVuayA/IG5ld0NodW5rLnJlcGxhY2UoL15cXHhFRlxceEJCXFx4QkYvLCBcIlwiKSA6IG5ld0NodW5rLCBbY29tcGxldGUsIGluY29tcGxldGVdID0gc3BsaXRMaW5lcyhgJHtpbmNvbXBsZXRlTGluZX0ke2NodW5rfWApO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiBjb21wbGV0ZSlcbiAgICAgIHBhcnNlTGluZShsaW5lKTtcbiAgICBpbmNvbXBsZXRlTGluZSA9IGluY29tcGxldGUsIGlzRmlyc3RDaHVuayA9IGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlTGluZShsaW5lKSB7XG4gICAgaWYgKGxpbmUgPT09IFwiXCIpIHtcbiAgICAgIGRpc3BhdGNoRXZlbnQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGxpbmUuc3RhcnRzV2l0aChcIjpcIikpIHtcbiAgICAgIG9uQ29tbWVudCAmJiBvbkNvbW1lbnQobGluZS5zbGljZShsaW5lLnN0YXJ0c1dpdGgoXCI6IFwiKSA/IDIgOiAxKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkU2VwYXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICAgIGlmIChmaWVsZFNlcGFyYXRvckluZGV4ICE9PSAtMSkge1xuICAgICAgY29uc3QgZmllbGQgPSBsaW5lLnNsaWNlKDAsIGZpZWxkU2VwYXJhdG9ySW5kZXgpLCBvZmZzZXQgPSBsaW5lW2ZpZWxkU2VwYXJhdG9ySW5kZXggKyAxXSA9PT0gXCIgXCIgPyAyIDogMSwgdmFsdWUgPSBsaW5lLnNsaWNlKGZpZWxkU2VwYXJhdG9ySW5kZXggKyBvZmZzZXQpO1xuICAgICAgcHJvY2Vzc0ZpZWxkKGZpZWxkLCB2YWx1ZSwgbGluZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByb2Nlc3NGaWVsZChsaW5lLCBcIlwiLCBsaW5lKTtcbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzRmllbGQoZmllbGQsIHZhbHVlLCBsaW5lKSB7XG4gICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgIGV2ZW50VHlwZSA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgIGRhdGEgPSBgJHtkYXRhfSR7dmFsdWV9XG5gO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpZFwiOlxuICAgICAgICBpZCA9IHZhbHVlLmluY2x1ZGVzKFwiXFwwXCIpID8gdm9pZCAwIDogdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJldHJ5XCI6XG4gICAgICAgIC9eXFxkKyQvLnRlc3QodmFsdWUpID8gb25SZXRyeShwYXJzZUludCh2YWx1ZSwgMTApKSA6IG9uRXJyb3IoXG4gICAgICAgICAgbmV3IFBhcnNlRXJyb3IoYEludmFsaWQgXFxgcmV0cnlcXGAgdmFsdWU6IFwiJHt2YWx1ZX1cImAsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZC1yZXRyeVwiLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBsaW5lXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBvbkVycm9yKFxuICAgICAgICAgIG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgYFVua25vd24gZmllbGQgXCIke2ZpZWxkLmxlbmd0aCA+IDIwID8gYCR7ZmllbGQuc2xpY2UoMCwgMjApfVxcdTIwMjZgIDogZmllbGR9XCJgLFxuICAgICAgICAgICAgeyB0eXBlOiBcInVua25vd24tZmllbGRcIiwgZmllbGQsIHZhbHVlLCBsaW5lIH1cbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KCkge1xuICAgIGRhdGEubGVuZ3RoID4gMCAmJiBvbkV2ZW50KHtcbiAgICAgIGlkLFxuICAgICAgZXZlbnQ6IGV2ZW50VHlwZSB8fCB2b2lkIDAsXG4gICAgICAvLyBJZiB0aGUgZGF0YSBidWZmZXIncyBsYXN0IGNoYXJhY3RlciBpcyBhIFUrMDAwQSBMSU5FIEZFRUQgKExGKSBjaGFyYWN0ZXIsXG4gICAgICAvLyB0aGVuIHJlbW92ZSB0aGUgbGFzdCBjaGFyYWN0ZXIgZnJvbSB0aGUgZGF0YSBidWZmZXIuXG4gICAgICBkYXRhOiBkYXRhLmVuZHNXaXRoKGBcbmApID8gZGF0YS5zbGljZSgwLCAtMSkgOiBkYXRhXG4gICAgfSksIGlkID0gdm9pZCAwLCBkYXRhID0gXCJcIiwgZXZlbnRUeXBlID0gXCJcIjtcbiAgfVxuICBmdW5jdGlvbiByZXNldChvcHRpb25zID0ge30pIHtcbiAgICBpbmNvbXBsZXRlTGluZSAmJiBvcHRpb25zLmNvbnN1bWUgJiYgcGFyc2VMaW5lKGluY29tcGxldGVMaW5lKSwgaXNGaXJzdENodW5rID0gdHJ1ZSwgaWQgPSB2b2lkIDAsIGRhdGEgPSBcIlwiLCBldmVudFR5cGUgPSBcIlwiLCBpbmNvbXBsZXRlTGluZSA9IFwiXCI7XG4gIH1cbiAgcmV0dXJuIHsgZmVlZCwgcmVzZXQgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0TGluZXMoY2h1bmspIHtcbiAgY29uc3QgbGluZXMgPSBbXTtcbiAgbGV0IGluY29tcGxldGVMaW5lID0gXCJcIiwgc2VhcmNoSW5kZXggPSAwO1xuICBmb3IgKDsgc2VhcmNoSW5kZXggPCBjaHVuay5sZW5ndGg7ICkge1xuICAgIGNvbnN0IGNySW5kZXggPSBjaHVuay5pbmRleE9mKFwiXFxyXCIsIHNlYXJjaEluZGV4KSwgbGZJbmRleCA9IGNodW5rLmluZGV4T2YoYFxuYCwgc2VhcmNoSW5kZXgpO1xuICAgIGxldCBsaW5lRW5kID0gLTE7XG4gICAgaWYgKGNySW5kZXggIT09IC0xICYmIGxmSW5kZXggIT09IC0xID8gbGluZUVuZCA9IE1hdGgubWluKGNySW5kZXgsIGxmSW5kZXgpIDogY3JJbmRleCAhPT0gLTEgPyBsaW5lRW5kID0gY3JJbmRleCA6IGxmSW5kZXggIT09IC0xICYmIChsaW5lRW5kID0gbGZJbmRleCksIGxpbmVFbmQgPT09IC0xKSB7XG4gICAgICBpbmNvbXBsZXRlTGluZSA9IGNodW5rLnNsaWNlKHNlYXJjaEluZGV4KTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsaW5lID0gY2h1bmsuc2xpY2Uoc2VhcmNoSW5kZXgsIGxpbmVFbmQpO1xuICAgICAgbGluZXMucHVzaChsaW5lKSwgc2VhcmNoSW5kZXggPSBsaW5lRW5kICsgMSwgY2h1bmtbc2VhcmNoSW5kZXggLSAxXSA9PT0gXCJcXHJcIiAmJiBjaHVua1tzZWFyY2hJbmRleF0gPT09IGBcbmAgJiYgc2VhcmNoSW5kZXgrKztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtsaW5lcywgaW5jb21wbGV0ZUxpbmVdO1xufVxuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vZXZlbnRzb3VyY2UtcGFyc2VyQDMuMC4zL25vZGVfbW9kdWxlcy9ldmVudHNvdXJjZS1wYXJzZXIvZGlzdC9zdHJlYW0uanNcbnZhciBFdmVudFNvdXJjZVBhcnNlclN0cmVhbSA9IGNsYXNzIGV4dGVuZHMgVHJhbnNmb3JtU3RyZWFtIHtcbiAgY29uc3RydWN0b3IoeyBvbkVycm9yLCBvblJldHJ5LCBvbkNvbW1lbnQgfSA9IHt9KSB7XG4gICAgbGV0IHBhcnNlcjtcbiAgICBzdXBlcih7XG4gICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgIHBhcnNlciA9IGNyZWF0ZVBhcnNlcih7XG4gICAgICAgICAgb25FdmVudDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZXZlbnQpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25FcnJvcihlcnJvcikge1xuICAgICAgICAgICAgb25FcnJvciA9PT0gXCJ0ZXJtaW5hdGVcIiA/IGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpIDogdHlwZW9mIG9uRXJyb3IgPT0gXCJmdW5jdGlvblwiICYmIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25SZXRyeSxcbiAgICAgICAgICBvbkNvbW1lbnRcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgdHJhbnNmb3JtKGNodW5rKSB7XG4gICAgICAgIHBhcnNlci5mZWVkKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL0BhaS1zZGsrcHJvdmlkZXItdXRpbHNAMy4wLjFfem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL0BhaS1zZGsvcHJvdmlkZXItdXRpbHMvZGlzdC9pbmRleC5tanNcbmltcG9ydCAqIGFzIHo0IGZyb20gXCJ6b2QvdjRcIjtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZC10by1qc29uLXNjaGVtYUAzLjI0LjZfem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9PcHRpb25zLmpzXG52YXIgaWdub3JlT3ZlcnJpZGUgPSBTeW1ib2woXCJMZXQgem9kVG9Kc29uU2NoZW1hIGRlY2lkZSBvbiB3aGljaCBwYXJzZXIgdG8gdXNlXCIpO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kLXRvLWpzb24tc2NoZW1hQDMuMjQuNl96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3NlbGVjdFBhcnNlci5qc1xuaW1wb3J0IHsgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIGFzIFpvZEZpcnN0UGFydHlUeXBlS2luZDMgfSBmcm9tIFwiem9kXCI7XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS96b2QtdG8tanNvbi1zY2hlbWFAMy4yNC42X3pvZEAzLjI1Ljc2L25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy9hcnJheS5qc1xuaW1wb3J0IHsgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIH0gZnJvbSBcInpvZFwiO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kLXRvLWpzb24tc2NoZW1hQDMuMjQuNl96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvcmVjb3JkLmpzXG5pbXBvcnQgeyBab2RGaXJzdFBhcnR5VHlwZUtpbmQgYXMgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMiB9IGZyb20gXCJ6b2RcIjtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZC10by1qc29uLXNjaGVtYUAzLjI0LjZfem9kQDMuMjUuNzYvbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL3N0cmluZy5qc1xudmFyIEFMUEhBX05VTUVSSUMgPSBuZXcgU2V0KFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVlhZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ4eXowMTIzNDU2Nzg5XCIpO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vQGFpLXNkaytwcm92aWRlci11dGlsc0AzLjAuMV96b2RAMy4yNS43Ni9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci11dGlscy9kaXN0L2luZGV4Lm1qc1xuZnVuY3Rpb24gY29tYmluZUhlYWRlcnMoLi4uaGVhZGVycykge1xuICByZXR1cm4gaGVhZGVycy5yZWR1Y2UoXG4gICAgKGNvbWJpbmVkSGVhZGVycywgY3VycmVudEhlYWRlcnMpID0+IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBjb21iaW5lZEhlYWRlcnMpLCBjdXJyZW50SGVhZGVycyAhPSBudWxsID8gY3VycmVudEhlYWRlcnMgOiB7fSksXG4gICAge31cbiAgKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhbLi4ucmVzcG9uc2UuaGVhZGVyc10pO1xufVxudmFyIGNyZWF0ZUlkR2VuZXJhdG9yID0gKHtcbiAgcHJlZml4LFxuICBzaXplID0gMTYsXG4gIGFscGhhYmV0ID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLFxuICBzZXBhcmF0b3IgPSBcIi1cIlxufSA9IHt9KSA9PiB7XG4gIGNvbnN0IGdlbmVyYXRvciA9ICgpID0+IHtcbiAgICBjb25zdCBhbHBoYWJldExlbmd0aCA9IGFscGhhYmV0Lmxlbmd0aDtcbiAgICBjb25zdCBjaGFycyA9IG5ldyBBcnJheShzaXplKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgY2hhcnNbaV0gPSBhbHBoYWJldFtNYXRoLnJhbmRvbSgpICogYWxwaGFiZXRMZW5ndGggfCAwXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oXCJcIik7XG4gIH07XG4gIGlmIChwcmVmaXggPT0gbnVsbCkge1xuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgaWYgKGFscGhhYmV0LmluY2x1ZGVzKHNlcGFyYXRvcikpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgYXJndW1lbnQ6IFwic2VwYXJhdG9yXCIsXG4gICAgICBtZXNzYWdlOiBgVGhlIHNlcGFyYXRvciBcIiR7c2VwYXJhdG9yfVwiIG11c3Qgbm90IGJlIHBhcnQgb2YgdGhlIGFscGhhYmV0IFwiJHthbHBoYWJldH1cIi5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuICgpID0+IGAke3ByZWZpeH0ke3NlcGFyYXRvcn0ke2dlbmVyYXRvcigpfWA7XG59O1xudmFyIGdlbmVyYXRlSWQgPSBjcmVhdGVJZEdlbmVyYXRvcigpO1xuZnVuY3Rpb24gaXNBYm9ydEVycm9yKGVycm9yKSB7XG4gIHJldHVybiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbikgJiYgKGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiIHx8IGVycm9yLm5hbWUgPT09IFwiUmVzcG9uc2VBYm9ydGVkXCIgfHwgLy8gTmV4dC5qc1xuICBlcnJvci5uYW1lID09PSBcIlRpbWVvdXRFcnJvclwiKTtcbn1cbnZhciBGRVRDSF9GQUlMRURfRVJST1JfTUVTU0FHRVMgPSBbXCJmZXRjaCBmYWlsZWRcIiwgXCJmYWlsZWQgdG8gZmV0Y2hcIl07XG5mdW5jdGlvbiBoYW5kbGVGZXRjaEVycm9yKHtcbiAgZXJyb3IsXG4gIHVybCxcbiAgcmVxdWVzdEJvZHlWYWx1ZXNcbn0pIHtcbiAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIEZFVENIX0ZBSUxFRF9FUlJPUl9NRVNTQUdFUy5pbmNsdWRlcyhlcnJvci5tZXNzYWdlLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgY29uc3QgY2F1c2UgPSBlcnJvci5jYXVzZTtcbiAgICBpZiAoY2F1c2UgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBBUElDYWxsRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgQ2Fubm90IGNvbm5lY3QgdG8gQVBJOiAke2NhdXNlLm1lc3NhZ2V9YCxcbiAgICAgICAgY2F1c2UsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICAgIGlzUmV0cnlhYmxlOiB0cnVlXG4gICAgICAgIC8vIHJldHJ5IHdoZW4gbmV0d29yayBlcnJvclxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlcnJvcjtcbn1cbmZ1bmN0aW9uIHJlbW92ZVVuZGVmaW5lZEVudHJpZXMocmVjb3JkKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMocmVjb3JkKS5maWx0ZXIoKFtfa2V5LCB2YWx1ZV0pID0+IHZhbHVlICE9IG51bGwpXG4gICk7XG59XG5mdW5jdGlvbiBsb2FkQXBpS2V5KHtcbiAgYXBpS2V5LFxuICBlbnZpcm9ubWVudFZhcmlhYmxlTmFtZSxcbiAgYXBpS2V5UGFyYW1ldGVyTmFtZSA9IFwiYXBpS2V5XCIsXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIGlmICh0eXBlb2YgYXBpS2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGFwaUtleTtcbiAgfVxuICBpZiAoYXBpS2V5ICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTG9hZEFQSUtleUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBBUEkga2V5IG11c3QgYmUgYSBzdHJpbmcuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7YXBpS2V5UGFyYW1ldGVyTmFtZX0nIHBhcmFtZXRlci4gRW52aXJvbm1lbnQgdmFyaWFibGVzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC5gXG4gICAgfSk7XG4gIH1cbiAgYXBpS2V5ID0gcHJvY2Vzcy5lbnZbZW52aXJvbm1lbnRWYXJpYWJsZU5hbWVdO1xuICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTG9hZEFQSUtleUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBBUEkga2V5IGlzIG1pc3NpbmcuIFBhc3MgaXQgdXNpbmcgdGhlICcke2FwaUtleVBhcmFtZXRlck5hbWV9JyBwYXJhbWV0ZXIgb3IgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlLmBcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIGFwaUtleSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgbXVzdCBiZSBhIHN0cmluZy4gVGhlIHZhbHVlIG9mIHRoZSAke2Vudmlyb25tZW50VmFyaWFibGVOYW1lfSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3QgYSBzdHJpbmcuYFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBhcGlLZXk7XG59XG52YXIgc3VzcGVjdFByb3RvUnggPSAvXCJfX3Byb3RvX19cIlxccyo6LztcbnZhciBzdXNwZWN0Q29uc3RydWN0b3JSeCA9IC9cImNvbnN0cnVjdG9yXCJcXHMqOi87XG5mdW5jdGlvbiBfcGFyc2UodGV4dCkge1xuICBjb25zdCBvYmogPSBKU09OLnBhcnNlKHRleHQpO1xuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGlmIChzdXNwZWN0UHJvdG9SeC50ZXN0KHRleHQpID09PSBmYWxzZSAmJiBzdXNwZWN0Q29uc3RydWN0b3JSeC50ZXN0KHRleHQpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgcmV0dXJuIGZpbHRlcihvYmopO1xufVxuZnVuY3Rpb24gZmlsdGVyKG9iaikge1xuICBsZXQgbmV4dCA9IFtvYmpdO1xuICB3aGlsZSAobmV4dC5sZW5ndGgpIHtcbiAgICBjb25zdCBub2RlcyA9IG5leHQ7XG4gICAgbmV4dCA9IFtdO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBcIl9fcHJvdG9fX1wiKSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJPYmplY3QgY29udGFpbnMgZm9yYmlkZGVuIHByb3RvdHlwZSBwcm9wZXJ0eVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZSwgXCJjb25zdHJ1Y3RvclwiKSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZS5jb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiT2JqZWN0IGNvbnRhaW5zIGZvcmJpZGRlbiBwcm90b3R5cGUgcHJvcGVydHlcIik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBub2RlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbm9kZVtrZXldO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgbmV4dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gc2VjdXJlSnNvblBhcnNlKHRleHQpIHtcbiAgY29uc3QgeyBzdGFja1RyYWNlTGltaXQgfSA9IEVycm9yO1xuICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAwO1xuICB0cnkge1xuICAgIHJldHVybiBfcGFyc2UodGV4dCk7XG4gIH0gZmluYWxseSB7XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gc3RhY2tUcmFjZUxpbWl0O1xuICB9XG59XG52YXIgdmFsaWRhdG9yU3ltYm9sID0gU3ltYm9sLmZvcihcInZlcmNlbC5haS52YWxpZGF0b3JcIik7XG5mdW5jdGlvbiB2YWxpZGF0b3IodmFsaWRhdGUpIHtcbiAgcmV0dXJuIHsgW3ZhbGlkYXRvclN5bWJvbF06IHRydWUsIHZhbGlkYXRlIH07XG59XG5mdW5jdGlvbiBpc1ZhbGlkYXRvcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIHZhbGlkYXRvclN5bWJvbCBpbiB2YWx1ZSAmJiB2YWx1ZVt2YWxpZGF0b3JTeW1ib2xdID09PSB0cnVlICYmIFwidmFsaWRhdGVcIiBpbiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGFzVmFsaWRhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1ZhbGlkYXRvcih2YWx1ZSkgPyB2YWx1ZSA6IHN0YW5kYXJkU2NoZW1hVmFsaWRhdG9yKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHN0YW5kYXJkU2NoZW1hVmFsaWRhdG9yKHN0YW5kYXJkU2NoZW1hKSB7XG4gIHJldHVybiB2YWxpZGF0b3IoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RhbmRhcmRTY2hlbWFbXCJ+c3RhbmRhcmRcIl0udmFsaWRhdGUodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQuaXNzdWVzID09IG51bGwgPyB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiByZXN1bHQudmFsdWUgfSA6IHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGNhdXNlOiByZXN1bHQuaXNzdWVzXG4gICAgICB9KVxuICAgIH07XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVUeXBlcyh7XG4gIHZhbHVlLFxuICBzY2hlbWFcbn0pIHtcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMoeyB2YWx1ZSwgc2NoZW1hIH0pO1xuICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgdGhyb3cgVHlwZVZhbGlkYXRpb25FcnJvci53cmFwKHsgdmFsdWUsIGNhdXNlOiByZXN1bHQuZXJyb3IgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgdmFsdWUsXG4gIHNjaGVtYVxufSkge1xuICBjb25zdCB2YWxpZGF0b3IyID0gYXNWYWxpZGF0b3Ioc2NoZW1hKTtcbiAgdHJ5IHtcbiAgICBpZiAodmFsaWRhdG9yMi52YWxpZGF0ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZSwgcmF3VmFsdWU6IHZhbHVlIH07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRvcjIudmFsaWRhdGUodmFsdWUpO1xuICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHJlc3VsdC52YWx1ZSwgcmF3VmFsdWU6IHZhbHVlIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBUeXBlVmFsaWRhdGlvbkVycm9yLndyYXAoeyB2YWx1ZSwgY2F1c2U6IHJlc3VsdC5lcnJvciB9KSxcbiAgICAgIHJhd1ZhbHVlOiB2YWx1ZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IFR5cGVWYWxpZGF0aW9uRXJyb3Iud3JhcCh7IHZhbHVlLCBjYXVzZTogZXJyb3IgfSksXG4gICAgICByYXdWYWx1ZTogdmFsdWVcbiAgICB9O1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBwYXJzZUpTT04oe1xuICB0ZXh0LFxuICBzY2hlbWFcbn0pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB2YWx1ZSA9IHNlY3VyZUpzb25QYXJzZSh0ZXh0KTtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkYXRlVHlwZXMoeyB2YWx1ZSwgc2NoZW1hIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChKU09OUGFyc2VFcnJvci5pc0luc3RhbmNlKGVycm9yKSB8fCBUeXBlVmFsaWRhdGlvbkVycm9yLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEpTT05QYXJzZUVycm9yKHsgdGV4dCwgY2F1c2U6IGVycm9yIH0pO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBzYWZlUGFyc2VKU09OKHtcbiAgdGV4dCxcbiAgc2NoZW1hXG59KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdmFsdWUgPSBzZWN1cmVKc29uUGFyc2UodGV4dCk7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZSwgcmF3VmFsdWU6IHZhbHVlIH07XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBzYWZlVmFsaWRhdGVUeXBlcyh7IHZhbHVlLCBzY2hlbWEgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IEpTT05QYXJzZUVycm9yLmlzSW5zdGFuY2UoZXJyb3IpID8gZXJyb3IgOiBuZXcgSlNPTlBhcnNlRXJyb3IoeyB0ZXh0LCBjYXVzZTogZXJyb3IgfSksXG4gICAgICByYXdWYWx1ZTogdm9pZCAwXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaXNQYXJzYWJsZUpzb24oaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICBzZWN1cmVKc29uUGFyc2UoaW5wdXQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUpzb25FdmVudFN0cmVhbSh7XG4gIHN0cmVhbSxcbiAgc2NoZW1hXG59KSB7XG4gIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpLnBpcGVUaHJvdWdoKG5ldyBFdmVudFNvdXJjZVBhcnNlclN0cmVhbSgpKS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIGFzeW5jIHRyYW5zZm9ybSh7IGRhdGEgfSwgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoZGF0YSA9PT0gXCJbRE9ORV1cIikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYXdhaXQgc2FmZVBhcnNlSlNPTih7IHRleHQ6IGRhdGEsIHNjaGVtYSB9KSk7XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cbnZhciBnZXRPcmlnaW5hbEZldGNoMiA9ICgpID0+IGdsb2JhbFRoaXMuZmV0Y2g7XG52YXIgcG9zdEpzb25Ub0FwaSA9IGFzeW5jICh7XG4gIHVybCxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2hcbn0pID0+IHBvc3RUb0FwaSh7XG4gIHVybCxcbiAgaGVhZGVyczogX19zcHJlYWRWYWx1ZXMoe1xuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gIH0sIGhlYWRlcnMpLFxuICBib2R5OiB7XG4gICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgdmFsdWVzOiBib2R5XG4gIH0sXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoXG59KTtcbnZhciBwb3N0VG9BcGkgPSBhc3luYyAoe1xuICB1cmwsXG4gIGhlYWRlcnMgPSB7fSxcbiAgYm9keSxcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2ggPSBnZXRPcmlnaW5hbEZldGNoMigpXG59KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiByZW1vdmVVbmRlZmluZWRFbnRyaWVzKGhlYWRlcnMpLFxuICAgICAgYm9keTogYm9keS5jb250ZW50LFxuICAgICAgc2lnbmFsOiBhYm9ydFNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvckluZm9ybWF0aW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JJbmZvcm1hdGlvbiA9IGF3YWl0IGZhaWxlZFJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpIHx8IEFQSUNhbGxFcnJvci5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHByb2Nlc3MgZXJyb3IgcmVzcG9uc2VcIixcbiAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JJbmZvcm1hdGlvbi52YWx1ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyKHtcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikgfHwgQVBJQ2FsbEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwcm9jZXNzIHN1Y2Nlc3NmdWwgcmVzcG9uc2VcIixcbiAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczogYm9keS52YWx1ZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBoYW5kbGVGZXRjaEVycm9yKHsgZXJyb3IsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzIH0pO1xuICB9XG59O1xudmFyIGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlciA9ICh7XG4gIGVycm9yU2NoZW1hLFxuICBlcnJvclRvTWVzc2FnZSxcbiAgaXNSZXRyeWFibGVcbn0pID0+IGFzeW5jICh7IHJlc3BvbnNlLCB1cmwsIHJlcXVlc3RCb2R5VmFsdWVzIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKHJlc3BvbnNlQm9keS50cmltKCkgPT09IFwiXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgdmFsdWU6IG5ldyBBUElDYWxsRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlKVxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkRXJyb3IgPSBhd2FpdCBwYXJzZUpTT04oe1xuICAgICAgdGV4dDogcmVzcG9uc2VCb2R5LFxuICAgICAgc2NoZW1hOiBlcnJvclNjaGVtYVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGVycm9yVG9NZXNzYWdlKHBhcnNlZEVycm9yKSxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlc3BvbnNlQm9keSxcbiAgICAgICAgZGF0YTogcGFyc2VkRXJyb3IsXG4gICAgICAgIGlzUmV0cnlhYmxlOiBpc1JldHJ5YWJsZSA9PSBudWxsID8gdm9pZCAwIDogaXNSZXRyeWFibGUocmVzcG9uc2UsIHBhcnNlZEVycm9yKVxuICAgICAgfSlcbiAgICB9O1xuICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHZhbHVlOiBuZXcgQVBJQ2FsbEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlc3BvbnNlQm9keSxcbiAgICAgICAgaXNSZXRyeWFibGU6IGlzUmV0cnlhYmxlID09IG51bGwgPyB2b2lkIDAgOiBpc1JldHJ5YWJsZShyZXNwb25zZSlcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxufTtcbnZhciBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlciA9IChjaHVua1NjaGVtYSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKHJlc3BvbnNlLmJvZHkgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFbXB0eVJlc3BvbnNlQm9keUVycm9yKHt9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICB2YWx1ZTogcGFyc2VKc29uRXZlbnRTdHJlYW0oe1xuICAgICAgc3RyZWFtOiByZXNwb25zZS5ib2R5LFxuICAgICAgc2NoZW1hOiBjaHVua1NjaGVtYVxuICAgIH0pXG4gIH07XG59O1xudmFyIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIgPSAocmVzcG9uc2VTY2hlbWEpID0+IGFzeW5jICh7IHJlc3BvbnNlLCB1cmwsIHJlcXVlc3RCb2R5VmFsdWVzIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VCb2R5ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICBjb25zdCBwYXJzZWRSZXN1bHQgPSBhd2FpdCBzYWZlUGFyc2VKU09OKHtcbiAgICB0ZXh0OiByZXNwb25zZUJvZHksXG4gICAgc2NoZW1hOiByZXNwb25zZVNjaGVtYVxuICB9KTtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGlmICghcGFyc2VkUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBKU09OIHJlc3BvbnNlXCIsXG4gICAgICBjYXVzZTogcGFyc2VkUmVzdWx0LmVycm9yLFxuICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgdXJsLFxuICAgICAgcmVxdWVzdEJvZHlWYWx1ZXNcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICB2YWx1ZTogcGFyc2VkUmVzdWx0LnZhbHVlLFxuICAgIHJhd1ZhbHVlOiBwYXJzZWRSZXN1bHQucmF3VmFsdWVcbiAgfTtcbn07XG52YXIgc2NoZW1hU3ltYm9sID0gU3ltYm9sLmZvcihcInZlcmNlbC5haS5zY2hlbWFcIik7XG52YXIgeyBidG9hLCBhdG9iIH0gPSBnbG9iYWxUaGlzO1xuZnVuY3Rpb24gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChhcnJheSkge1xuICBsZXQgbGF0aW4xc3RyaW5nID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGxhdGluMXN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChhcnJheVtpXSk7XG4gIH1cbiAgcmV0dXJuIGJ0b2EobGF0aW4xc3RyaW5nKTtcbn1cbmZ1bmN0aW9uIHdpdGhvdXRUcmFpbGluZ1NsYXNoKHVybCkge1xuICByZXR1cm4gdXJsID09IG51bGwgPyB2b2lkIDAgOiB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xufVxuXG4vLyBzcmMvc2NoZW1hcy9yZWFzb25pbmctZGV0YWlscy50c1xuaW1wb3J0IHsgeiB9IGZyb20gXCJ6b2QvdjRcIjtcbnZhciBSZWFzb25pbmdEZXRhaWxTdW1tYXJ5U2NoZW1hID0gei5vYmplY3Qoe1xuICB0eXBlOiB6LmxpdGVyYWwoXCJyZWFzb25pbmcuc3VtbWFyeVwiIC8qIFN1bW1hcnkgKi8pLFxuICBzdW1tYXJ5OiB6LnN0cmluZygpXG59KTtcbnZhciBSZWFzb25pbmdEZXRhaWxFbmNyeXB0ZWRTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHR5cGU6IHoubGl0ZXJhbChcInJlYXNvbmluZy5lbmNyeXB0ZWRcIiAvKiBFbmNyeXB0ZWQgKi8pLFxuICBkYXRhOiB6LnN0cmluZygpXG59KTtcbnZhciBSZWFzb25pbmdEZXRhaWxUZXh0U2NoZW1hID0gei5vYmplY3Qoe1xuICB0eXBlOiB6LmxpdGVyYWwoXCJyZWFzb25pbmcudGV4dFwiIC8qIFRleHQgKi8pLFxuICB0ZXh0OiB6LnN0cmluZygpLm51bGxpc2goKSxcbiAgc2lnbmF0dXJlOiB6LnN0cmluZygpLm51bGxpc2goKVxufSk7XG52YXIgUmVhc29uaW5nRGV0YWlsVW5pb25TY2hlbWEgPSB6LnVuaW9uKFtcbiAgUmVhc29uaW5nRGV0YWlsU3VtbWFyeVNjaGVtYSxcbiAgUmVhc29uaW5nRGV0YWlsRW5jcnlwdGVkU2NoZW1hLFxuICBSZWFzb25pbmdEZXRhaWxUZXh0U2NoZW1hXG5dKTtcbnZhciBSZWFzb25pbmdEZXRhaWxzV2l0aFVua25vd25TY2hlbWEgPSB6LnVuaW9uKFtcbiAgUmVhc29uaW5nRGV0YWlsVW5pb25TY2hlbWEsXG4gIHoudW5rbm93bigpLnRyYW5zZm9ybSgoKSA9PiBudWxsKVxuXSk7XG52YXIgUmVhc29uaW5nRGV0YWlsQXJyYXlTY2hlbWEgPSB6LmFycmF5KFJlYXNvbmluZ0RldGFpbHNXaXRoVW5rbm93blNjaGVtYSkudHJhbnNmb3JtKChkKSA9PiBkLmZpbHRlcigoZDIpID0+ICEhZDIpKTtcblxuLy8gc3JjL3NjaGVtYXMvZXJyb3ItcmVzcG9uc2UudHNcbmltcG9ydCB7IHogYXMgejIgfSBmcm9tIFwiem9kL3Y0XCI7XG52YXIgT3BlblJvdXRlckVycm9yUmVzcG9uc2VTY2hlbWEgPSB6Mi5vYmplY3Qoe1xuICBlcnJvcjogejIub2JqZWN0KHtcbiAgICBjb2RlOiB6Mi51bmlvbihbejIuc3RyaW5nKCksIHoyLm51bWJlcigpXSkubnVsbGFibGUoKS5vcHRpb25hbCgpLmRlZmF1bHQobnVsbCksXG4gICAgbWVzc2FnZTogejIuc3RyaW5nKCksXG4gICAgdHlwZTogejIuc3RyaW5nKCkubnVsbGFibGUoKS5vcHRpb25hbCgpLmRlZmF1bHQobnVsbCksXG4gICAgcGFyYW06IHoyLmFueSgpLm51bGxhYmxlKCkub3B0aW9uYWwoKS5kZWZhdWx0KG51bGwpXG4gIH0pXG59KTtcbnZhciBvcGVucm91dGVyRmFpbGVkUmVzcG9uc2VIYW5kbGVyID0gY3JlYXRlSnNvbkVycm9yUmVzcG9uc2VIYW5kbGVyKHtcbiAgZXJyb3JTY2hlbWE6IE9wZW5Sb3V0ZXJFcnJvclJlc3BvbnNlU2NoZW1hLFxuICBlcnJvclRvTWVzc2FnZTogKGRhdGEpID0+IGRhdGEuZXJyb3IubWVzc2FnZVxufSk7XG5cbi8vIHNyYy91dGlscy9tYXAtZmluaXNoLXJlYXNvbi50c1xuZnVuY3Rpb24gbWFwT3BlblJvdXRlckZpbmlzaFJlYXNvbihmaW5pc2hSZWFzb24pIHtcbiAgc3dpdGNoIChmaW5pc2hSZWFzb24pIHtcbiAgICBjYXNlIFwic3RvcFwiOlxuICAgICAgcmV0dXJuIFwic3RvcFwiO1xuICAgIGNhc2UgXCJsZW5ndGhcIjpcbiAgICAgIHJldHVybiBcImxlbmd0aFwiO1xuICAgIGNhc2UgXCJjb250ZW50X2ZpbHRlclwiOlxuICAgICAgcmV0dXJuIFwiY29udGVudC1maWx0ZXJcIjtcbiAgICBjYXNlIFwiZnVuY3Rpb25fY2FsbFwiOlxuICAgIGNhc2UgXCJ0b29sX2NhbGxzXCI6XG4gICAgICByZXR1cm4gXCJ0b29sLWNhbGxzXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcInVua25vd25cIjtcbiAgfVxufVxuXG4vLyBzcmMvY2hhdC9pcy11cmwudHNcbmZ1bmN0aW9uIGlzVXJsKHtcbiAgdXJsLFxuICBwcm90b2NvbHNcbn0pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKHVybCk7XG4gICAgcmV0dXJuIHByb3RvY29scy5oYXModXJsT2JqLnByb3RvY29sKTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBzcmMvY2hhdC9maWxlLXVybC11dGlscy50c1xuZnVuY3Rpb24gZ2V0RmlsZVVybCh7XG4gIHBhcnQsXG4gIGRlZmF1bHRNZWRpYVR5cGVcbn0pIHtcbiAgdmFyIF9hMTUsIF9iO1xuICBpZiAocGFydC5kYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIGNvbnN0IGJhc2U2NCA9IGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQocGFydC5kYXRhKTtcbiAgICByZXR1cm4gYGRhdGE6JHsoX2ExNSA9IHBhcnQubWVkaWFUeXBlKSAhPSBudWxsID8gX2ExNSA6IGRlZmF1bHRNZWRpYVR5cGV9O2Jhc2U2NCwke2Jhc2U2NH1gO1xuICB9XG4gIGNvbnN0IHN0cmluZ1VybCA9IHBhcnQuZGF0YS50b1N0cmluZygpO1xuICBpZiAoaXNVcmwoe1xuICAgIHVybDogc3RyaW5nVXJsLFxuICAgIHByb3RvY29sczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiaHR0cDpcIiwgXCJodHRwczpcIl0pXG4gIH0pKSB7XG4gICAgcmV0dXJuIHN0cmluZ1VybDtcbiAgfVxuICByZXR1cm4gc3RyaW5nVXJsLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSA/IHN0cmluZ1VybCA6IGBkYXRhOiR7KF9iID0gcGFydC5tZWRpYVR5cGUpICE9IG51bGwgPyBfYiA6IGRlZmF1bHRNZWRpYVR5cGV9O2Jhc2U2NCwke3N0cmluZ1VybH1gO1xufVxuZnVuY3Rpb24gZ2V0TWVkaWFUeXBlKGRhdGFVcmwsIGRlZmF1bHRNZWRpYVR5cGUpIHtcbiAgdmFyIF9hMTU7XG4gIGNvbnN0IG1hdGNoID0gZGF0YVVybC5tYXRjaCgvXmRhdGE6KFteO10rKS8pO1xuICByZXR1cm4gbWF0Y2ggPyAoX2ExNSA9IG1hdGNoWzFdKSAhPSBudWxsID8gX2ExNSA6IGRlZmF1bHRNZWRpYVR5cGUgOiBkZWZhdWx0TWVkaWFUeXBlO1xufVxuZnVuY3Rpb24gZ2V0QmFzZTY0RnJvbURhdGFVcmwoZGF0YVVybCkge1xuICBjb25zdCBtYXRjaCA9IGRhdGFVcmwubWF0Y2goL15kYXRhOlteO10qO2Jhc2U2NCwoLispJC8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IGRhdGFVcmw7XG59XG5cbi8vIHNyYy9jaGF0L2NvbnZlcnQtdG8tb3BlbnJvdXRlci1jaGF0LW1lc3NhZ2VzLnRzXG5mdW5jdGlvbiBnZXRDYWNoZUNvbnRyb2wocHJvdmlkZXJNZXRhZGF0YSkge1xuICB2YXIgX2ExNSwgX2IsIF9jO1xuICBjb25zdCBhbnRocm9waWMgPSBwcm92aWRlck1ldGFkYXRhID09IG51bGwgPyB2b2lkIDAgOiBwcm92aWRlck1ldGFkYXRhLmFudGhyb3BpYztcbiAgY29uc3Qgb3BlbnJvdXRlcjIgPSBwcm92aWRlck1ldGFkYXRhID09IG51bGwgPyB2b2lkIDAgOiBwcm92aWRlck1ldGFkYXRhLm9wZW5yb3V0ZXI7XG4gIHJldHVybiAoX2MgPSAoX2IgPSAoX2ExNSA9IG9wZW5yb3V0ZXIyID09IG51bGwgPyB2b2lkIDAgOiBvcGVucm91dGVyMi5jYWNoZUNvbnRyb2wpICE9IG51bGwgPyBfYTE1IDogb3BlbnJvdXRlcjIgPT0gbnVsbCA/IHZvaWQgMCA6IG9wZW5yb3V0ZXIyLmNhY2hlX2NvbnRyb2wpICE9IG51bGwgPyBfYiA6IGFudGhyb3BpYyA9PSBudWxsID8gdm9pZCAwIDogYW50aHJvcGljLmNhY2hlQ29udHJvbCkgIT0gbnVsbCA/IF9jIDogYW50aHJvcGljID09IG51bGwgPyB2b2lkIDAgOiBhbnRocm9waWMuY2FjaGVfY29udHJvbDtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRUb09wZW5Sb3V0ZXJDaGF0TWVzc2FnZXMocHJvbXB0KSB7XG4gIHZhciBfYTE1LCBfYiwgX2M7XG4gIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gIGZvciAoY29uc3QgeyByb2xlLCBjb250ZW50LCBwcm92aWRlck9wdGlvbnMgfSBvZiBwcm9tcHQpIHtcbiAgICBzd2l0Y2ggKHJvbGUpIHtcbiAgICAgIGNhc2UgXCJzeXN0ZW1cIjoge1xuICAgICAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgY2FjaGVfY29udHJvbDogZ2V0Q2FjaGVDb250cm9sKHByb3ZpZGVyT3B0aW9ucylcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICBpZiAoY29udGVudC5sZW5ndGggPT09IDEgJiYgKChfYTE1ID0gY29udGVudFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTUudHlwZSkgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgY29uc3QgY2FjaGVDb250cm9sID0gKF9iID0gZ2V0Q2FjaGVDb250cm9sKHByb3ZpZGVyT3B0aW9ucykpICE9IG51bGwgPyBfYiA6IGdldENhY2hlQ29udHJvbChjb250ZW50WzBdLnByb3ZpZGVyT3B0aW9ucyk7XG4gICAgICAgICAgY29uc3QgY29udGVudFdpdGhDYWNoZUNvbnRyb2wgPSBjYWNoZUNvbnRyb2wgPyBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICB0ZXh0OiBjb250ZW50WzBdLnRleHQsXG4gICAgICAgICAgICAgIGNhY2hlX2NvbnRyb2w6IGNhY2hlQ29udHJvbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0gOiBjb250ZW50WzBdLnRleHQ7XG4gICAgICAgICAgbWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnRXaXRoQ2FjaGVDb250cm9sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZUNhY2hlQ29udHJvbCA9IGdldENhY2hlQ29udHJvbChwcm92aWRlck9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjb250ZW50UGFydHMgPSBjb250ZW50Lm1hcChcbiAgICAgICAgICAocGFydCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hMTYsIF9iMiwgX2MyLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVDb250cm9sID0gKF9hMTYgPSBnZXRDYWNoZUNvbnRyb2wocGFydC5wcm92aWRlck9wdGlvbnMpKSAhPSBudWxsID8gX2ExNiA6IG1lc3NhZ2VDYWNoZUNvbnRyb2w7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICAgIC8vIEZvciB0ZXh0IHBhcnRzLCBvbmx5IHVzZSBwYXJ0LXNwZWNpZmljIGNhY2hlIGNvbnRyb2xcbiAgICAgICAgICAgICAgICAgIGNhY2hlX2NvbnRyb2w6IGNhY2hlQ29udHJvbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgICBpZiAoKF9iMiA9IHBhcnQubWVkaWFUeXBlKSA9PSBudWxsID8gdm9pZCAwIDogX2IyLnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGdldEZpbGVVcmwoe1xuICAgICAgICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TWVkaWFUeXBlOiBcImltYWdlL2pwZWdcIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlX3VybFwiLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZV91cmw6IHtcbiAgICAgICAgICAgICAgICAgICAgICB1cmxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGltYWdlIHBhcnRzLCB1c2UgcGFydC1zcGVjaWZpYyBvciBtZXNzYWdlLWxldmVsIGNhY2hlIGNvbnRyb2xcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVfY29udHJvbDogY2FjaGVDb250cm9sXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IFN0cmluZyhcbiAgICAgICAgICAgICAgICAgIChfZiA9IChfZSA9IChfZCA9IChfYzIgPSBwYXJ0LnByb3ZpZGVyT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jMi5vcGVucm91dGVyKSA9PSBudWxsID8gdm9pZCAwIDogX2QuZmlsZW5hbWUpICE9IG51bGwgPyBfZSA6IHBhcnQuZmlsZW5hbWUpICE9IG51bGwgPyBfZiA6IFwiXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVEYXRhID0gZ2V0RmlsZVVybCh7XG4gICAgICAgICAgICAgICAgICBwYXJ0LFxuICAgICAgICAgICAgICAgICAgZGVmYXVsdE1lZGlhVHlwZTogXCJhcHBsaWNhdGlvbi9wZGZcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpc1VybCh7XG4gICAgICAgICAgICAgICAgICB1cmw6IGZpbGVEYXRhLFxuICAgICAgICAgICAgICAgICAgcHJvdG9jb2xzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJodHRwOlwiLCBcImh0dHBzOlwiXSlcbiAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogZmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgZmlsZV9kYXRhOiBmaWxlRGF0YVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgICBmaWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZV9kYXRhOiBmaWxlRGF0YVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGNhY2hlX2NvbnRyb2w6IGNhY2hlQ29udHJvbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICBjYWNoZV9jb250cm9sOiBjYWNoZUNvbnRyb2xcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBtZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjb250ZW50OiBjb250ZW50UGFydHNcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcImFzc2lzdGFudFwiOiB7XG4gICAgICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICAgICAgbGV0IHJlYXNvbmluZyA9IFwiXCI7XG4gICAgICAgIGNvbnN0IHJlYXNvbmluZ0RldGFpbHMgPSBbXTtcbiAgICAgICAgY29uc3QgdG9vbENhbGxzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBjb250ZW50KSB7XG4gICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgdGV4dCArPSBwYXJ0LnRleHQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgICAgIHRvb2xDYWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICAgICAgbmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5zdHJpbmdpZnkocGFydC5pbnB1dClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmdcIjoge1xuICAgICAgICAgICAgICByZWFzb25pbmcgKz0gcGFydC50ZXh0O1xuICAgICAgICAgICAgICByZWFzb25pbmdEZXRhaWxzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLnRleHRcIiAvKiBUZXh0ICovLFxuICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgY29udGVudDogdGV4dCxcbiAgICAgICAgICB0b29sX2NhbGxzOiB0b29sQ2FsbHMubGVuZ3RoID4gMCA/IHRvb2xDYWxscyA6IHZvaWQgMCxcbiAgICAgICAgICByZWFzb25pbmc6IHJlYXNvbmluZyB8fCB2b2lkIDAsXG4gICAgICAgICAgcmVhc29uaW5nX2RldGFpbHM6IHJlYXNvbmluZ0RldGFpbHMubGVuZ3RoID4gMCA/IHJlYXNvbmluZ0RldGFpbHMgOiB2b2lkIDAsXG4gICAgICAgICAgY2FjaGVfY29udHJvbDogZ2V0Q2FjaGVDb250cm9sKHByb3ZpZGVyT3B0aW9ucylcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgICBmb3IgKGNvbnN0IHRvb2xSZXNwb25zZSBvZiBjb250ZW50KSB7XG4gICAgICAgICAgY29uc3QgY29udGVudDIgPSBnZXRUb29sUmVzdWx0Q29udGVudCh0b29sUmVzcG9uc2UpO1xuICAgICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgICAgICB0b29sX2NhbGxfaWQ6IHRvb2xSZXNwb25zZS50b29sQ2FsbElkLFxuICAgICAgICAgICAgY29udGVudDogY29udGVudDIsXG4gICAgICAgICAgICBjYWNoZV9jb250cm9sOiAoX2MgPSBnZXRDYWNoZUNvbnRyb2wocHJvdmlkZXJPcHRpb25zKSkgIT0gbnVsbCA/IF9jIDogZ2V0Q2FjaGVDb250cm9sKHRvb2xSZXNwb25zZS5wcm92aWRlck9wdGlvbnMpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWVzc2FnZXM7XG59XG5mdW5jdGlvbiBnZXRUb29sUmVzdWx0Q29udGVudChpbnB1dCkge1xuICByZXR1cm4gaW5wdXQub3V0cHV0LnR5cGUgPT09IFwidGV4dFwiID8gaW5wdXQub3V0cHV0LnZhbHVlIDogSlNPTi5zdHJpbmdpZnkoaW5wdXQub3V0cHV0LnZhbHVlKTtcbn1cblxuLy8gc3JjL2NoYXQvZ2V0LXRvb2wtY2hvaWNlLnRzXG5pbXBvcnQgeyB6IGFzIHozIH0gZnJvbSBcInpvZC92NFwiO1xudmFyIENoYXRDb21wbGV0aW9uVG9vbENob2ljZVNjaGVtYSA9IHozLnVuaW9uKFtcbiAgejMubGl0ZXJhbChcImF1dG9cIiksXG4gIHozLmxpdGVyYWwoXCJub25lXCIpLFxuICB6My5saXRlcmFsKFwicmVxdWlyZWRcIiksXG4gIHozLm9iamVjdCh7XG4gICAgdHlwZTogejMubGl0ZXJhbChcImZ1bmN0aW9uXCIpLFxuICAgIGZ1bmN0aW9uOiB6My5vYmplY3Qoe1xuICAgICAgbmFtZTogejMuc3RyaW5nKClcbiAgICB9KVxuICB9KVxuXSk7XG5mdW5jdGlvbiBnZXRDaGF0Q29tcGxldGlvblRvb2xDaG9pY2UodG9vbENob2ljZSkge1xuICBzd2l0Y2ggKHRvb2xDaG9pY2UudHlwZSkge1xuICAgIGNhc2UgXCJhdXRvXCI6XG4gICAgY2FzZSBcIm5vbmVcIjpcbiAgICBjYXNlIFwicmVxdWlyZWRcIjpcbiAgICAgIHJldHVybiB0b29sQ2hvaWNlLnR5cGU7XG4gICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBmdW5jdGlvbjogeyBuYW1lOiB0b29sQ2hvaWNlLnRvb2xOYW1lIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIHRvb2xDaG9pY2U7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdG9vbCBjaG9pY2UgdHlwZTogJHt0b29sQ2hvaWNlfWApO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvY2hhdC9zY2hlbWFzLnRzXG5pbXBvcnQgeyB6IGFzIHo2IH0gZnJvbSBcInpvZC92NFwiO1xuXG4vLyBzcmMvc2NoZW1hcy9pbWFnZS50c1xuaW1wb3J0IHsgeiBhcyB6NSB9IGZyb20gXCJ6b2QvdjRcIjtcbnZhciBJbWFnZVJlc3BvbnNlU2NoZW1hID0gejUub2JqZWN0KHtcbiAgdHlwZTogejUubGl0ZXJhbChcImltYWdlX3VybFwiKSxcbiAgaW1hZ2VfdXJsOiB6NS5vYmplY3Qoe1xuICAgIHVybDogejUuc3RyaW5nKClcbiAgfSlcbn0pO1xudmFyIEltYWdlUmVzcG9uc2VXaXRoVW5rbm93blNjaGVtYSA9IHo1LnVuaW9uKFtcbiAgSW1hZ2VSZXNwb25zZVNjaGVtYSxcbiAgejUudW5rbm93bigpLnRyYW5zZm9ybSgoKSA9PiBudWxsKVxuXSk7XG52YXIgSW1hZ2VSZXNwb25zZUFycmF5U2NoZW1hID0gejUuYXJyYXkoSW1hZ2VSZXNwb25zZVdpdGhVbmtub3duU2NoZW1hKS50cmFuc2Zvcm0oKGQpID0+IGQuZmlsdGVyKChkMikgPT4gISFkMikpO1xuXG4vLyBzcmMvY2hhdC9zY2hlbWFzLnRzXG52YXIgT3BlblJvdXRlckNoYXRDb21wbGV0aW9uQmFzZVJlc3BvbnNlU2NoZW1hID0gejYub2JqZWN0KHtcbiAgaWQ6IHo2LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIG1vZGVsOiB6Ni5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICBwcm92aWRlcjogejYuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgdXNhZ2U6IHo2Lm9iamVjdCh7XG4gICAgcHJvbXB0X3Rva2VuczogejYubnVtYmVyKCksXG4gICAgcHJvbXB0X3Rva2Vuc19kZXRhaWxzOiB6Ni5vYmplY3Qoe1xuICAgICAgY2FjaGVkX3Rva2VuczogejYubnVtYmVyKClcbiAgICB9KS5udWxsaXNoKCksXG4gICAgY29tcGxldGlvbl90b2tlbnM6IHo2Lm51bWJlcigpLFxuICAgIGNvbXBsZXRpb25fdG9rZW5zX2RldGFpbHM6IHo2Lm9iamVjdCh7XG4gICAgICByZWFzb25pbmdfdG9rZW5zOiB6Ni5udW1iZXIoKVxuICAgIH0pLm51bGxpc2goKSxcbiAgICB0b3RhbF90b2tlbnM6IHo2Lm51bWJlcigpLFxuICAgIGNvc3Q6IHo2Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgY29zdF9kZXRhaWxzOiB6Ni5vYmplY3Qoe1xuICAgICAgdXBzdHJlYW1faW5mZXJlbmNlX2Nvc3Q6IHo2Lm51bWJlcigpLm51bGxpc2goKVxuICAgIH0pLm51bGxpc2goKVxuICB9KS5udWxsaXNoKClcbn0pO1xudmFyIE9wZW5Sb3V0ZXJOb25TdHJlYW1DaGF0Q29tcGxldGlvblJlc3BvbnNlU2NoZW1hID0gT3BlblJvdXRlckNoYXRDb21wbGV0aW9uQmFzZVJlc3BvbnNlU2NoZW1hLmV4dGVuZCh7XG4gIGNob2ljZXM6IHo2LmFycmF5KFxuICAgIHo2Lm9iamVjdCh7XG4gICAgICBtZXNzYWdlOiB6Ni5vYmplY3Qoe1xuICAgICAgICByb2xlOiB6Ni5saXRlcmFsKFwiYXNzaXN0YW50XCIpLFxuICAgICAgICBjb250ZW50OiB6Ni5zdHJpbmcoKS5udWxsYWJsZSgpLm9wdGlvbmFsKCksXG4gICAgICAgIHJlYXNvbmluZzogejYuc3RyaW5nKCkubnVsbGFibGUoKS5vcHRpb25hbCgpLFxuICAgICAgICByZWFzb25pbmdfZGV0YWlsczogUmVhc29uaW5nRGV0YWlsQXJyYXlTY2hlbWEubnVsbGlzaCgpLFxuICAgICAgICBpbWFnZXM6IEltYWdlUmVzcG9uc2VBcnJheVNjaGVtYS5udWxsaXNoKCksXG4gICAgICAgIHRvb2xfY2FsbHM6IHo2LmFycmF5KFxuICAgICAgICAgIHo2Lm9iamVjdCh7XG4gICAgICAgICAgICBpZDogejYuc3RyaW5nKCkub3B0aW9uYWwoKS5udWxsYWJsZSgpLFxuICAgICAgICAgICAgdHlwZTogejYubGl0ZXJhbChcImZ1bmN0aW9uXCIpLFxuICAgICAgICAgICAgZnVuY3Rpb246IHo2Lm9iamVjdCh7XG4gICAgICAgICAgICAgIG5hbWU6IHo2LnN0cmluZygpLFxuICAgICAgICAgICAgICBhcmd1bWVudHM6IHo2LnN0cmluZygpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgICkub3B0aW9uYWwoKSxcbiAgICAgICAgYW5ub3RhdGlvbnM6IHo2LmFycmF5KFxuICAgICAgICAgIHo2Lm9iamVjdCh7XG4gICAgICAgICAgICB0eXBlOiB6Ni5lbnVtKFtcInVybF9jaXRhdGlvblwiXSksXG4gICAgICAgICAgICB1cmxfY2l0YXRpb246IHo2Lm9iamVjdCh7XG4gICAgICAgICAgICAgIGVuZF9pbmRleDogejYubnVtYmVyKCksXG4gICAgICAgICAgICAgIHN0YXJ0X2luZGV4OiB6Ni5udW1iZXIoKSxcbiAgICAgICAgICAgICAgdGl0bGU6IHo2LnN0cmluZygpLFxuICAgICAgICAgICAgICB1cmw6IHo2LnN0cmluZygpLFxuICAgICAgICAgICAgICBjb250ZW50OiB6Ni5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgICkubnVsbGlzaCgpXG4gICAgICB9KSxcbiAgICAgIGluZGV4OiB6Ni5udW1iZXIoKS5udWxsaXNoKCksXG4gICAgICBsb2dwcm9iczogejYub2JqZWN0KHtcbiAgICAgICAgY29udGVudDogejYuYXJyYXkoXG4gICAgICAgICAgejYub2JqZWN0KHtcbiAgICAgICAgICAgIHRva2VuOiB6Ni5zdHJpbmcoKSxcbiAgICAgICAgICAgIGxvZ3Byb2I6IHo2Lm51bWJlcigpLFxuICAgICAgICAgICAgdG9wX2xvZ3Byb2JzOiB6Ni5hcnJheShcbiAgICAgICAgICAgICAgejYub2JqZWN0KHtcbiAgICAgICAgICAgICAgICB0b2tlbjogejYuc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgbG9ncHJvYjogejYubnVtYmVyKClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KVxuICAgICAgICApLm51bGxhYmxlKClcbiAgICAgIH0pLm51bGxhYmxlKCkub3B0aW9uYWwoKSxcbiAgICAgIGZpbmlzaF9yZWFzb246IHo2LnN0cmluZygpLm9wdGlvbmFsKCkubnVsbGFibGUoKVxuICAgIH0pXG4gIClcbn0pO1xudmFyIE9wZW5Sb3V0ZXJTdHJlYW1DaGF0Q29tcGxldGlvbkNodW5rU2NoZW1hID0gejYudW5pb24oW1xuICBPcGVuUm91dGVyQ2hhdENvbXBsZXRpb25CYXNlUmVzcG9uc2VTY2hlbWEuZXh0ZW5kKHtcbiAgICBjaG9pY2VzOiB6Ni5hcnJheShcbiAgICAgIHo2Lm9iamVjdCh7XG4gICAgICAgIGRlbHRhOiB6Ni5vYmplY3Qoe1xuICAgICAgICAgIHJvbGU6IHo2LmVudW0oW1wiYXNzaXN0YW50XCJdKS5vcHRpb25hbCgpLFxuICAgICAgICAgIGNvbnRlbnQ6IHo2LnN0cmluZygpLm51bGxpc2goKSxcbiAgICAgICAgICByZWFzb25pbmc6IHo2LnN0cmluZygpLm51bGxpc2goKS5vcHRpb25hbCgpLFxuICAgICAgICAgIHJlYXNvbmluZ19kZXRhaWxzOiBSZWFzb25pbmdEZXRhaWxBcnJheVNjaGVtYS5udWxsaXNoKCksXG4gICAgICAgICAgaW1hZ2VzOiBJbWFnZVJlc3BvbnNlQXJyYXlTY2hlbWEubnVsbGlzaCgpLFxuICAgICAgICAgIHRvb2xfY2FsbHM6IHo2LmFycmF5KFxuICAgICAgICAgICAgejYub2JqZWN0KHtcbiAgICAgICAgICAgICAgaW5kZXg6IHo2Lm51bWJlcigpLm51bGxpc2goKSxcbiAgICAgICAgICAgICAgaWQ6IHo2LnN0cmluZygpLm51bGxpc2goKSxcbiAgICAgICAgICAgICAgdHlwZTogejYubGl0ZXJhbChcImZ1bmN0aW9uXCIpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGZ1bmN0aW9uOiB6Ni5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIG5hbWU6IHo2LnN0cmluZygpLm51bGxpc2goKSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IHo2LnN0cmluZygpLm51bGxpc2goKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApLm51bGxpc2goKSxcbiAgICAgICAgICBhbm5vdGF0aW9uczogejYuYXJyYXkoXG4gICAgICAgICAgICB6Ni5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6Ni5lbnVtKFtcInVybF9jaXRhdGlvblwiXSksXG4gICAgICAgICAgICAgIHVybF9jaXRhdGlvbjogejYub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBlbmRfaW5kZXg6IHo2Lm51bWJlcigpLFxuICAgICAgICAgICAgICAgIHN0YXJ0X2luZGV4OiB6Ni5udW1iZXIoKSxcbiAgICAgICAgICAgICAgICB0aXRsZTogejYuc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgdXJsOiB6Ni5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB6Ni5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICkubnVsbGlzaCgpXG4gICAgICAgIH0pLm51bGxpc2goKSxcbiAgICAgICAgbG9ncHJvYnM6IHo2Lm9iamVjdCh7XG4gICAgICAgICAgY29udGVudDogejYuYXJyYXkoXG4gICAgICAgICAgICB6Ni5vYmplY3Qoe1xuICAgICAgICAgICAgICB0b2tlbjogejYuc3RyaW5nKCksXG4gICAgICAgICAgICAgIGxvZ3Byb2I6IHo2Lm51bWJlcigpLFxuICAgICAgICAgICAgICB0b3BfbG9ncHJvYnM6IHo2LmFycmF5KFxuICAgICAgICAgICAgICAgIHo2Lm9iamVjdCh7XG4gICAgICAgICAgICAgICAgICB0b2tlbjogejYuc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICBsb2dwcm9iOiB6Ni5udW1iZXIoKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKS5udWxsYWJsZSgpXG4gICAgICAgIH0pLm51bGxpc2goKSxcbiAgICAgICAgZmluaXNoX3JlYXNvbjogejYuc3RyaW5nKCkubnVsbGFibGUoKS5vcHRpb25hbCgpLFxuICAgICAgICBpbmRleDogejYubnVtYmVyKCkubnVsbGlzaCgpXG4gICAgICB9KVxuICAgIClcbiAgfSksXG4gIE9wZW5Sb3V0ZXJFcnJvclJlc3BvbnNlU2NoZW1hXG5dKTtcblxuLy8gc3JjL2NoYXQvaW5kZXgudHNcbnZhciBPcGVuUm91dGVyQ2hhdExhbmd1YWdlTW9kZWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG1vZGVsSWQsIHNldHRpbmdzLCBjb25maWcpIHtcbiAgICB0aGlzLnNwZWNpZmljYXRpb25WZXJzaW9uID0gXCJ2MlwiO1xuICAgIHRoaXMucHJvdmlkZXIgPSBcIm9wZW5yb3V0ZXJcIjtcbiAgICB0aGlzLmRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZSA9IFwidG9vbFwiO1xuICAgIHRoaXMuc3VwcG9ydGVkVXJscyA9IHtcbiAgICAgIFwiaW1hZ2UvKlwiOiBbXG4gICAgICAgIC9eZGF0YTppbWFnZVxcL1thLXpBLVpdKztiYXNlNjQsLyxcbiAgICAgICAgL15odHRwcz86XFwvXFwvLitcXC4oanBnfGpwZWd8cG5nfGdpZnx3ZWJwKSQvaVxuICAgICAgXSxcbiAgICAgIC8vICd0ZXh0LyonOiBbL15kYXRhOnRleHRcXC8vLCAvXmh0dHBzPzpcXC9cXC8uKyQvXSxcbiAgICAgIFwiYXBwbGljYXRpb24vKlwiOiBbL15kYXRhOmFwcGxpY2F0aW9uXFwvLywgL15odHRwcz86XFwvXFwvLiskL11cbiAgICB9O1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG4gIGdldEFyZ3Moe1xuICAgIHByb21wdCxcbiAgICBtYXhPdXRwdXRUb2tlbnMsXG4gICAgdGVtcGVyYXR1cmUsXG4gICAgdG9wUCxcbiAgICBmcmVxdWVuY3lQZW5hbHR5LFxuICAgIHByZXNlbmNlUGVuYWx0eSxcbiAgICBzZWVkLFxuICAgIHN0b3BTZXF1ZW5jZXMsXG4gICAgcmVzcG9uc2VGb3JtYXQsXG4gICAgdG9wSyxcbiAgICB0b29scyxcbiAgICB0b29sQ2hvaWNlXG4gIH0pIHtcbiAgICB2YXIgX2ExNTtcbiAgICBjb25zdCBiYXNlQXJncyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIC8vIG1vZGVsIGlkOlxuICAgICAgbW9kZWw6IHRoaXMubW9kZWxJZCxcbiAgICAgIG1vZGVsczogdGhpcy5zZXR0aW5ncy5tb2RlbHMsXG4gICAgICAvLyBtb2RlbCBzcGVjaWZpYyBzZXR0aW5nczpcbiAgICAgIGxvZ2l0X2JpYXM6IHRoaXMuc2V0dGluZ3MubG9naXRCaWFzLFxuICAgICAgbG9ncHJvYnM6IHRoaXMuc2V0dGluZ3MubG9ncHJvYnMgPT09IHRydWUgfHwgdHlwZW9mIHRoaXMuc2V0dGluZ3MubG9ncHJvYnMgPT09IFwibnVtYmVyXCIgPyB0cnVlIDogdm9pZCAwLFxuICAgICAgdG9wX2xvZ3Byb2JzOiB0eXBlb2YgdGhpcy5zZXR0aW5ncy5sb2dwcm9icyA9PT0gXCJudW1iZXJcIiA/IHRoaXMuc2V0dGluZ3MubG9ncHJvYnMgOiB0eXBlb2YgdGhpcy5zZXR0aW5ncy5sb2dwcm9icyA9PT0gXCJib29sZWFuXCIgPyB0aGlzLnNldHRpbmdzLmxvZ3Byb2JzID8gMCA6IHZvaWQgMCA6IHZvaWQgMCxcbiAgICAgIHVzZXI6IHRoaXMuc2V0dGluZ3MudXNlcixcbiAgICAgIHBhcmFsbGVsX3Rvb2xfY2FsbHM6IHRoaXMuc2V0dGluZ3MucGFyYWxsZWxUb29sQ2FsbHMsXG4gICAgICAvLyBzdGFuZGFyZGl6ZWQgc2V0dGluZ3M6XG4gICAgICBtYXhfdG9rZW5zOiBtYXhPdXRwdXRUb2tlbnMsXG4gICAgICB0ZW1wZXJhdHVyZSxcbiAgICAgIHRvcF9wOiB0b3BQLFxuICAgICAgZnJlcXVlbmN5X3BlbmFsdHk6IGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICBwcmVzZW5jZV9wZW5hbHR5OiBwcmVzZW5jZVBlbmFsdHksXG4gICAgICBzZWVkLFxuICAgICAgc3RvcDogc3RvcFNlcXVlbmNlcyxcbiAgICAgIHJlc3BvbnNlX2Zvcm1hdDogcmVzcG9uc2VGb3JtYXQsXG4gICAgICB0b3BfazogdG9wSyxcbiAgICAgIC8vIG1lc3NhZ2VzOlxuICAgICAgbWVzc2FnZXM6IGNvbnZlcnRUb09wZW5Sb3V0ZXJDaGF0TWVzc2FnZXMocHJvbXB0KSxcbiAgICAgIC8vIE9wZW5Sb3V0ZXIgc3BlY2lmaWMgc2V0dGluZ3M6XG4gICAgICBpbmNsdWRlX3JlYXNvbmluZzogdGhpcy5zZXR0aW5ncy5pbmNsdWRlUmVhc29uaW5nLFxuICAgICAgcmVhc29uaW5nOiB0aGlzLnNldHRpbmdzLnJlYXNvbmluZyxcbiAgICAgIHVzYWdlOiB0aGlzLnNldHRpbmdzLnVzYWdlLFxuICAgICAgLy8gV2ViIHNlYXJjaCBzZXR0aW5nczpcbiAgICAgIHBsdWdpbnM6IHRoaXMuc2V0dGluZ3MucGx1Z2lucyxcbiAgICAgIHdlYl9zZWFyY2hfb3B0aW9uczogdGhpcy5zZXR0aW5ncy53ZWJfc2VhcmNoX29wdGlvbnMsXG4gICAgICAvLyBQcm92aWRlciByb3V0aW5nIHNldHRpbmdzOlxuICAgICAgcHJvdmlkZXI6IHRoaXMuc2V0dGluZ3MucHJvdmlkZXJcbiAgICB9LCB0aGlzLmNvbmZpZy5leHRyYUJvZHkpLCB0aGlzLnNldHRpbmdzLmV4dHJhQm9keSk7XG4gICAgaWYgKChyZXNwb25zZUZvcm1hdCA9PSBudWxsID8gdm9pZCAwIDogcmVzcG9uc2VGb3JtYXQudHlwZSkgPT09IFwianNvblwiICYmIHJlc3BvbnNlRm9ybWF0LnNjaGVtYSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYmFzZUFyZ3MpLCB7XG4gICAgICAgIHJlc3BvbnNlX2Zvcm1hdDoge1xuICAgICAgICAgIHR5cGU6IFwianNvbl9zY2hlbWFcIixcbiAgICAgICAgICBqc29uX3NjaGVtYTogX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICAgICAgc2NoZW1hOiByZXNwb25zZUZvcm1hdC5zY2hlbWEsXG4gICAgICAgICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICAgICAgICBuYW1lOiAoX2ExNSA9IHJlc3BvbnNlRm9ybWF0Lm5hbWUpICE9IG51bGwgPyBfYTE1IDogXCJyZXNwb25zZVwiXG4gICAgICAgICAgfSwgcmVzcG9uc2VGb3JtYXQuZGVzY3JpcHRpb24gJiYge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IHJlc3BvbnNlRm9ybWF0LmRlc2NyaXB0aW9uXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0b29scyAmJiB0b29scy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBtYXBwZWRUb29scyA9IHRvb2xzLmZpbHRlcigodG9vbCkgPT4gdG9vbC50eXBlID09PSBcImZ1bmN0aW9uXCIpLm1hcCgodG9vbCkgPT4gKHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgIG5hbWU6IHRvb2wubmFtZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbC5kZXNjcmlwdGlvbixcbiAgICAgICAgICBwYXJhbWV0ZXJzOiB0b29sLmlucHV0U2NoZW1hXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBiYXNlQXJncyksIHtcbiAgICAgICAgdG9vbHM6IG1hcHBlZFRvb2xzLFxuICAgICAgICB0b29sX2Nob2ljZTogdG9vbENob2ljZSA/IGdldENoYXRDb21wbGV0aW9uVG9vbENob2ljZSh0b29sQ2hvaWNlKSA6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlQXJncztcbiAgfVxuICBhc3luYyBkb0dlbmVyYXRlKG9wdGlvbnMpIHtcbiAgICB2YXIgX2ExNSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9pLCBfaiwgX2ssIF9sLCBfbSwgX24sIF9vLCBfcCwgX3EsIF9yLCBfcywgX3QsIF91LCBfdiwgX3csIF94O1xuICAgIGNvbnN0IHByb3ZpZGVyT3B0aW9ucyA9IG9wdGlvbnMucHJvdmlkZXJPcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IG9wZW5yb3V0ZXJPcHRpb25zID0gcHJvdmlkZXJPcHRpb25zLm9wZW5yb3V0ZXIgfHwge307XG4gICAgY29uc3QgYXJncyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLmdldEFyZ3Mob3B0aW9ucykpLCBvcGVucm91dGVyT3B0aW9ucyk7XG4gICAgY29uc3QgeyB2YWx1ZTogcmVzcG9uc2UsIHJlc3BvbnNlSGVhZGVycyB9ID0gYXdhaXQgcG9zdEpzb25Ub0FwaSh7XG4gICAgICB1cmw6IHRoaXMuY29uZmlnLnVybCh7XG4gICAgICAgIHBhdGg6IFwiL2NoYXQvY29tcGxldGlvbnNcIixcbiAgICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbElkXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IGNvbWJpbmVIZWFkZXJzKHRoaXMuY29uZmlnLmhlYWRlcnMoKSwgb3B0aW9ucy5oZWFkZXJzKSxcbiAgICAgIGJvZHk6IGFyZ3MsXG4gICAgICBmYWlsZWRSZXNwb25zZUhhbmRsZXI6IG9wZW5yb3V0ZXJGYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gICAgICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyOiBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyKFxuICAgICAgICBPcGVuUm91dGVyTm9uU3RyZWFtQ2hhdENvbXBsZXRpb25SZXNwb25zZVNjaGVtYVxuICAgICAgKSxcbiAgICAgIGFib3J0U2lnbmFsOiBvcHRpb25zLmFib3J0U2lnbmFsLFxuICAgICAgZmV0Y2g6IHRoaXMuY29uZmlnLmZldGNoXG4gICAgfSk7XG4gICAgY29uc3QgY2hvaWNlID0gcmVzcG9uc2UuY2hvaWNlc1swXTtcbiAgICBpZiAoIWNob2ljZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2hvaWNlIGluIHJlc3BvbnNlXCIpO1xuICAgIH1cbiAgICBjb25zdCB1c2FnZUluZm8gPSByZXNwb25zZS51c2FnZSA/IHtcbiAgICAgIGlucHV0VG9rZW5zOiAoX2ExNSA9IHJlc3BvbnNlLnVzYWdlLnByb21wdF90b2tlbnMpICE9IG51bGwgPyBfYTE1IDogMCxcbiAgICAgIG91dHB1dFRva2VuczogKF9iID0gcmVzcG9uc2UudXNhZ2UuY29tcGxldGlvbl90b2tlbnMpICE9IG51bGwgPyBfYiA6IDAsXG4gICAgICB0b3RhbFRva2VuczogKChfYyA9IHJlc3BvbnNlLnVzYWdlLnByb21wdF90b2tlbnMpICE9IG51bGwgPyBfYyA6IDApICsgKChfZCA9IHJlc3BvbnNlLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zKSAhPSBudWxsID8gX2QgOiAwKSxcbiAgICAgIHJlYXNvbmluZ1Rva2VuczogKF9mID0gKF9lID0gcmVzcG9uc2UudXNhZ2UuY29tcGxldGlvbl90b2tlbnNfZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLnJlYXNvbmluZ190b2tlbnMpICE9IG51bGwgPyBfZiA6IDAsXG4gICAgICBjYWNoZWRJbnB1dFRva2VuczogKF9oID0gKF9nID0gcmVzcG9uc2UudXNhZ2UucHJvbXB0X3Rva2Vuc19kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2cuY2FjaGVkX3Rva2VucykgIT0gbnVsbCA/IF9oIDogMFxuICAgIH0gOiB7XG4gICAgICBpbnB1dFRva2VuczogMCxcbiAgICAgIG91dHB1dFRva2VuczogMCxcbiAgICAgIHRvdGFsVG9rZW5zOiAwLFxuICAgICAgcmVhc29uaW5nVG9rZW5zOiAwLFxuICAgICAgY2FjaGVkSW5wdXRUb2tlbnM6IDBcbiAgICB9O1xuICAgIGNvbnN0IHJlYXNvbmluZ0RldGFpbHMgPSAoX2kgPSBjaG9pY2UubWVzc2FnZS5yZWFzb25pbmdfZGV0YWlscykgIT0gbnVsbCA/IF9pIDogW107XG4gICAgY29uc3QgcmVhc29uaW5nID0gcmVhc29uaW5nRGV0YWlscy5sZW5ndGggPiAwID8gcmVhc29uaW5nRGV0YWlscy5tYXAoKGRldGFpbCkgPT4ge1xuICAgICAgc3dpdGNoIChkZXRhaWwudHlwZSkge1xuICAgICAgICBjYXNlIFwicmVhc29uaW5nLnRleHRcIiAvKiBUZXh0ICovOiB7XG4gICAgICAgICAgaWYgKGRldGFpbC50ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgICB0ZXh0OiBkZXRhaWwudGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInJlYXNvbmluZy5zdW1tYXJ5XCIgLyogU3VtbWFyeSAqLzoge1xuICAgICAgICAgIGlmIChkZXRhaWwuc3VtbWFyeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICAgICAgdGV4dDogZGV0YWlsLnN1bW1hcnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyZWFzb25pbmcuZW5jcnlwdGVkXCIgLyogRW5jcnlwdGVkICovOiB7XG4gICAgICAgICAgaWYgKGRldGFpbC5kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgICB0ZXh0OiBcIltSRURBQ1RFRF1cIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGRldGFpbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSkuZmlsdGVyKChwKSA9PiBwICE9PSBudWxsKSA6IGNob2ljZS5tZXNzYWdlLnJlYXNvbmluZyA/IFtcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgdGV4dDogY2hvaWNlLm1lc3NhZ2UucmVhc29uaW5nXG4gICAgICB9XG4gICAgXSA6IFtdO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBbXTtcbiAgICBjb250ZW50LnB1c2goLi4ucmVhc29uaW5nKTtcbiAgICBpZiAoY2hvaWNlLm1lc3NhZ2UuY29udGVudCkge1xuICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgIHRleHQ6IGNob2ljZS5tZXNzYWdlLmNvbnRlbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoY2hvaWNlLm1lc3NhZ2UudG9vbF9jYWxscykge1xuICAgICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiBjaG9pY2UubWVzc2FnZS50b29sX2NhbGxzKSB7XG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICB0b29sQ2FsbElkOiAoX2ogPSB0b29sQ2FsbC5pZCkgIT0gbnVsbCA/IF9qIDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgIGlucHV0OiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaG9pY2UubWVzc2FnZS5pbWFnZXMpIHtcbiAgICAgIGZvciAoY29uc3QgaW1hZ2Ugb2YgY2hvaWNlLm1lc3NhZ2UuaW1hZ2VzKSB7XG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgbWVkaWFUeXBlOiBnZXRNZWRpYVR5cGUoaW1hZ2UuaW1hZ2VfdXJsLnVybCwgXCJpbWFnZS9qcGVnXCIpLFxuICAgICAgICAgIGRhdGE6IGdldEJhc2U2NEZyb21EYXRhVXJsKGltYWdlLmltYWdlX3VybC51cmwpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2hvaWNlLm1lc3NhZ2UuYW5ub3RhdGlvbnMpIHtcbiAgICAgIGZvciAoY29uc3QgYW5ub3RhdGlvbiBvZiBjaG9pY2UubWVzc2FnZS5hbm5vdGF0aW9ucykge1xuICAgICAgICBpZiAoYW5ub3RhdGlvbi50eXBlID09PSBcInVybF9jaXRhdGlvblwiKSB7XG4gICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwic291cmNlXCIsXG4gICAgICAgICAgICBzb3VyY2VUeXBlOiBcInVybFwiLFxuICAgICAgICAgICAgaWQ6IGFubm90YXRpb24udXJsX2NpdGF0aW9uLnVybCxcbiAgICAgICAgICAgIHVybDogYW5ub3RhdGlvbi51cmxfY2l0YXRpb24udXJsLFxuICAgICAgICAgICAgdGl0bGU6IGFubm90YXRpb24udXJsX2NpdGF0aW9uLnRpdGxlLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YToge1xuICAgICAgICAgICAgICBvcGVucm91dGVyOiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogYW5ub3RhdGlvbi51cmxfY2l0YXRpb24uY29udGVudCB8fCBcIlwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudCxcbiAgICAgIGZpbmlzaFJlYXNvbjogbWFwT3BlblJvdXRlckZpbmlzaFJlYXNvbihjaG9pY2UuZmluaXNoX3JlYXNvbiksXG4gICAgICB1c2FnZTogdXNhZ2VJbmZvLFxuICAgICAgd2FybmluZ3M6IFtdLFxuICAgICAgcHJvdmlkZXJNZXRhZGF0YToge1xuICAgICAgICBvcGVucm91dGVyOiB7XG4gICAgICAgICAgcHJvdmlkZXI6IChfayA9IHJlc3BvbnNlLnByb3ZpZGVyKSAhPSBudWxsID8gX2sgOiBcIlwiLFxuICAgICAgICAgIHVzYWdlOiB7XG4gICAgICAgICAgICBwcm9tcHRUb2tlbnM6IChfbCA9IHVzYWdlSW5mby5pbnB1dFRva2VucykgIT0gbnVsbCA/IF9sIDogMCxcbiAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IChfbSA9IHVzYWdlSW5mby5vdXRwdXRUb2tlbnMpICE9IG51bGwgPyBfbSA6IDAsXG4gICAgICAgICAgICB0b3RhbFRva2VuczogKF9uID0gdXNhZ2VJbmZvLnRvdGFsVG9rZW5zKSAhPSBudWxsID8gX24gOiAwLFxuICAgICAgICAgICAgY29zdDogKF9vID0gcmVzcG9uc2UudXNhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfby5jb3N0LFxuICAgICAgICAgICAgcHJvbXB0VG9rZW5zRGV0YWlsczoge1xuICAgICAgICAgICAgICBjYWNoZWRUb2tlbnM6IChfciA9IChfcSA9IChfcCA9IHJlc3BvbnNlLnVzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX3AucHJvbXB0X3Rva2Vuc19kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX3EuY2FjaGVkX3Rva2VucykgIT0gbnVsbCA/IF9yIDogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnNEZXRhaWxzOiB7XG4gICAgICAgICAgICAgIHJlYXNvbmluZ1Rva2VuczogKF91ID0gKF90ID0gKF9zID0gcmVzcG9uc2UudXNhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfcy5jb21wbGV0aW9uX3Rva2Vuc19kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX3QucmVhc29uaW5nX3Rva2VucykgIT0gbnVsbCA/IF91IDogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvc3REZXRhaWxzOiB7XG4gICAgICAgICAgICAgIHVwc3RyZWFtSW5mZXJlbmNlQ29zdDogKF94ID0gKF93ID0gKF92ID0gcmVzcG9uc2UudXNhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfdi5jb3N0X2RldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfdy51cHN0cmVhbV9pbmZlcmVuY2VfY29zdCkgIT0gbnVsbCA/IF94IDogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlcXVlc3Q6IHsgYm9keTogYXJncyB9LFxuICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgaWQ6IHJlc3BvbnNlLmlkLFxuICAgICAgICBtb2RlbElkOiByZXNwb25zZS5tb2RlbCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBhc3luYyBkb1N0cmVhbShvcHRpb25zKSB7XG4gICAgdmFyIF9hMTU7XG4gICAgY29uc3QgcHJvdmlkZXJPcHRpb25zID0gb3B0aW9ucy5wcm92aWRlck9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgb3BlbnJvdXRlck9wdGlvbnMgPSBwcm92aWRlck9wdGlvbnMub3BlbnJvdXRlciB8fCB7fTtcbiAgICBjb25zdCBhcmdzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuZ2V0QXJncyhvcHRpb25zKSksIG9wZW5yb3V0ZXJPcHRpb25zKTtcbiAgICBjb25zdCB7IHZhbHVlOiByZXNwb25zZSwgcmVzcG9uc2VIZWFkZXJzIH0gPSBhd2FpdCBwb3N0SnNvblRvQXBpKHtcbiAgICAgIHVybDogdGhpcy5jb25maWcudXJsKHtcbiAgICAgICAgcGF0aDogXCIvY2hhdC9jb21wbGV0aW9uc1wiLFxuICAgICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWRcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogY29tYmluZUhlYWRlcnModGhpcy5jb25maWcuaGVhZGVycygpLCBvcHRpb25zLmhlYWRlcnMpLFxuICAgICAgYm9keTogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYXJncyksIHtcbiAgICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgICAvLyBvbmx5IGluY2x1ZGUgc3RyZWFtX29wdGlvbnMgd2hlbiBpbiBzdHJpY3QgY29tcGF0aWJpbGl0eSBtb2RlOlxuICAgICAgICBzdHJlYW1fb3B0aW9uczogdGhpcy5jb25maWcuY29tcGF0aWJpbGl0eSA9PT0gXCJzdHJpY3RcIiA/IF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgICAgICBpbmNsdWRlX3VzYWdlOiB0cnVlXG4gICAgICAgIH0sICgoX2ExNSA9IHRoaXMuc2V0dGluZ3MudXNhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTE1LmluY2x1ZGUpID8geyBpbmNsdWRlX3VzYWdlOiB0cnVlIH0gOiB7fSkgOiB2b2lkIDBcbiAgICAgIH0pLFxuICAgICAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyOiBvcGVucm91dGVyRmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICAgICAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcjogY3JlYXRlRXZlbnRTb3VyY2VSZXNwb25zZUhhbmRsZXIoXG4gICAgICAgIE9wZW5Sb3V0ZXJTdHJlYW1DaGF0Q29tcGxldGlvbkNodW5rU2NoZW1hXG4gICAgICApLFxuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICBmZXRjaDogdGhpcy5jb25maWcuZmV0Y2hcbiAgICB9KTtcbiAgICBjb25zdCB0b29sQ2FsbHMgPSBbXTtcbiAgICBsZXQgZmluaXNoUmVhc29uID0gXCJvdGhlclwiO1xuICAgIGNvbnN0IHVzYWdlID0ge1xuICAgICAgaW5wdXRUb2tlbnM6IE51bWJlci5OYU4sXG4gICAgICBvdXRwdXRUb2tlbnM6IE51bWJlci5OYU4sXG4gICAgICB0b3RhbFRva2VuczogTnVtYmVyLk5hTixcbiAgICAgIHJlYXNvbmluZ1Rva2VuczogTnVtYmVyLk5hTixcbiAgICAgIGNhY2hlZElucHV0VG9rZW5zOiBOdW1iZXIuTmFOXG4gICAgfTtcbiAgICBjb25zdCBvcGVucm91dGVyVXNhZ2UgPSB7fTtcbiAgICBsZXQgdGV4dFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBsZXQgcmVhc29uaW5nU3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCB0ZXh0SWQ7XG4gICAgbGV0IHJlYXNvbmluZ0lkO1xuICAgIGxldCBvcGVucm91dGVyUmVzcG9uc2VJZDtcbiAgICBsZXQgcHJvdmlkZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmVhbTogcmVzcG9uc2UucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgdmFyIF9hMTYsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaSwgX2osIF9rLCBfbCwgX20sIF9uO1xuICAgICAgICAgICAgaWYgKCFjaHVuay5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgIGZpbmlzaFJlYXNvbiA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvcjogY2h1bmsuZXJyb3IgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2h1bmsudmFsdWU7XG4gICAgICAgICAgICBpZiAoXCJlcnJvclwiIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgIGZpbmlzaFJlYXNvbiA9IFwiZXJyb3JcIjtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvcjogdmFsdWUuZXJyb3IgfSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS5wcm92aWRlcikge1xuICAgICAgICAgICAgICBwcm92aWRlciA9IHZhbHVlLnByb3ZpZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLmlkKSB7XG4gICAgICAgICAgICAgIG9wZW5yb3V0ZXJSZXNwb25zZUlkID0gdmFsdWUuaWQ7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZXNwb25zZS1tZXRhZGF0YVwiLFxuICAgICAgICAgICAgICAgIGlkOiB2YWx1ZS5pZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS5tb2RlbCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVzcG9uc2UtbWV0YWRhdGFcIixcbiAgICAgICAgICAgICAgICBtb2RlbElkOiB2YWx1ZS5tb2RlbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS51c2FnZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHVzYWdlLmlucHV0VG9rZW5zID0gdmFsdWUudXNhZ2UucHJvbXB0X3Rva2VucztcbiAgICAgICAgICAgICAgdXNhZ2Uub3V0cHV0VG9rZW5zID0gdmFsdWUudXNhZ2UuY29tcGxldGlvbl90b2tlbnM7XG4gICAgICAgICAgICAgIHVzYWdlLnRvdGFsVG9rZW5zID0gdmFsdWUudXNhZ2UucHJvbXB0X3Rva2VucyArIHZhbHVlLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zO1xuICAgICAgICAgICAgICBvcGVucm91dGVyVXNhZ2UucHJvbXB0VG9rZW5zID0gdmFsdWUudXNhZ2UucHJvbXB0X3Rva2VucztcbiAgICAgICAgICAgICAgaWYgKHZhbHVlLnVzYWdlLnByb21wdF90b2tlbnNfZGV0YWlscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZElucHV0VG9rZW5zID0gKF9hMTYgPSB2YWx1ZS51c2FnZS5wcm9tcHRfdG9rZW5zX2RldGFpbHMuY2FjaGVkX3Rva2VucykgIT0gbnVsbCA/IF9hMTYgOiAwO1xuICAgICAgICAgICAgICAgIHVzYWdlLmNhY2hlZElucHV0VG9rZW5zID0gY2FjaGVkSW5wdXRUb2tlbnM7XG4gICAgICAgICAgICAgICAgb3BlbnJvdXRlclVzYWdlLnByb21wdFRva2Vuc0RldGFpbHMgPSB7XG4gICAgICAgICAgICAgICAgICBjYWNoZWRUb2tlbnM6IGNhY2hlZElucHV0VG9rZW5zXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcGVucm91dGVyVXNhZ2UuY29tcGxldGlvblRva2VucyA9IHZhbHVlLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zO1xuICAgICAgICAgICAgICBpZiAodmFsdWUudXNhZ2UuY29tcGxldGlvbl90b2tlbnNfZGV0YWlscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYXNvbmluZ1Rva2VucyA9IChfYiA9IHZhbHVlLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zX2RldGFpbHMucmVhc29uaW5nX3Rva2VucykgIT0gbnVsbCA/IF9iIDogMDtcbiAgICAgICAgICAgICAgICB1c2FnZS5yZWFzb25pbmdUb2tlbnMgPSByZWFzb25pbmdUb2tlbnM7XG4gICAgICAgICAgICAgICAgb3BlbnJvdXRlclVzYWdlLmNvbXBsZXRpb25Ub2tlbnNEZXRhaWxzID0ge1xuICAgICAgICAgICAgICAgICAgcmVhc29uaW5nVG9rZW5zXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcGVucm91dGVyVXNhZ2UuY29zdCA9IHZhbHVlLnVzYWdlLmNvc3Q7XG4gICAgICAgICAgICAgIG9wZW5yb3V0ZXJVc2FnZS50b3RhbFRva2VucyA9IHZhbHVlLnVzYWdlLnRvdGFsX3Rva2VucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNob2ljZSA9IHZhbHVlLmNob2ljZXNbMF07XG4gICAgICAgICAgICBpZiAoKGNob2ljZSA9PSBudWxsID8gdm9pZCAwIDogY2hvaWNlLmZpbmlzaF9yZWFzb24pICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gbWFwT3BlblJvdXRlckZpbmlzaFJlYXNvbihjaG9pY2UuZmluaXNoX3JlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGNob2ljZSA9PSBudWxsID8gdm9pZCAwIDogY2hvaWNlLmRlbHRhKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gY2hvaWNlLmRlbHRhO1xuICAgICAgICAgICAgY29uc3QgZW1pdFJlYXNvbmluZ0NodW5rID0gKGNodW5rVGV4dCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXJlYXNvbmluZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICByZWFzb25pbmdJZCA9IG9wZW5yb3V0ZXJSZXNwb25zZUlkIHx8IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctc3RhcnRcIixcbiAgICAgICAgICAgICAgICAgIGlkOiByZWFzb25pbmdJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlYXNvbmluZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctZGVsdGFcIixcbiAgICAgICAgICAgICAgICBkZWx0YTogY2h1bmtUZXh0LFxuICAgICAgICAgICAgICAgIGlkOiByZWFzb25pbmdJZCB8fCBnZW5lcmF0ZUlkKClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGRlbHRhLnJlYXNvbmluZ19kZXRhaWxzICYmIGRlbHRhLnJlYXNvbmluZ19kZXRhaWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBkZXRhaWwgb2YgZGVsdGEucmVhc29uaW5nX2RldGFpbHMpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRldGFpbC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLnRleHRcIiAvKiBUZXh0ICovOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXRhaWwudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGVtaXRSZWFzb25pbmdDaHVuayhkZXRhaWwudGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLmVuY3J5cHRlZFwiIC8qIEVuY3J5cHRlZCAqLzoge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGV0YWlsLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlbWl0UmVhc29uaW5nQ2h1bmsoXCJbUkVEQUNURURdXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy5zdW1tYXJ5XCIgLyogU3VtbWFyeSAqLzoge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGV0YWlsLnN1bW1hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBlbWl0UmVhc29uaW5nQ2h1bmsoZGV0YWlsLnN1bW1hcnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICBkZXRhaWw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChkZWx0YS5yZWFzb25pbmcpIHtcbiAgICAgICAgICAgICAgZW1pdFJlYXNvbmluZ0NodW5rKGRlbHRhLnJlYXNvbmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVsdGEuY29udGVudCkge1xuICAgICAgICAgICAgICBpZiAocmVhc29uaW5nU3RhcnRlZCAmJiAhdGV4dFN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctZW5kXCIsXG4gICAgICAgICAgICAgICAgICBpZDogcmVhc29uaW5nSWQgfHwgZ2VuZXJhdGVJZCgpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVhc29uaW5nU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghdGV4dFN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0SWQgPSBvcGVucm91dGVyUmVzcG9uc2VJZCB8fCBnZW5lcmF0ZUlkKCk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1zdGFydFwiLFxuICAgICAgICAgICAgICAgICAgaWQ6IHRleHRJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRleHRTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgIGRlbHRhOiBkZWx0YS5jb250ZW50LFxuICAgICAgICAgICAgICAgIGlkOiB0ZXh0SWQgfHwgZ2VuZXJhdGVJZCgpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbHRhLmFubm90YXRpb25zKSB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgYW5ub3RhdGlvbiBvZiBkZWx0YS5hbm5vdGF0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChhbm5vdGF0aW9uLnR5cGUgPT09IFwidXJsX2NpdGF0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic291cmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVR5cGU6IFwidXJsXCIsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBhbm5vdGF0aW9uLnVybF9jaXRhdGlvbi51cmwsXG4gICAgICAgICAgICAgICAgICAgIHVybDogYW5ub3RhdGlvbi51cmxfY2l0YXRpb24udXJsLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogYW5ub3RhdGlvbi51cmxfY2l0YXRpb24udGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvcGVucm91dGVyOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBhbm5vdGF0aW9uLnVybF9jaXRhdGlvbi5jb250ZW50IHx8IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlbHRhLnRvb2xfY2FsbHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsRGVsdGEgb2YgZGVsdGEudG9vbF9jYWxscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gKF9jID0gdG9vbENhbGxEZWx0YS5pbmRleCkgIT0gbnVsbCA/IF9jIDogdG9vbENhbGxzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2xDYWxsc1tpbmRleF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRvb2xDYWxsRGVsdGEudHlwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRvb2xDYWxsRGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkICdmdW5jdGlvbicgdHlwZS5gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRvb2xDYWxsRGVsdGEuaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0b29sQ2FsbERlbHRhLFxuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCAnaWQnIHRvIGJlIGEgc3RyaW5nLmBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoKChfZCA9IHRvb2xDYWxsRGVsdGEuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZC5uYW1lKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRvb2xDYWxsRGVsdGEsXG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEV4cGVjdGVkICdmdW5jdGlvbi5uYW1lJyB0byBiZSBhIHN0cmluZy5gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxzW2luZGV4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRvb2xDYWxsRGVsdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sQ2FsbERlbHRhLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiAoX2UgPSB0b29sQ2FsbERlbHRhLmZ1bmN0aW9uLmFyZ3VtZW50cykgIT0gbnVsbCA/IF9lIDogXCJcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBpbnB1dFN0YXJ0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBzZW50OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsMiA9IHRvb2xDYWxsc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICBpZiAodG9vbENhbGwyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vbCBjYWxsIGlzIG1pc3NpbmdcIik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoKChfZiA9IHRvb2xDYWxsMi5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLm5hbWUpICE9IG51bGwgJiYgKChfZyA9IHRvb2xDYWxsMi5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLmFyZ3VtZW50cykgIT0gbnVsbCAmJiBpc1BhcnNhYmxlSnNvbih0b29sQ2FsbDIuZnVuY3Rpb24uYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbDIuaW5wdXRTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtaW5wdXQtc3RhcnRcIixcbiAgICAgICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwyLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbDIuZnVuY3Rpb24ubmFtZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtaW5wdXQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwyLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhOiB0b29sQ2FsbDIuZnVuY3Rpb24uYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1pbnB1dC1lbmRcIixcbiAgICAgICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwyLmlkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwyLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbDIuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogdG9vbENhbGwyLmZ1bmN0aW9uLmFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGwyLnNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsID0gdG9vbENhbGxzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAodG9vbENhbGwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vbCBjYWxsIGlzIG1pc3NpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdG9vbENhbGwuaW5wdXRTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbC5pbnB1dFN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWlucHV0LXN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWVcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKChfaCA9IHRvb2xDYWxsRGVsdGEuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfaC5hcmd1bWVudHMpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyArPSAoX2ogPSAoX2kgPSB0b29sQ2FsbERlbHRhLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2kuYXJndW1lbnRzKSAhPSBudWxsID8gX2ogOiBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWlucHV0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgICBkZWx0YTogKF9rID0gdG9vbENhbGxEZWx0YS5mdW5jdGlvbi5hcmd1bWVudHMpICE9IG51bGwgPyBfayA6IFwiXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoKChfbCA9IHRvb2xDYWxsLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2wubmFtZSkgIT0gbnVsbCAmJiAoKF9tID0gdG9vbENhbGwuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfbS5hcmd1bWVudHMpICE9IG51bGwgJiYgaXNQYXJzYWJsZUpzb24odG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogKF9uID0gdG9vbENhbGwuaWQpICE9IG51bGwgPyBfbiA6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGwuc2VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVsdGEuaW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBpbWFnZSBvZiBkZWx0YS5pbWFnZXMpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgICAgICAgICBtZWRpYVR5cGU6IGdldE1lZGlhVHlwZShpbWFnZS5pbWFnZV91cmwudXJsLCBcImltYWdlL2pwZWdcIiksXG4gICAgICAgICAgICAgICAgICBkYXRhOiBnZXRCYXNlNjRGcm9tRGF0YVVybChpbWFnZS5pbWFnZV91cmwudXJsKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICB2YXIgX2ExNjtcbiAgICAgICAgICAgIGlmIChmaW5pc2hSZWFzb24gPT09IFwidG9vbC1jYWxsc1wiKSB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2YgdG9vbENhbGxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2xDYWxsICYmICF0b29sQ2FsbC5zZW50KSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiAoX2ExNiA9IHRvb2xDYWxsLmlkKSAhPSBudWxsID8gX2ExNiA6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSBpbnZhbGlkIGFyZ3VtZW50cyB0byBhbiBlbXB0eSBKU09OIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogaXNQYXJzYWJsZUpzb24odG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzKSA/IHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyA6IFwie31cIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbC5zZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWFzb25pbmdTdGFydGVkKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctZW5kXCIsXG4gICAgICAgICAgICAgICAgaWQ6IHJlYXNvbmluZ0lkIHx8IGdlbmVyYXRlSWQoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXh0U3RhcnRlZCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1lbmRcIixcbiAgICAgICAgICAgICAgICBpZDogdGV4dElkIHx8IGdlbmVyYXRlSWQoKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wZW5yb3V0ZXJNZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgdXNhZ2U6IG9wZW5yb3V0ZXJVc2FnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwcm92aWRlciAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIG9wZW5yb3V0ZXJNZXRhZGF0YS5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJmaW5pc2hcIixcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIG9wZW5yb3V0ZXI6IG9wZW5yb3V0ZXJNZXRhZGF0YVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAgd2FybmluZ3M6IFtdLFxuICAgICAgcmVxdWVzdDogeyBib2R5OiBhcmdzIH0sXG4gICAgICByZXNwb25zZTogeyBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMgfVxuICAgIH07XG4gIH1cbn07XG5cbi8vIHNyYy9jb21wbGV0aW9uL2NvbnZlcnQtdG8tb3BlbnJvdXRlci1jb21wbGV0aW9uLXByb21wdC50c1xuZnVuY3Rpb24gY29udmVydFRvT3BlblJvdXRlckNvbXBsZXRpb25Qcm9tcHQoe1xuICBwcm9tcHQsXG4gIGlucHV0Rm9ybWF0LFxuICB1c2VyID0gXCJ1c2VyXCIsXG4gIGFzc2lzdGFudCA9IFwiYXNzaXN0YW50XCJcbn0pIHtcbiAgaWYgKGlucHV0Rm9ybWF0ID09PSBcInByb21wdFwiICYmIHByb21wdC5sZW5ndGggPT09IDEgJiYgcHJvbXB0WzBdICYmIHByb21wdFswXS5yb2xlID09PSBcInVzZXJcIiAmJiBwcm9tcHRbMF0uY29udGVudC5sZW5ndGggPT09IDEgJiYgcHJvbXB0WzBdLmNvbnRlbnRbMF0gJiYgcHJvbXB0WzBdLmNvbnRlbnRbMF0udHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICByZXR1cm4geyBwcm9tcHQ6IHByb21wdFswXS5jb250ZW50WzBdLnRleHQgfTtcbiAgfVxuICBsZXQgdGV4dCA9IFwiXCI7XG4gIGlmIChwcm9tcHRbMF0gJiYgcHJvbXB0WzBdLnJvbGUgPT09IFwic3lzdGVtXCIpIHtcbiAgICB0ZXh0ICs9IGAke3Byb21wdFswXS5jb250ZW50fVxuXG5gO1xuICAgIHByb21wdCA9IHByb21wdC5zbGljZSgxKTtcbiAgfVxuICBmb3IgKGNvbnN0IHsgcm9sZSwgY29udGVudCB9IG9mIHByb21wdCkge1xuICAgIHN3aXRjaCAocm9sZSkge1xuICAgICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IGBVbmV4cGVjdGVkIHN5c3RlbSBtZXNzYWdlIGluIHByb21wdDogJHtjb250ZW50fWAsXG4gICAgICAgICAgcHJvbXB0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICBjb25zdCB1c2VyTWVzc2FnZSA9IGNvbnRlbnQubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yKHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcImZpbGUgYXR0YWNobWVudHNcIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KS5qb2luKFwiXCIpO1xuICAgICAgICB0ZXh0ICs9IGAke3VzZXJ9OlxuJHt1c2VyTWVzc2FnZX1cblxuYDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgICAgY29uc3QgYXNzaXN0YW50TWVzc2FnZSA9IGNvbnRlbnQubWFwKFxuICAgICAgICAgIChwYXJ0KSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQudGV4dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgZnVuY3Rpb25hbGl0eTogXCJ0b29sLWNhbGwgbWVzc2FnZXNcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yKHtcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwidG9vbC1yZXN1bHQgbWVzc2FnZXNcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmdcIjoge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcInJlYXNvbmluZyBtZXNzYWdlc1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbmFsaXR5OiBcImZpbGUgYXR0YWNobWVudHNcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKS5qb2luKFwiXCIpO1xuICAgICAgICB0ZXh0ICs9IGAke2Fzc2lzdGFudH06XG4ke2Fzc2lzdGFudE1lc3NhZ2V9XG5cbmA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwidG9vbCBtZXNzYWdlc1wiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGV4dCArPSBgJHthc3Npc3RhbnR9OlxuYDtcbiAgcmV0dXJuIHtcbiAgICBwcm9tcHQ6IHRleHRcbiAgfTtcbn1cblxuLy8gc3JjL2NvbXBsZXRpb24vc2NoZW1hcy50c1xuaW1wb3J0IHsgeiBhcyB6NyB9IGZyb20gXCJ6b2QvdjRcIjtcbnZhciBPcGVuUm91dGVyQ29tcGxldGlvbkNodW5rU2NoZW1hID0gejcudW5pb24oW1xuICB6Ny5vYmplY3Qoe1xuICAgIGlkOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIG1vZGVsOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGNob2ljZXM6IHo3LmFycmF5KFxuICAgICAgejcub2JqZWN0KHtcbiAgICAgICAgdGV4dDogejcuc3RyaW5nKCksXG4gICAgICAgIHJlYXNvbmluZzogejcuc3RyaW5nKCkubnVsbGlzaCgpLm9wdGlvbmFsKCksXG4gICAgICAgIHJlYXNvbmluZ19kZXRhaWxzOiBSZWFzb25pbmdEZXRhaWxBcnJheVNjaGVtYS5udWxsaXNoKCksXG4gICAgICAgIGZpbmlzaF9yZWFzb246IHo3LnN0cmluZygpLm51bGxpc2goKSxcbiAgICAgICAgaW5kZXg6IHo3Lm51bWJlcigpLm51bGxpc2goKSxcbiAgICAgICAgbG9ncHJvYnM6IHo3Lm9iamVjdCh7XG4gICAgICAgICAgdG9rZW5zOiB6Ny5hcnJheSh6Ny5zdHJpbmcoKSksXG4gICAgICAgICAgdG9rZW5fbG9ncHJvYnM6IHo3LmFycmF5KHo3Lm51bWJlcigpKSxcbiAgICAgICAgICB0b3BfbG9ncHJvYnM6IHo3LmFycmF5KHo3LnJlY29yZCh6Ny5zdHJpbmcoKSwgejcubnVtYmVyKCkpKS5udWxsYWJsZSgpXG4gICAgICAgIH0pLm51bGxhYmxlKCkub3B0aW9uYWwoKVxuICAgICAgfSlcbiAgICApLFxuICAgIHVzYWdlOiB6Ny5vYmplY3Qoe1xuICAgICAgcHJvbXB0X3Rva2VuczogejcubnVtYmVyKCksXG4gICAgICBwcm9tcHRfdG9rZW5zX2RldGFpbHM6IHo3Lm9iamVjdCh7XG4gICAgICAgIGNhY2hlZF90b2tlbnM6IHo3Lm51bWJlcigpXG4gICAgICB9KS5udWxsaXNoKCksXG4gICAgICBjb21wbGV0aW9uX3Rva2VuczogejcubnVtYmVyKCksXG4gICAgICBjb21wbGV0aW9uX3Rva2Vuc19kZXRhaWxzOiB6Ny5vYmplY3Qoe1xuICAgICAgICByZWFzb25pbmdfdG9rZW5zOiB6Ny5udW1iZXIoKVxuICAgICAgfSkubnVsbGlzaCgpLFxuICAgICAgdG90YWxfdG9rZW5zOiB6Ny5udW1iZXIoKSxcbiAgICAgIGNvc3Q6IHo3Lm51bWJlcigpLm9wdGlvbmFsKClcbiAgICB9KS5udWxsaXNoKClcbiAgfSksXG4gIE9wZW5Sb3V0ZXJFcnJvclJlc3BvbnNlU2NoZW1hXG5dKTtcblxuLy8gc3JjL2NvbXBsZXRpb24vaW5kZXgudHNcbnZhciBPcGVuUm91dGVyQ29tcGxldGlvbkxhbmd1YWdlTW9kZWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG1vZGVsSWQsIHNldHRpbmdzLCBjb25maWcpIHtcbiAgICB0aGlzLnNwZWNpZmljYXRpb25WZXJzaW9uID0gXCJ2MlwiO1xuICAgIHRoaXMucHJvdmlkZXIgPSBcIm9wZW5yb3V0ZXJcIjtcbiAgICB0aGlzLnN1cHBvcnRlZFVybHMgPSB7XG4gICAgICBcImltYWdlLypcIjogW1xuICAgICAgICAvXmRhdGE6aW1hZ2VcXC9bYS16QS1aXSs7YmFzZTY0LC8sXG4gICAgICAgIC9eaHR0cHM/OlxcL1xcLy4rXFwuKGpwZ3xqcGVnfHBuZ3xnaWZ8d2VicCkkL2lcbiAgICAgIF0sXG4gICAgICBcInRleHQvKlwiOiBbL15kYXRhOnRleHRcXC8vLCAvXmh0dHBzPzpcXC9cXC8uKyQvXSxcbiAgICAgIFwiYXBwbGljYXRpb24vKlwiOiBbL15kYXRhOmFwcGxpY2F0aW9uXFwvLywgL15odHRwcz86XFwvXFwvLiskL11cbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdE9iamVjdEdlbmVyYXRpb25Nb2RlID0gdm9pZCAwO1xuICAgIHRoaXMubW9kZWxJZCA9IG1vZGVsSWQ7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICB9XG4gIGdldEFyZ3Moe1xuICAgIHByb21wdCxcbiAgICBtYXhPdXRwdXRUb2tlbnMsXG4gICAgdGVtcGVyYXR1cmUsXG4gICAgdG9wUCxcbiAgICBmcmVxdWVuY3lQZW5hbHR5LFxuICAgIHByZXNlbmNlUGVuYWx0eSxcbiAgICBzZWVkLFxuICAgIHJlc3BvbnNlRm9ybWF0LFxuICAgIHRvcEssXG4gICAgc3RvcFNlcXVlbmNlcyxcbiAgICB0b29scyxcbiAgICB0b29sQ2hvaWNlXG4gIH0pIHtcbiAgICBjb25zdCB7IHByb21wdDogY29tcGxldGlvblByb21wdCB9ID0gY29udmVydFRvT3BlblJvdXRlckNvbXBsZXRpb25Qcm9tcHQoe1xuICAgICAgcHJvbXB0LFxuICAgICAgaW5wdXRGb3JtYXQ6IFwicHJvbXB0XCJcbiAgICB9KTtcbiAgICBpZiAodG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yKHtcbiAgICAgICAgZnVuY3Rpb25hbGl0eTogXCJ0b29sc1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRvb2xDaG9pY2UpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwidG9vbENob2ljZVwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHtcbiAgICAgIC8vIG1vZGVsIGlkOlxuICAgICAgbW9kZWw6IHRoaXMubW9kZWxJZCxcbiAgICAgIG1vZGVsczogdGhpcy5zZXR0aW5ncy5tb2RlbHMsXG4gICAgICAvLyBtb2RlbCBzcGVjaWZpYyBzZXR0aW5nczpcbiAgICAgIGxvZ2l0X2JpYXM6IHRoaXMuc2V0dGluZ3MubG9naXRCaWFzLFxuICAgICAgbG9ncHJvYnM6IHR5cGVvZiB0aGlzLnNldHRpbmdzLmxvZ3Byb2JzID09PSBcIm51bWJlclwiID8gdGhpcy5zZXR0aW5ncy5sb2dwcm9icyA6IHR5cGVvZiB0aGlzLnNldHRpbmdzLmxvZ3Byb2JzID09PSBcImJvb2xlYW5cIiA/IHRoaXMuc2V0dGluZ3MubG9ncHJvYnMgPyAwIDogdm9pZCAwIDogdm9pZCAwLFxuICAgICAgc3VmZml4OiB0aGlzLnNldHRpbmdzLnN1ZmZpeCxcbiAgICAgIHVzZXI6IHRoaXMuc2V0dGluZ3MudXNlcixcbiAgICAgIC8vIHN0YW5kYXJkaXplZCBzZXR0aW5nczpcbiAgICAgIG1heF90b2tlbnM6IG1heE91dHB1dFRva2VucyxcbiAgICAgIHRlbXBlcmF0dXJlLFxuICAgICAgdG9wX3A6IHRvcFAsXG4gICAgICBmcmVxdWVuY3lfcGVuYWx0eTogZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgIHByZXNlbmNlX3BlbmFsdHk6IHByZXNlbmNlUGVuYWx0eSxcbiAgICAgIHNlZWQsXG4gICAgICBzdG9wOiBzdG9wU2VxdWVuY2VzLFxuICAgICAgcmVzcG9uc2VfZm9ybWF0OiByZXNwb25zZUZvcm1hdCxcbiAgICAgIHRvcF9rOiB0b3BLLFxuICAgICAgLy8gcHJvbXB0OlxuICAgICAgcHJvbXB0OiBjb21wbGV0aW9uUHJvbXB0LFxuICAgICAgLy8gT3BlblJvdXRlciBzcGVjaWZpYyBzZXR0aW5nczpcbiAgICAgIGluY2x1ZGVfcmVhc29uaW5nOiB0aGlzLnNldHRpbmdzLmluY2x1ZGVSZWFzb25pbmcsXG4gICAgICByZWFzb25pbmc6IHRoaXMuc2V0dGluZ3MucmVhc29uaW5nXG4gICAgfSwgdGhpcy5jb25maWcuZXh0cmFCb2R5KSwgdGhpcy5zZXR0aW5ncy5leHRyYUJvZHkpO1xuICB9XG4gIGFzeW5jIGRvR2VuZXJhdGUob3B0aW9ucykge1xuICAgIHZhciBfYTE1LCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2ksIF9qLCBfaywgX2wsIF9tLCBfbiwgX287XG4gICAgY29uc3QgcHJvdmlkZXJPcHRpb25zID0gb3B0aW9ucy5wcm92aWRlck9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgb3BlbnJvdXRlck9wdGlvbnMgPSBwcm92aWRlck9wdGlvbnMub3BlbnJvdXRlciB8fCB7fTtcbiAgICBjb25zdCBhcmdzID0gX19zcHJlYWRWYWx1ZXMoX19zcHJlYWRWYWx1ZXMoe30sIHRoaXMuZ2V0QXJncyhvcHRpb25zKSksIG9wZW5yb3V0ZXJPcHRpb25zKTtcbiAgICBjb25zdCB7IHZhbHVlOiByZXNwb25zZSwgcmVzcG9uc2VIZWFkZXJzIH0gPSBhd2FpdCBwb3N0SnNvblRvQXBpKHtcbiAgICAgIHVybDogdGhpcy5jb25maWcudXJsKHtcbiAgICAgICAgcGF0aDogXCIvY29tcGxldGlvbnNcIixcbiAgICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbElkXG4gICAgICB9KSxcbiAgICAgIGhlYWRlcnM6IGNvbWJpbmVIZWFkZXJzKHRoaXMuY29uZmlnLmhlYWRlcnMoKSwgb3B0aW9ucy5oZWFkZXJzKSxcbiAgICAgIGJvZHk6IGFyZ3MsXG4gICAgICBmYWlsZWRSZXNwb25zZUhhbmRsZXI6IG9wZW5yb3V0ZXJGYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gICAgICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyOiBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyKFxuICAgICAgICBPcGVuUm91dGVyQ29tcGxldGlvbkNodW5rU2NoZW1hXG4gICAgICApLFxuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICBmZXRjaDogdGhpcy5jb25maWcuZmV0Y2hcbiAgICB9KTtcbiAgICBpZiAoXCJlcnJvclwiIGluIHJlc3BvbnNlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzcG9uc2UuZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgY29uc3QgY2hvaWNlID0gcmVzcG9uc2UuY2hvaWNlc1swXTtcbiAgICBpZiAoIWNob2ljZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2hvaWNlIGluIE9wZW5Sb3V0ZXIgY29tcGxldGlvbiByZXNwb25zZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgIHRleHQ6IChfYTE1ID0gY2hvaWNlLnRleHQpICE9IG51bGwgPyBfYTE1IDogXCJcIlxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgZmluaXNoUmVhc29uOiBtYXBPcGVuUm91dGVyRmluaXNoUmVhc29uKGNob2ljZS5maW5pc2hfcmVhc29uKSxcbiAgICAgIHVzYWdlOiB7XG4gICAgICAgIGlucHV0VG9rZW5zOiAoX2MgPSAoX2IgPSByZXNwb25zZS51c2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnByb21wdF90b2tlbnMpICE9IG51bGwgPyBfYyA6IDAsXG4gICAgICAgIG91dHB1dFRva2VuczogKF9lID0gKF9kID0gcmVzcG9uc2UudXNhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfZC5jb21wbGV0aW9uX3Rva2VucykgIT0gbnVsbCA/IF9lIDogMCxcbiAgICAgICAgdG90YWxUb2tlbnM6ICgoX2cgPSAoX2YgPSByZXNwb25zZS51c2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnByb21wdF90b2tlbnMpICE9IG51bGwgPyBfZyA6IDApICsgKChfaSA9IChfaCA9IHJlc3BvbnNlLnVzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2guY29tcGxldGlvbl90b2tlbnMpICE9IG51bGwgPyBfaSA6IDApLFxuICAgICAgICByZWFzb25pbmdUb2tlbnM6IChfbCA9IChfayA9IChfaiA9IHJlc3BvbnNlLnVzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2ouY29tcGxldGlvbl90b2tlbnNfZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9rLnJlYXNvbmluZ190b2tlbnMpICE9IG51bGwgPyBfbCA6IDAsXG4gICAgICAgIGNhY2hlZElucHV0VG9rZW5zOiAoX28gPSAoX24gPSAoX20gPSByZXNwb25zZS51c2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tLnByb21wdF90b2tlbnNfZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9uLmNhY2hlZF90b2tlbnMpICE9IG51bGwgPyBfbyA6IDBcbiAgICAgIH0sXG4gICAgICB3YXJuaW5nczogW10sXG4gICAgICByZXNwb25zZToge1xuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnNcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGFzeW5jIGRvU3RyZWFtKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwcm92aWRlck9wdGlvbnMgPSBvcHRpb25zLnByb3ZpZGVyT3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBvcGVucm91dGVyT3B0aW9ucyA9IHByb3ZpZGVyT3B0aW9ucy5vcGVucm91dGVyIHx8IHt9O1xuICAgIGNvbnN0IGFyZ3MgPSBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgdGhpcy5nZXRBcmdzKG9wdGlvbnMpKSwgb3BlbnJvdXRlck9wdGlvbnMpO1xuICAgIGNvbnN0IHsgdmFsdWU6IHJlc3BvbnNlLCByZXNwb25zZUhlYWRlcnMgfSA9IGF3YWl0IHBvc3RKc29uVG9BcGkoe1xuICAgICAgdXJsOiB0aGlzLmNvbmZpZy51cmwoe1xuICAgICAgICBwYXRoOiBcIi9jb21wbGV0aW9uc1wiLFxuICAgICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWRcbiAgICAgIH0pLFxuICAgICAgaGVhZGVyczogY29tYmluZUhlYWRlcnModGhpcy5jb25maWcuaGVhZGVycygpLCBvcHRpb25zLmhlYWRlcnMpLFxuICAgICAgYm9keTogX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgYXJncyksIHtcbiAgICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgICAvLyBvbmx5IGluY2x1ZGUgc3RyZWFtX29wdGlvbnMgd2hlbiBpbiBzdHJpY3QgY29tcGF0aWJpbGl0eSBtb2RlOlxuICAgICAgICBzdHJlYW1fb3B0aW9uczogdGhpcy5jb25maWcuY29tcGF0aWJpbGl0eSA9PT0gXCJzdHJpY3RcIiA/IHsgaW5jbHVkZV91c2FnZTogdHJ1ZSB9IDogdm9pZCAwXG4gICAgICB9KSxcbiAgICAgIGZhaWxlZFJlc3BvbnNlSGFuZGxlcjogb3BlbnJvdXRlckZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgICAgIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXI6IGNyZWF0ZUV2ZW50U291cmNlUmVzcG9uc2VIYW5kbGVyKFxuICAgICAgICBPcGVuUm91dGVyQ29tcGxldGlvbkNodW5rU2NoZW1hXG4gICAgICApLFxuICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICBmZXRjaDogdGhpcy5jb25maWcuZmV0Y2hcbiAgICB9KTtcbiAgICBsZXQgZmluaXNoUmVhc29uID0gXCJvdGhlclwiO1xuICAgIGNvbnN0IHVzYWdlID0ge1xuICAgICAgaW5wdXRUb2tlbnM6IE51bWJlci5OYU4sXG4gICAgICBvdXRwdXRUb2tlbnM6IE51bWJlci5OYU4sXG4gICAgICB0b3RhbFRva2VuczogTnVtYmVyLk5hTixcbiAgICAgIHJlYXNvbmluZ1Rva2VuczogTnVtYmVyLk5hTixcbiAgICAgIGNhY2hlZElucHV0VG9rZW5zOiBOdW1iZXIuTmFOXG4gICAgfTtcbiAgICBjb25zdCBvcGVucm91dGVyVXNhZ2UgPSB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RyZWFtOiByZXNwb25zZS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICB2YXIgX2ExNSwgX2I7XG4gICAgICAgICAgICBpZiAoIWNodW5rLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yOiBjaHVuay5lcnJvciB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjaHVuay52YWx1ZTtcbiAgICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yOiB2YWx1ZS5lcnJvciB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLnVzYWdlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdXNhZ2UuaW5wdXRUb2tlbnMgPSB2YWx1ZS51c2FnZS5wcm9tcHRfdG9rZW5zO1xuICAgICAgICAgICAgICB1c2FnZS5vdXRwdXRUb2tlbnMgPSB2YWx1ZS51c2FnZS5jb21wbGV0aW9uX3Rva2VucztcbiAgICAgICAgICAgICAgdXNhZ2UudG90YWxUb2tlbnMgPSB2YWx1ZS51c2FnZS5wcm9tcHRfdG9rZW5zICsgdmFsdWUudXNhZ2UuY29tcGxldGlvbl90b2tlbnM7XG4gICAgICAgICAgICAgIG9wZW5yb3V0ZXJVc2FnZS5wcm9tcHRUb2tlbnMgPSB2YWx1ZS51c2FnZS5wcm9tcHRfdG9rZW5zO1xuICAgICAgICAgICAgICBpZiAodmFsdWUudXNhZ2UucHJvbXB0X3Rva2Vuc19kZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkSW5wdXRUb2tlbnMgPSAoX2ExNSA9IHZhbHVlLnVzYWdlLnByb21wdF90b2tlbnNfZGV0YWlscy5jYWNoZWRfdG9rZW5zKSAhPSBudWxsID8gX2ExNSA6IDA7XG4gICAgICAgICAgICAgICAgdXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnMgPSBjYWNoZWRJbnB1dFRva2VucztcbiAgICAgICAgICAgICAgICBvcGVucm91dGVyVXNhZ2UucHJvbXB0VG9rZW5zRGV0YWlscyA9IHtcbiAgICAgICAgICAgICAgICAgIGNhY2hlZFRva2VuczogY2FjaGVkSW5wdXRUb2tlbnNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9wZW5yb3V0ZXJVc2FnZS5jb21wbGV0aW9uVG9rZW5zID0gdmFsdWUudXNhZ2UuY29tcGxldGlvbl90b2tlbnM7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZS51c2FnZS5jb21wbGV0aW9uX3Rva2Vuc19kZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhc29uaW5nVG9rZW5zID0gKF9iID0gdmFsdWUudXNhZ2UuY29tcGxldGlvbl90b2tlbnNfZGV0YWlscy5yZWFzb25pbmdfdG9rZW5zKSAhPSBudWxsID8gX2IgOiAwO1xuICAgICAgICAgICAgICAgIHVzYWdlLnJlYXNvbmluZ1Rva2VucyA9IHJlYXNvbmluZ1Rva2VucztcbiAgICAgICAgICAgICAgICBvcGVucm91dGVyVXNhZ2UuY29tcGxldGlvblRva2Vuc0RldGFpbHMgPSB7XG4gICAgICAgICAgICAgICAgICByZWFzb25pbmdUb2tlbnNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9wZW5yb3V0ZXJVc2FnZS5jb3N0ID0gdmFsdWUudXNhZ2UuY29zdDtcbiAgICAgICAgICAgICAgb3BlbnJvdXRlclVzYWdlLnRvdGFsVG9rZW5zID0gdmFsdWUudXNhZ2UudG90YWxfdG9rZW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hvaWNlID0gdmFsdWUuY2hvaWNlc1swXTtcbiAgICAgICAgICAgIGlmICgoY2hvaWNlID09IG51bGwgPyB2b2lkIDAgOiBjaG9pY2UuZmluaXNoX3JlYXNvbikgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBmaW5pc2hSZWFzb24gPSBtYXBPcGVuUm91dGVyRmluaXNoUmVhc29uKGNob2ljZS5maW5pc2hfcmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoY2hvaWNlID09IG51bGwgPyB2b2lkIDAgOiBjaG9pY2UudGV4dCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgIGRlbHRhOiBjaG9pY2UudGV4dCxcbiAgICAgICAgICAgICAgICBpZDogZ2VuZXJhdGVJZCgpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJmaW5pc2hcIixcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YToge1xuICAgICAgICAgICAgICAgIG9wZW5yb3V0ZXI6IHtcbiAgICAgICAgICAgICAgICAgIHVzYWdlOiBvcGVucm91dGVyVXNhZ2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICByZXNwb25zZToge1xuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnNcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvZmFjYWRlLnRzXG52YXIgT3BlblJvdXRlciA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgT3BlblJvdXRlciBwcm92aWRlciBpbnN0YW5jZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHZhciBfYTE1LCBfYjtcbiAgICB0aGlzLmJhc2VVUkwgPSAoX2IgPSB3aXRob3V0VHJhaWxpbmdTbGFzaCgoX2ExNSA9IG9wdGlvbnMuYmFzZVVSTCkgIT0gbnVsbCA/IF9hMTUgOiBvcHRpb25zLmJhc2VVcmwpKSAhPSBudWxsID8gX2IgOiBcImh0dHBzOi8vb3BlbnJvdXRlci5haS9hcGkvdjFcIjtcbiAgICB0aGlzLmFwaUtleSA9IG9wdGlvbnMuYXBpS2V5O1xuICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycztcbiAgfVxuICBnZXQgYmFzZUNvbmZpZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmFzZVVSTDogdGhpcy5iYXNlVVJMLFxuICAgICAgaGVhZGVyczogKCkgPT4gX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7bG9hZEFwaUtleSh7XG4gICAgICAgICAgYXBpS2V5OiB0aGlzLmFwaUtleSxcbiAgICAgICAgICBlbnZpcm9ubWVudFZhcmlhYmxlTmFtZTogXCJPUEVOUk9VVEVSX0FQSV9LRVlcIixcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJPcGVuUm91dGVyXCJcbiAgICAgICAgfSl9YFxuICAgICAgfSwgdGhpcy5oZWFkZXJzKVxuICAgIH07XG4gIH1cbiAgY2hhdChtb2RlbElkLCBzZXR0aW5ncyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBPcGVuUm91dGVyQ2hhdExhbmd1YWdlTW9kZWwobW9kZWxJZCwgc2V0dGluZ3MsIF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgcHJvdmlkZXI6IFwib3BlbnJvdXRlci5jaGF0XCJcbiAgICB9LCB0aGlzLmJhc2VDb25maWcpLCB7XG4gICAgICBjb21wYXRpYmlsaXR5OiBcInN0cmljdFwiLFxuICAgICAgdXJsOiAoeyBwYXRoIH0pID0+IGAke3RoaXMuYmFzZVVSTH0ke3BhdGh9YFxuICAgIH0pKTtcbiAgfVxuICBjb21wbGV0aW9uKG1vZGVsSWQsIHNldHRpbmdzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IE9wZW5Sb3V0ZXJDb21wbGV0aW9uTGFuZ3VhZ2VNb2RlbChtb2RlbElkLCBzZXR0aW5ncywgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7XG4gICAgICBwcm92aWRlcjogXCJvcGVucm91dGVyLmNvbXBsZXRpb25cIlxuICAgIH0sIHRoaXMuYmFzZUNvbmZpZyksIHtcbiAgICAgIGNvbXBhdGliaWxpdHk6IFwic3RyaWN0XCIsXG4gICAgICB1cmw6ICh7IHBhdGggfSkgPT4gYCR7dGhpcy5iYXNlVVJMfSR7cGF0aH1gXG4gICAgfSkpO1xuICB9XG59O1xuXG4vLyBzcmMvcHJvdmlkZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZU9wZW5Sb3V0ZXIob3B0aW9ucyA9IHt9KSB7XG4gIHZhciBfYTE1LCBfYiwgX2M7XG4gIGNvbnN0IGJhc2VVUkwgPSAoX2IgPSB3aXRob3V0VHJhaWxpbmdTbGFzaCgoX2ExNSA9IG9wdGlvbnMuYmFzZVVSTCkgIT0gbnVsbCA/IF9hMTUgOiBvcHRpb25zLmJhc2VVcmwpKSAhPSBudWxsID8gX2IgOiBcImh0dHBzOi8vb3BlbnJvdXRlci5haS9hcGkvdjFcIjtcbiAgY29uc3QgY29tcGF0aWJpbGl0eSA9IChfYyA9IG9wdGlvbnMuY29tcGF0aWJpbGl0eSkgIT0gbnVsbCA/IF9jIDogXCJjb21wYXRpYmxlXCI7XG4gIGNvbnN0IGdldEhlYWRlcnMgPSAoKSA9PiBfX3NwcmVhZFZhbHVlcyh7XG4gICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2xvYWRBcGlLZXkoe1xuICAgICAgYXBpS2V5OiBvcHRpb25zLmFwaUtleSxcbiAgICAgIGVudmlyb25tZW50VmFyaWFibGVOYW1lOiBcIk9QRU5ST1VURVJfQVBJX0tFWVwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiT3BlblJvdXRlclwiXG4gICAgfSl9YFxuICB9LCBvcHRpb25zLmhlYWRlcnMpO1xuICBjb25zdCBjcmVhdGVDaGF0TW9kZWwgPSAobW9kZWxJZCwgc2V0dGluZ3MgPSB7fSkgPT4gbmV3IE9wZW5Sb3V0ZXJDaGF0TGFuZ3VhZ2VNb2RlbChtb2RlbElkLCBzZXR0aW5ncywge1xuICAgIHByb3ZpZGVyOiBcIm9wZW5yb3V0ZXIuY2hhdFwiLFxuICAgIHVybDogKHsgcGF0aCB9KSA9PiBgJHtiYXNlVVJMfSR7cGF0aH1gLFxuICAgIGhlYWRlcnM6IGdldEhlYWRlcnMsXG4gICAgY29tcGF0aWJpbGl0eSxcbiAgICBmZXRjaDogb3B0aW9ucy5mZXRjaCxcbiAgICBleHRyYUJvZHk6IG9wdGlvbnMuZXh0cmFCb2R5XG4gIH0pO1xuICBjb25zdCBjcmVhdGVDb21wbGV0aW9uTW9kZWwgPSAobW9kZWxJZCwgc2V0dGluZ3MgPSB7fSkgPT4gbmV3IE9wZW5Sb3V0ZXJDb21wbGV0aW9uTGFuZ3VhZ2VNb2RlbChtb2RlbElkLCBzZXR0aW5ncywge1xuICAgIHByb3ZpZGVyOiBcIm9wZW5yb3V0ZXIuY29tcGxldGlvblwiLFxuICAgIHVybDogKHsgcGF0aCB9KSA9PiBgJHtiYXNlVVJMfSR7cGF0aH1gLFxuICAgIGhlYWRlcnM6IGdldEhlYWRlcnMsXG4gICAgY29tcGF0aWJpbGl0eSxcbiAgICBmZXRjaDogb3B0aW9ucy5mZXRjaCxcbiAgICBleHRyYUJvZHk6IG9wdGlvbnMuZXh0cmFCb2R5XG4gIH0pO1xuICBjb25zdCBjcmVhdGVMYW5ndWFnZU1vZGVsID0gKG1vZGVsSWQsIHNldHRpbmdzKSA9PiB7XG4gICAgaWYgKG5ldy50YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJUaGUgT3BlblJvdXRlciBtb2RlbCBmdW5jdGlvbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBrZXl3b3JkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobW9kZWxJZCA9PT0gXCJvcGVuYWkvZ3B0LTMuNS10dXJiby1pbnN0cnVjdFwiKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ29tcGxldGlvbk1vZGVsKFxuICAgICAgICBtb2RlbElkLFxuICAgICAgICBzZXR0aW5nc1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYXRNb2RlbChtb2RlbElkLCBzZXR0aW5ncyk7XG4gIH07XG4gIGNvbnN0IHByb3ZpZGVyID0gKG1vZGVsSWQsIHNldHRpbmdzKSA9PiBjcmVhdGVMYW5ndWFnZU1vZGVsKG1vZGVsSWQsIHNldHRpbmdzKTtcbiAgcHJvdmlkZXIubGFuZ3VhZ2VNb2RlbCA9IGNyZWF0ZUxhbmd1YWdlTW9kZWw7XG4gIHByb3ZpZGVyLmNoYXQgPSBjcmVhdGVDaGF0TW9kZWw7XG4gIHByb3ZpZGVyLmNvbXBsZXRpb24gPSBjcmVhdGVDb21wbGV0aW9uTW9kZWw7XG4gIHJldHVybiBwcm92aWRlcjtcbn1cbnZhciBvcGVucm91dGVyID0gY3JlYXRlT3BlblJvdXRlcih7XG4gIGNvbXBhdGliaWxpdHk6IFwic3RyaWN0XCJcbiAgLy8gc3RyaWN0IGZvciBPcGVuUm91dGVyIEFQSVxufSk7XG5leHBvcnQge1xuICBPcGVuUm91dGVyLFxuICBjcmVhdGVPcGVuUm91dGVyLFxuICBvcGVucm91dGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@openrouter+ai-sdk-provider@1.2.0_ai@5.0.47_zod@3.25.76__zod@3.25.76/node_modules/@openrouter/ai-sdk-provider/dist/index.mjs\n");

/***/ })

};
;